Use: Locations: 'Kaeon United Specification'

Use: Locations: 'Kaeon United Specification: 1 - Philosophy: 1 - Code: 1 - Conventions: 1 - Modules: 1 - Philosopher~'s Suite'

-
	Philosopher's Suite
-
	-
		Philosophy
	-
		-
			A philosopher's suite is a defined set of utilities.
		-

Use: Locations: 'Kaeon United Specification: 1 - Philosophy: 1 - Code: 1 - Conventions: 1 - Modules: 1 - Philosopher~'s Suite: 1 - Philosopher~'s Suite Conventions'

-
	Philosopher's Suite Conventions
-
	-
		Philosophy
	-
		-
			This document lists conventions regarding philosopher's suites.
		-
	-
		Principles
	-
		-
			Constructs
		-
			-
				Standard Philosopher's Suite
			-
				-
					A standard philosopher's suite is a philosopher's suite of software utilities.
				-
			-
				Philosopher's Suite Atlas
			-
				-
					Philosopher's suites may include references to other philosopher's suites.

					A network of connected philosopher's suites is called a philosopher's suite
					atlas, and the contents of all philosopher's suites in a given philosopher's
					suite atlas can be rendered to a single philosopher's suite.
				-
			-
				Philosopher's Singularity
			-
				-
					A philosopher's singularity is an API that provides access to the contents of a
					philosopher's suite, which may be either imported into a program or executed as
					an application with arguments, and which may be called either locally or from a
					static endpoint, such that it will provide different elements of said
					philosopher's suite depending on the environment it is called from, the
					environment it is executed within, and, if applicable, the arguments passed to
					it, thus serving as a platform through which to provide a vast array of
					functionality via a single module.
				-
		-
			Terms
		-
			-
				A philosopher's suite may also be known as a union suite, and a philosopher's
				singularity may also be known as a union API.
			-

Use: Locations: 'Kaeon United Specification: 1 - Philosophy: 1 - Code: 1 - Conventions: 1 - Modules: 2 - Interface Module'

-
	Interface Module
-
	-
		Philosophy
	-
		-
			An interface module is a package containing a philosopher's suite in the form of
			utilities for various applications, as well as references to other interface modules.
		-
	-
		Principles
	-
		-
			Aliases
		-
			-
				An interface module shall have a string alias with which to identify it.
			-
		-
			Structure
		-
			-
				Connections
			-
				-
					An interface module may contain connections to other interface modules, which
					shall each specify the alias of the interface module it references, which may
					each specify methods of accessing the interface module it references, and which
					may optionally extend the contents of the interface module to which it belongs
					with the contents of the interface module it references, those that do so being
					called extension connections, and those that do not being called reference
					connections.
				-
			-
				Contents
			-
				-
					Each interface module acts as an interface utility.

					An interface utility has a string alias by which it may be referenced, and may
					contain other interface utilities.

					An interface utility may contain or reference an implementation of a module,
					called the utility source, interface utilities that do so being referred to as
					active interface utilities, and those that do not being referred to as inactive
					interface utilities.

					Among the set composed of a given interface utility and its descendants, the
					subset of said set including only the active interface utilities among it is
					referred to as the suite of said given interface utility.

					Interface properties are properties which apply to interface utilities, and
					which inform external environments regarding how to integrate and use the
					interface utilities to which they pertain.

					Interface utilities may have an indefinite number of interface properties.
				-
		-
			Interface Module Conventions
		-
			-
				A codified protocol specifying interface properties is called an interface module
				convention.
			-

Use: Locations: 'Kaeon United Specification: 1 - Philosophy: 1 - Code: 1 - Conventions: 1 - Modules: 2 - Interface Module: 1 - Conventions'

-
	Interface Module Conventions
-
	-
		Philosophy
	-
		-
			This document specifies conventions for interface modules.
		-
	-
		Principles
	-
		-
			Alias Reference
		-
			-
				An alias reference is a record specifying the aliases of various interface modules,
				as well as ways to access them.
			
				An interface module may be used as an alias reference via its connections.
			-
		-
			Interface Suites and Singularities
		-
			-
				An interface suite is a philosopher's suite implemented as an interface module, and
				an interface singularity is a philosopher's singularity which uses interface suites
				as its philosopher's suites.

				A standard interface singularity shall reference one interface suite as its default
				suite, from which it derives the content it delivers to its environment, and may
				optionally reference an indefinite number of other interface suites as alias
				references, or as extensions to its default suite.
			-

Use: Locations: 'Kaeon United Specification: 1 - Philosophy: 1 - Code: 1 - Conventions: 2 - Concepts: 1 - Trace Conventions'

-
	Trace Conventions
-
	-
		Philosophy
	-
		-
			The trace conventions are a set of conventions which may be used to search for content
			in graphs.
		-
	-
		Principles
	-
		-
			Conventions
		-
			-
				Concepts
			-
				-
					Graphs
				-
					-
						Trace Origin
					-
						-
							Any node within a graph from which all other nodes may be reached by
							traversal of the connections of said graph is called a trace origin.
						-
					-
						Trace Descendants
					-
						-
							If one node can be reached by traversing the connections of a graph
							from another node, the former node is referred to as a trace descendant
							of the latter.
							
							The minimum number of connections that must be traversed to reach a
							given trace descendant of a given node is referred to as the trace
							degree between them.
						-
				-
					Traversal
				-
					-
						Trace Traversal
					-
						-
							Trace traversal is the process of identifying a set of trace
							descendants of a given node, called the trace set, that meet certain
							criteria, said criteria being referred to trace classes, and that can
							be reached from said node without going through another member of said
							trace set, after which said descendants are sorted in order of trace
							degree from lowest to highest, and then sorted arbitrarily, their
							resulting placement being referred to as their trace index.
						-
					-
						Trace Relative Classes
					-
						-
							Certain trace classes, called trace relative classes, may assign nodes
							within a trace set scores from zero to one, inclusive, called trace
							scores, and trace traversals using trace relative classes shall sort
							the nodes of the resulting trace set in order of their trace score from
							highest to lowest, after sorting said nodes by trace degree and before
							sorting said nodes arbitrarily.
						-
					-
						Trace Path
					-
						-
							A trace path is a sequence of trace classes.
						-
			-
				Trace Path Traversal
			-
				-
					Trace path traversal is a sequence of trace traversals defined by a given trace
					path, which begins at a given node that matches the first trace class in the
					given trace path, and progresses from one node to another, iterating over the
					given trace path with each jump, such that the next node in the traversal is
					the one within a trace set, said set being that of the current node of the
					traversal and the next trace class of the iteration over the given trace path,
					with the lowest trace index for a standard trace path traversal, or with any
					other index for an atypical trace path traversal.
					
					For a given trace path traversal, the range of the trace degrees of each jump
					made in the course of said traversal is referred to as the trace range of said
					traversal, the lowest number in said range being referred to as the trace
					minimum of said traversal, and the highest number in said range being referred
					to as the trace maximum of said traversal.
					
					A trace path traversal with a trace maximum of one is referred to as a
					normalized trace path traversal.
					
					A trace path traversal where certain jumps cannot be made due to the specified
					descendant not existing is referred to as invalid, whereas any other trace path
					traversal is referred to as valid.
				-
		-
			Trace Filtering
		-
			-
				Trace filtering is a process which, using a given graph and a given trace path,
				identifies nodes within said graph that may be reached at the end of trace path
				traversals within said graph using said trace path.
			-

Use: Locations: 'Kaeon United Specification: 1 - Philosophy: 1 - Code: 1 - Conventions: 2 - Concepts: 1 - Trace Conventions: 1 - Tag Trace'

-
	Tag Trace
-
	-
		Philosophy
	-
		-
			Alphanumeric identifiers, called trace tags, assigned to nodes in a graph to which the
			trace conventions are applied, may be used by trace classes, called tag trace classes,
			which filter for nodes to which certain specific trace tags are assigned.
		-
	-
		Principles
	-
		-
			Terms
		-
			-
				Trace paths consisting solely of tag trace classes may be referred to as tag trace
				paths.
				
				Tag trace classes requiring only one trace tag may be referred to as single tag
				trace classes, and tag trace paths which only contain single tag trace classes may
				be referred to as single tag trace paths.
				
				Nodes which utilize trace tags may be referred to as tag trace modules.
			-
		-
			Tag Trace IDs
		-
			-
				For a given single tag trace path, the sequence of trace tags derived from said
				path is referred to as a tag trace ID.
			-

Use: Locations: 'Kaeon United Specification: 1 - Philosophy: 1 - Code: 1 - Conventions: 2 - Concepts: 2 - Data: 1 - Supervalid Language'

-
	Supervalid Language
-
	-
		Philosophy
	-
		-
			A supervalid language is a language syntax for which there is no invalid input.
		-
	-
		Principles
	-
		-
			Subvalid Language
		-
			-
				A subvalid language is a language syntax that is not supervalid.
			-
		-
			Extravalid Ruleset
		-
			-
				An extravalid ruleset is a set of rules that extend an existing subvalid language
				in order to render it supervalid.
			-

Use: Locations: 'Kaeon United Specification: 1 - Philosophy: 1 - Code: 1 - Conventions: 2 - Concepts: 2 - Data: 2 - Graph Document'

-
	Graph Document
-
	-
		Philosophy
	-
		-
			Document formats which encode their content as a tree may be used to represent
			amorphous graphs through constructs, called graph references, which represent links
			between their parent nodes and nodes located elsewhere.
		-

Use: Locations: 'Kaeon United Specification: 1 - Philosophy: 1 - Code: 1 - Conventions: 3 - The Kaeon Process'

-
	The Kaeon Process
-
	-
		Philosophy
	-
		-
			The Kaeon process is a project development methodology.
		-
	-
		Principles
	-
		-
			The Three Branches
		-
			-
				A project developed under the Kaeon process has three branches, these being the
				specification, the documentation, and the implementations.

				The specification is a set of written texts that define and specify the nature and
				aspects of the product or service that the developers intend to produce.

				The documentation are the documents that outline all aspects of the project that
				lie outside the scope of the specification.

				An implementation, of which there may be many, is a partially or completely
				developed product or service engineered according to the terms of the
				specification.
			-
		-
			Conventions
		-
			-
				Crystallization and Fragmentation
			-
				-
					Combining the specifications of multiple projects into a single specification
					is referred to as project crystallization, and the separation of a single
					specification into multiple specifications for separate projects is referred to
					as project fragmentation.
				-
			-
				Project Pivots
			-
				-
					The specification may be modified at any time and for any reason, after which
					the documentation and the implementations must be changed in order to conform
					to it.

					Thus, any major update to the plan of the project should begin with a
					modification to the specification.

					Such an update can be called a project pivot.
				-
			-
				Term Hierarchy
			-
				-
					The terms of the specification should be arranged into a hierarchy, ordered
					with the most fundamental elements of the project closer to the top and the
					least fundamental elements of the project closer to the bottom.

					There should be a single term at the top of the hierarchy that defines the
					overall idea of the project called the master term.
				-

Use: Locations: 'Kaeon United Specification: 1 - Philosophy: 1 - Code: 2 - ONE'

-
	ONE
-
	-
		Philosophy
	-
		-
			ONE is a system for organizing data.
		-
	-
		Principles
	-
		-
			Elements
		-
			-
				ONE stores data in elements.
				
				An element must contain a string of characters, and may act as a parent to other
				elements.
				
				The children of a given element must be arranged in a specific order relative to
				each other. No element may be the child of more than one element, and no loops may
				occur in the chain of parent-child connections.
			-

Use: Locations: 'Kaeon United Specification: 1 - Philosophy: 1 - Code: 2 - ONE: 1 - Conventions'

-
	ONE Conventions
-
	-
		Philosophy
	-
		-
			The ONE conventions are a set of principles regarding ONE that should be applied in any
			scenario where ONE is relevant.
		-
	-
		Principles
	-
		-
			Element Data
		-
			-
				Content
			-
				-
					The string contained by an element is referred to as its content.
				-
			-
				Scope
			-
				-
					Any element that may be accessed by trickling down through the child
					connections of another element are said to be in the latter element's scope.
				-
			-
				Index
			-
				-
					The position of an element relative to its siblings within the scope of its
					parent is referred to as its index, and is specified as an integer number,
					where said numbers start at one.
				-
		-
			Default Element
		-
			-
				By default, an element will have an empty string as its content and will have no
				children.
			-

Use: Locations: 'Kaeon United Specification: 1 - Philosophy: 1 - Code: 2 - ONE: 1 - Conventions: 1 - ONE Language'

-
	ONE Language
-
	-
		Philosophy
	-
		-
			The ONE language is a syntax for encoding ONE elements.
			
			A unit of text written in the ONE language is referred to as a ONE document.
		-
	-
		Principles
	-
		-
			Syntax
		-
			-
				The ONE language requires three unique sequences of characters to be defined: the
				terminating sequence, the breaking sequence, and the nesting sequence. It is not
				permitted for the sequences to be defined such that there may be any instances
				where two or more sequences conflict at a given location.
				
				The ONE language is composed entirely of ONE element definitions. No characters are
				permitted outside of element definitions.
				
				An element definition begins with the terminating sequence, followed by the
				breaking sequence, followed by the nesting sequence. The nesting sequence may be
				followed by any sequence of characters as long as the breaking sequence does not
				occur within it. This sequence is referred to as the encoded sequence. The encoded
				sequence is followed by the breaking sequence, which must be followed either with
				the nesting sequence which continues the element definition, or by the terminating
				sequence which ends the element definition. If an element definition precedes
				another element definition, the final terminating sequence of the preceding element
				definition must be followed by the breaking sequence.
				
				Element definitions may be nested within one another. If an element definition is
				nested within another element definition, the child element definition must be
				placed directly after either its parent or after another element definition nested
				within the scope of its parent. For every terminating sequence that does not occur
				with an encoded sequence and for every nesting sequence which immediately precedes
				an encoded sequence within the element definition, one instance of the nesting
				sequence must be placed between the breaking sequence that precedes said sequence
				and said sequence for every level the element definition is nested.
			-
		-
			Semantics
		-
			-
				The encoded data will all reside within the scope of an element with no parent and
				an empty string as its content referred to as the document element.
				
				Every element definition with no parent will encode an element as a child of the
				document element. Every element definition with a parent will encode an element as
				a child of the element defined by its parent element definition.
				
				The content encoded into elements defined by element definitions will consist of
				the content of each encoded sequence within the respective element definition, each
				with the exception of the content of the last occurring encoded sequence within the
				respective element definition followed by an instance of the breaking sequence,
				concatenated in the order in which the respective encoded sequences occur within
				the respective element definition.
				
				The order in which elements defined by element definitions are arranged within
				their parent element shall correspond to the order in which the definitions that
				defined them are written.
			-
		-
			Encoding
		-
			-
				A ONE element can only be encoded as a ONE document if it has an empty string as
				its content. Said element will become the document element of the document.
			-

Use: Locations: 'Kaeon United Specification: 1 - Philosophy: 1 - Code: 2 - ONE: 1 - Conventions: 1 - ONE Language: 1 - Standard ONE Language'

-
	Standard ONE Language
-
	-
		Philosophy
	-
		-
			The standard variant of the ONE Language defines specific sequences of characters as
			the three required sequences of the ONE language.
		-
	-
		Principles
	-
		-
			Standard Sequences
		-
			-
				Terminating Sequence
			-
				-
					In the standard variant of the ONE Language, the terminating sequence is a
					dash.
				-
			-
				Breaking Sequence
			-
				-
					In the standard variant of the ONE Language, the breaking sequence is a new
					line.
				-
			-
				Nesting Sequence
			-
				-
					In the standard variant of the ONE Language, the nesting sequence is a tab.
				-

Use: Locations: 'Kaeon United Specification: 1 - Philosophy: 1 - Code: 2 - ONE: 1 - Conventions: 1 - ONE Language: 2 - Conventions: 1 - ONE Wrapping'

-
	ONE Wrapping
-
	-
		Philosophy
	-
		-
			ONE wrapping is the practice of wrapping the content of ONE documents.
		-
	-
		Principles
	-
		-
			ONE Wrapping Standard
		-
			-
				A ONE wrapping standard defines a tab width and a character limit.
				
				For a given ONE wrapping standard, the content of each element in a ONE document
				that abides by it must be wrapped such that a rendering of the entire document with
				the specified tab width shall have no lines in excess of the character limit.
			-
		-
			ONE Unwrapping
		-
			-
				ONE unwrapping in the process of taking all contiguous sequences of lines in a
				given ONE element which have any non-whitespace characters and replacing them with
				a line generated by concatenating said lines together in order, separated by a
				given separator character.

				The default separator character is a space.
			-
		-
			Kaeon Document Conventions
		-
			-
				For a Kaeon document, each sentence or paragraph in an element should be conceived
				as a single line, which is to be wrapped in accordance with a ONE wrapping
				standard. Each paragraph in such an element should be separated by a blank line.

				The default ONE wrapping standard for Kaeon documents is a tab width of four and a
				character limit of ninety-nine.
			-

Use: Locations: 'Kaeon United Specification: 1 - Philosophy: 1 - Code: 2 - ONE: 1 - Conventions: 1 - ONE Language: 2 - Conventions: 2 - ONE Variants: 1 - Reduced ONE Language'

-
	Reduced ONE Language
-
	-
		Philosophy
	-
		-
			The reduced ONE language is an alternate form of the ONE language where all instances
			of the terminating sequence except for those that occur within encoded sequences are
			omitted.
		-

Use: Locations: 'Kaeon United Specification: 1 - Philosophy: 1 - Code: 2 - ONE: 1 - Conventions: 1 - ONE Language: 2 - Conventions: 2 - ONE Variants: 2 - Supervalid ONE'

-
	Supervalid ONE
-
	-
		Philosophy
	-
		-
			Supervalid ONE is an extravalid ruleset for the ONE language.
		-
	-
		Principles
	-
		-
			Whitespace
		-
			-
				Improperly placed whitespace shall be ignored by supervalid ONE.
			-
		-
			Dysfunctional Lines
		-
			-
				Any lines with improperly placed non-whitespace characters shall be ignored
				entirely, as shall any element definition containing said lines.
			-

Use: Locations: 'Kaeon United Specification: 1 - Philosophy: 1 - Code: 2 - ONE: 1 - Conventions: 1 - ONE Language: 2 - Conventions: 3 - ONE Trace'

-
	ONE Trace
-
	-
		Philosophy
	-
		-
			ONE elements may function as trace tag modules, with their content and index as trace
			tags, and their children as connections.
		-

Use: Locations: 'Kaeon United Specification: 1 - Philosophy: 1 - Code: 2 - ONE: 2 - Application: 1 - ACE'

-
	ACE
-
	-
		Philosophy
	-
		-
			ACE is a system that allows ONE elements to be interpreted as object nodes within an
			object model, structured according to their placement relative to each other.
		-
	-
		Principles
	-
		-
			Content
		-
			-
				A ONE element under the ACE system is referred to as an ACE element, and a ONE
				document under the ACE system is referred to as an ACE document.
			-
		-
			Conventions
		-
			-
				A codified protocol specifying how an ACE element is to be interpreted according to
				its content and children is referred to as an ACE convention.
			-

Use: Locations: 'Kaeon United Specification: 1 - Philosophy: 1 - Code: 2 - ONE: 2 - Application: 1 - ACE: 1 - Conventions: 1 - Elements: 1 - ACE Reference'

-
	ACE Reference
-
	-
		Philosophy
	-
		-
			ACE elements used as graph references are referred to as ACE references.
		-

Use: Locations: 'Kaeon United Specification: 1 - Philosophy: 1 - Code: 2 - ONE: 2 - Application: 1 - ACE: 1 - Conventions: 1 - Elements: 1 - ACE Reference: 1 - ACE Reference Conventions'

-
	ACE Reference Conventions
-
	-
		Philosophy
	-
		-
			This document specifies conventions for ACE references.
		-
	-
		Principles
	-
		-
			Conventions
		-
			-
				Attributes
			-
				-
					Aliases
				-
					-
						ACE references shall specify aliases for their targets.
					-
				-
					Targets
				-
					-
						ACE references may each have multiple targets.
						
						Said targets shall be arranged in a specific order by index, said indices
						starting at one.

						The target with the lowest index shall be referred to as the default
						target.
					-
			-
				Types
			-
				-
					Connection
				-
					-
						ACE references may optionally extend the document to which they belong,
						those that do being referred to as extension ACE references, and those that
						do not being referred to as non-extension ACE references.

						The default interpretation of extension ACE references has them swapped out
						for their targets, but this may be altered by the properties of the
						document to which they belong.
						
						With the default interpretation, an additional default behavior is the
						automatic filtering of looping connections.

						A codified protocol for an alternate means of interpreting extension ACE
						references is referred to as an ACE extension convention.
					-
				-
					Content
				-
					-
						An ACE reference that targets ONE elements is referred to as a standard ACE
						reference, and an ACE reference that targets anything else is referred to
						as a general ACE reference.
					-

Use: Locations: 'Kaeon United Specification: 1 - Philosophy: 1 - Code: 2 - ONE: 2 - Application: 1 - ACE: 1 - Conventions: 1 - Elements: 2 - ACE Command'

-
	ACE Command
-
	-
		Philosophy
	-
		-
			An ACE command is an object that may be passed to a simulation, said simulation being
			organized according to an ACE document, in order to modify said simulation's properties
			at runtime.

			Such a simulation is referred to as an ACE context.
		-
	-
		Principles
	-
		-
			Types
		-
			-
				An ACE command that is formatted as a ONE document is referred to as a ONE ACE
				command.

				An ACE command that is not a ONE ACE command is referred to as a general ACE
				command.
			-

Use: Locations: 'Kaeon United Specification: 1 - Philosophy: 1 - Code: 2 - ONE: 2 - Application: 1 - ACE: 1 - Conventions: 2 - Usage Document'

-
	Usage Document
-
	-
		Philosophy
	-
		-
			A usage document is an ACE document maintained during and within the runtime of a
			process.
		-
	-
		Principles
	-
		-
			The Use Convention
		-
			-
				In a ONE document which is not an ACE document, but to which the use convention is
				applied, a use element, which is any element for which the content is "Use" and
				which has no ancestor element with the content "Use", letter case irrelevant, shall
				be interpreted such that its children shall be implicitly added, in the order which
				said use element occurs relative to other use elements in its document, to the root
				of a usage document.

				This may also be done with an ordered set of ONE documents to generate a single
				usage document, the relevant contents of said documents being added to said usage
				document in said order.

				ACE content declared within use elements may take into account the location of said
				use elements and the surrounding content thereof when being interpreted.

				The general use convention extends the use convention, and holds that, when
				interpreting a ONE document as an ACE document where it is unknown whether or not
				said document is intended as an ACE document, the use convention shall be applied
				to said document if a use element is present within it, and if no use element is
				present within said document, the entire document shall be interpreted as an ACE
				document.
			-

Use: Locations: 'Kaeon United Specification: 1 - Philosophy: 1 - Code: 2 - ONE: 2 - Application: 1 - ACE: 2 - Kaeon ACE'

-
	Kaeon ACE
-
	-
		Philosophy
	-
		-
			Kaeon ACE is an ACE convention for using ACE to define a component-entity tree.
		-
	-
		Principles
	-
		-
			Elements
		-
			-
				Kaeon ACE Elements
			-
				-
					A Kaeon ACE element is an ACE element that represents an entity. It may, among
					other children, have a child with the content "Entities", and may also have a
					child with the content "Components".

					The content of a Kaeon ACE element specifies its alias.

					The entities element may have an indefinite number of Kaeon ACE elements as its
					children.

					The components element may have an indefinite number of elements as children,
					all of which shall be interpreted as component elements.

					A component element represents a component of the entity to which it belongs,
					its content specifying its alias, and possibly its type, and its children
					specifying its content.

					The order in which Kaeon ACE entities are declared relative to other Kaeon ACE
					entities within their parent Kaeon ACE entity, and the order in which Kaeon ACE
					components are declared relative to other Kaeon ACE components within their
					parent Kaeon ACE entity is referred to as their index, which starts at one.
				-
		-
			Conventions
		-
			-
				General
			-
				-
					Content
				-
					-
						The default alias for an entity is "Entity", and the default alias for a
						component is "Component".

						The letter case of element content in Kaeon ACE is irrelevant.
					-
				-
					Components
				-
					-
						Isolated Components
					-
						-
							Kaeon ACE components may be used outside of Kaeon ACE elements within
							generic ACE.
						-
					-
						Kaeon ACE Nodes
					-
						-
							Any child of a Kaeon ACE entity other than the entities element and the
							components element may be interpreted as both a Kaeon ACE element and
							as a Kaeon ACE component, and if the entities element or the components
							element have no children, they shall be interpreted as such.

							Elements interpreted this way are referred to as Kaeon ACE nodes.

							If Kaeon ACE content does not contain any Kaeon ACE nodes, it is said
							to be in proper form, whereas if it does contain Kaeon ACE nodes, it is
							said to be in improper form.
						-
				-
					Root as Entity
				-
					-
						The root of a Kaeon ACE document shall be interpreted as a Kaeon ACE
						entity.
					-
			-
				Kaeon ACE Conventions
			-
				-
					A codified protocol specifying how a component element is to be interpreted
					according to its content and children is referred to as a Kaeon ACE convention.
				-

Use: Locations: 'Kaeon United Specification: 1 - Philosophy: 1 - Code: 2 - ONE: 2 - Application: 1 - ACE: 2 - Kaeon ACE: 1 - Conventions: 1 - Elements: 1 - Constructs: 1 - Subcomponents'

-
	Kaeon ACE Subcomponents
-
	-
		Philosophy
	-
		-
			All elements in the scope of Kaeon ACE component elements shall be called
			subcomponents, and shall specify the properties of the component to which they belong.
		-
	-
		Principles
	-
		-
			Subcomponent Orders
		-
			-
				The depth at which a subcomponent is nested relative to the component to which it
				belongs is referred to as its order.
				
				Subcomponent orders begin at one.
			-
		-
			Predefinition
		-
			-
				Predefined subcomponent types are referred to as defined subcomponents.

				Undefined subcomponent types are referred to as undefined subcomponents.

				If defined subcomponent types may have any order, then they are referred to as
				unordered subcomponents.
				
				If defined subcomponents must select from a certain subset of orders, then they are
				referred to as ordered subcomponents.

				If ordered subcomponents have only one possible order, then they are referred to as
				single ordered subcomponents.

				If ordered subcomponents have more than one possible order, then they are referred
				to as multiple ordered subcomponents.
			-

Use: Locations: 'Kaeon United Specification: 1 - Philosophy: 1 - Code: 2 - ONE: 2 - Application: 1 - ACE: 2 - Kaeon ACE: 1 - Conventions: 1 - Elements: 1 - Constructs: 2 - Prefabs'

-
	Kaeon ACE Prefabs
-
	-
		Philosophy
	-
		-
			Kaeon ACE prefabs are predefined combinations of subcomponents, components, and
			entities.
		-
	-
		Principles
	-
		-
			Types
		-
			-
				Static Kaeon ACE prefabs are Kaeon ACE prefabs that may not have any variation.

				Dynamic Kaeon ACE prefabs are Kaeon ACE prefabs that may vary based on a given set
				of arguments.
			-
		-
			Core Prefab
		-
			-
				A core prefab is a Kaeon ACE prefab that defines the overall structure of a Kaeon
				ACE document.
			-
		-
			Prefab Set
		-
			-
				A prefab set is a set of Kaeon ACE prefabs.
			-

Use: Locations: 'Kaeon United Specification: 1 - Philosophy: 1 - Code: 2 - ONE: 2 - Application: 1 - ACE: 2 - Kaeon ACE: 1 - Conventions: 1 - Elements: 2 - Trace'

-
	Kaeon ACE Trace
-
	-
		Philosophy
	-
		-
			Kaeon ACE entities may function as tag trace modules, with their aliases, the aliases
			of their components, and their indices functioning as trace tags, and their children
			functioning as their connections.
		-

Use: Locations: 'Kaeon United Specification: 1 - Philosophy: 1 - Code: 2 - ONE: 2 - Application: 1 - ACE: 2 - Kaeon ACE: 1 - Conventions: 2 - Formats: 1 - Metadata: 1 - Components: 1 - META Component'

-
	Kaeon ACE META
-
	-
		Philosophy
	-
		-
			The Kaeon ACE META component convention is a Kaeon ACE convention regarding Kaeon ACE
			META components.

			A Kaeon ACE META component is a Kaeon ACE component element with the content "META",
			the children of which are Kaeon ACE component elements that, rather than applying
			solely to the entity to which the Kaeon ACE META component belongs to, shall also apply
			to said entity's descendant entities, unless overridden by the components of said
			descendants.
		-
	-
		Principles
	-
		-
			Kaeon ACE Void
		-
			-
				The Kaeon ACE void component convention is a Kaeon ACE convention regarding Kaeon
				ACE void components.

				A Kaeon ACE void component is a Kaeon ACE component element with the content
				"Void", the content of the children of which specify the aliases of Kaeon ACE
				components that the Kaeon ACE entity to which said Kaeon ACE void component
				belongs, and said Kaeon ACE entity's descendant Kaeon ACE entities, shall not
				inherit from said Kaeon ACE entity's ancestor Kaeon ACE entities via the Kaeon ACE
				META component. If a Kaeon ACE void component has no children, it shall block the
				inheritance of all such Kaeon ACE components.
			-

Use: Locations: 'Kaeon United Specification: 1 - Philosophy: 1 - Code: 2 - ONE: 2 - Application: 1 - ACE: 2 - Kaeon ACE: 1 - Conventions: 2 - Formats: 1 - Metadata: 1 - Components: 2 - Status: 1 - Global'

-
	Kaeon ACE Global
-
	-
		Philosophy
	-
		-
			The Kaeon ACE global component convention is a Kaeon ACE convention regarding Kaeon ACE
			global components.

			A Kaeon ACE global component is a Kaeon ACE component element with the content
			"Global".

			If attached to a given entity, it will cause any other entity that shares its alias to
			share said given entity's components, unless said components are overridden by the
			components of said other entity.
		-

Use: Locations: 'Kaeon United Specification: 1 - Philosophy: 1 - Code: 2 - ONE: 2 - Application: 1 - ACE: 2 - Kaeon ACE: 1 - Conventions: 2 - Formats: 1 - Metadata: 1 - Components: 2 - Status: 2 - Reserve'

-
	Kaeon ACE Reserve
-
	-
		Philosophy
	-
		-
			The Kaeon ACE reserve component convention is a Kaeon ACE convention regarding Kaeon
			ACE reserve components.

			A Kaeon ACE reserve component is a Kaeon ACE component element with the content
			"Reserve".

			If attached to a given entity, it will prevent said entity from having an effect within
			an ACE context, however, the effect of this component is disabled where an entity it is
			attached to is called upon via reference.
		-

Use: Locations: 'Kaeon United Specification: 1 - Philosophy: 1 - Code: 2 - ONE: 2 - Application: 1 - ACE: 2 - Kaeon ACE: 1 - Conventions: 2 - Formats: 1 - Metadata: 1 - Components: 3 - Data: 1 - File'

-
	Kaeon ACE File
-
	-
		Philosophy
	-
		-
			The Kaeon ACE file component convention is a Kaeon ACE convention regarding Kaeon ACE
			file components.

			A Kaeon ACE file component is a Kaeon ACE component element with the content "File".

			It shall have children which each specify a path to a given resource, with the
			available paths being preferred in order of their index, and shall represent said
			resource as itself being a component of the Kaeon ACE entity to which the component
			belongs.
		-

Use: Locations: 'Kaeon United Specification: 1 - Philosophy: 1 - Code: 2 - ONE: 2 - Application: 1 - ACE: 2 - Kaeon ACE: 1 - Conventions: 2 - Formats: 1 - Metadata: 1 - Components: 3 - Data: 2 - Content'

-
	Kaeon ACE Content
-
	-
		Philosophy
	-
		-
			The Kaeon ACE content component convention is a Kaeon ACE convention regarding Kaeon
			ACE content components.

			A Kaeon ACE content component is a Kaeon ACE component element with the content
			"Content". It may also be used as a Kaeon ACE subcomponent.

			It may have any children, and has no function in and of itself.

			Codified conventions for the children and effects of Kaeon ACE content components are
			referred to as Kaeon ACE content conventions.
		-

Use: Locations: 'Kaeon United Specification: 1 - Philosophy: 1 - Code: 2 - ONE: 2 - Application: 1 - ACE: 2 - Kaeon ACE: 1 - Conventions: 2 - Formats: 1 - Metadata: 2 - Query ACE'

-
	Query ACE
-
	-
		Philosophy
	-
		-
			Query ACE is a set of Kaeon ACE conventions used to specify ACE references.
		-
	-
		Principles
	-
		-
			Conventions
		-
			-
				Format
			-
				-
					Entities
				-
					-
						The Kaeon ACE components of query ACE, called the query ACE components,
						specify properties of ACE references, and Kaeon ACE entities to which query
						ACE components are applied, called query entities, represent ACE references
						to which said properties apply, the aliases of said entities specifying the
						aliases of the targets of said references.
					-
				-
					Aliases
				-
					-
						Once the target of a query entity is explicitly specified, its alias shall
						become implicitly associated with said target until it is explicitly
						redefined.
					-
			-
				Components
			-
				-
					Reserve
				-
					-
						Any ACE reference to which the reserve component is not applied is an
						extension ACE reference.
					-
				-
					ACE Component
				-
					-
						A Kaeon ACE component with the content "ACE" may have a query ACE document,
						which is a Kaeon ACE document containing query entities, embedded within
						it, which extends the contents of the Kaeon ACE entity to which it applies,
						in accordance with the other components which apply to said Kaeon ACE
						entity.
					-
		-
			Query ACE Components
		-
			-
				Locations
			-
				-
					The locations component is a Kaeon ACE component with the content "Locations",
					which may have an indefinite number of children that specify possible locations
					of documents in which to find the target of the ACE references to which it
					applies, with the first locations listed given preference.

					If multiselect status is in effect, all of the specified locations which are
					available shall be targeted.

					If this component is not present, it shall be assumed that the targets of the
					query entities to which it would otherwise apply are located in the documents
					that said query entities belong to, or that the targets of the query entities
					to which it would otherwise apply are in locations specified implicitly the
					aliases of said query entities.
				-
			-
				Path
			-
				-
					The path component is a Kaeon ACE component which may have an indefinite number
					of children that specify trace classes for ONE elements or for Kaeon ACE
					entities, specifying said classes in the order of their element indices,
					forming a trace path to the origin element of the target of the query entities
					to which it applies from the root of the documents that said targets are
					located in, the origin element either being the target itself or the reference
					point relative to which the target is defined by some other criteria.

					The children of the path component may either specify tag trace classes or
					model trace classes.

					For children specifying tag trace classes, they shall have the content "Tags",
					and may have an indefinite number of children, each of which specifying a trace
					tag that a node must have.

					For children specifying trace model classes, which are trace relative classes,
					they shall have the content "Model", and its children shall specify a model
					element relative to which each ONE element within a trace set shall be assigned
					a trace score according to how closely they match the model element, with a
					higher trace score meaning greater resemblance.

					This component can only be used for standard ACE references, and if it is not
					present, it shall be assumed that the origin elements of the targets of the
					query entities to which it would otherwise apply are either the root of the
					documents they are located in.

					The path component shall have the content "ONE Path" if it is targeting a
					generic ONE element in a generic ONE document, and it shall have the content
					"ACE Path" if it is targeting a Kaeon ACE entity in the usage document of a
					Kaeon ACE document.
				-
			-
				Multiselect
			-
				-
					The multiselect component is a Kaeon ACE component with the content
					"Multiselect", and indicates that an ACE reference it is applied to has
					multiselect status, meaning it may target multiple ACE elements.

					If multiple targets are selected, their indices shall be assigned according to
					the indices of the query ACE components which targeted them.
				-

Use: Locations: 'Kaeon United Specification: 1 - Philosophy: 1 - Code: 2 - ONE: 2 - Application: 1 - ACE: 2 - Kaeon ACE: 1 - Conventions: 2 - Formats: 2 - Standard Kaeon ACE'

-
	Standard Kaeon ACE
-
	-
		Philosophy
	-
		-
			Standard Kaeon ACE is a set of Kaeon ACE conventions consisting of the Kaeon ACE META
			component convention, the Kaeon ACE void component convention, the Kaeon ACE global
			component convention, the Kaeon ACE reserve component convention, and the query ACE
			conventions.
		-
	-
		Principles
	-
		-
			Letter Case
		-
			-
				The letter case of the component aliases specified by standard Kaeon ACE is
				irrelevant.
			-
		-
			General Use Convention
		-
			-
				Unless stated otherwise, standard Kaeon ACE document shall be interpreted according
				to the general use convention.
			-

Use: Locations: 'Kaeon United Specification: 1 - Philosophy: 1 - Code: 2 - ONE: 2 - Application: 1 - ACE: 2 - Kaeon ACE: 2 - Interface ACE'

-
	Interface ACE
-
	-
		Philosophy
	-
		-
			Interface ACE is a set of ACE extension conventions and Kaeon ACE conventions for
			encoding the content of interface modules.
		-
	-
		Principles
	-
		-
			Format
		-
			-
				Under interface ACE, an entity may represent an interface utility if it has a
				source component, or is a query entity, either method serving to specify the
				utility source of said utility.

				Such entities are called interface entities, and the alias of an interface entity
				specifies the alias of the interface utility it represents.

				A source component is a Kaeon ACE component with the content "Source", which may
				have any children such that said children specify the utility source of the
				interface utility that the interface entity it belongs to represents.

				If an interface entity is a query entity, its default target shall represent the
				utility source of the interface utility that said interface entity represents.

				If an interface entity is a query entity with a source component, the utility
				source specified by the source component may be defaulted to if no target can be
				located when query ACE is applied to said entity, while the default target
				identified by query ACE will take priority if it can be located.
			-

Use: Locations: 'Kaeon United Specification: 1 - Philosophy: 1 - Code: 2 - ONE: 2 - Application: 1 - ACE: 2 - Kaeon ACE: 2 - Interface ACE: 1 - Standard Interface Ace'

-
	Standard Interface ACE
-
	-
		Philosophy
	-
		-
			Standard interface ACE is a set of Kaeon ACE conventions consisting of the standard
			Kaeon ACE conventions and the interface ACE conventions.
		-
	-
		Principles
	-
		-
			Letter Case
		-
			-
				The letter case of the component aliases specified by standard interface ACE is
				irrelevant.
			-

Use: Locations: 'Kaeon United Specification: 1 - Philosophy: 1 - Code: 2 - ONE: 2 - Application: 2 - FUSION'

-
	FUSION
-
	-
		Philosophy
	-
		-
			FUSION is a system that allows any ONE element to serve as code.
		-
	-
		Principles
	-
		-
			Order of Operations
		-
			-
				Step One
			-
				-
					FUSION will be given a ONE element to start at.
				-
			-
				Step Two
			-
				-
					Based on the current element, FUSION will perform an operation.
					
					If the current element has no children, FUSION will proceed to step three.
					
					If the current element does have children, then based on the current element,
					FUSION will decide whether or not to trickle down to the current element's
					children.
					
					If it decides to do so, FUSION will shift focus to the current element's first
					child, and repeat step two. Otherwise, FUSION will proceed to step three.
				-
			-
				Step Three
			-
				-
					Based on the current element, FUSION will perform an operation and generate a
					value.
					
					Any values previously generated by performing step three on the current
					element's children and stored by FUSION will then be deleted.
					
					FUSION will then decide based on the current element whether the generated
					value will be used as an argument when performing operations on the current
					element's parent.
					
					If it decides to use the value as an argument, the order in which it was
					generated relative to any such values generated by the siblings of the current
					element will be held relevant.
				-
			-
				Step Four
			-
				-
					Based on the current element, FUSION will decide whether or not to terminate.
					
					If FUSION decides not to terminate, it will decide based on the current element
					whether or not to jump to another element.
					
					If it chooses to jump to another element, any values that were generated during
					step three and stored by FUSION that were to be used as arguments when
					performing operations on another element will be deleted, and FUSION will loop
					back to step two.
					
					If it chooses not to jump to another element and the current element is
					followed by a sibling element, FUSION will shift focus to the next sibling and
					loop back to step two.
					
					If it chooses not to jump to another element and the current element is not
					followed by a sibling element but does have a parent, FUSION will shift focus
					to the current element's parent, and loop back to step three.
					
					If none of the aforementioned conditions are met, FUSION will terminate.
				-
		-
			Commands
		-
			-
				An element being operated on by FUSION is referred to as a command.
				
				By default, commands will do the following unless otherwise specified:
				
				At step two, a command will perform no operation and will trickle down.
				
				At step three, a command will perform no operation, generate a null value, and
				allow the generated value to be used as an argument for its parent.
				
				At step four, a command will not terminate and will not jump to another element.
			-
		-
			Error Handling
		-
			-
				If an error occurs during any step, FUSION will skip over said step and proceed as
				if nothing happened.
			-

Use: Locations: 'Kaeon United Specification: 1 - Philosophy: 1 - Code: 2 - ONE: 2 - Application: 2 - FUSION: 1 - Kaeon FUSION'

-
	Kaeon FUSION
-
	-
		Philosophy
	-
		-
			Kaeon FUSION is a dialect of FUSION.
			
			It starts only with the functionality necessary to expand its functionality at runtime.
		-

Use: Locations: 'Kaeon United Specification: 1 - Philosophy: 1 - Code: 2 - ONE: 2 - Application: 2 - FUSION: 1 - Kaeon FUSION: 1 - Conventions'

-
	Kaeon FUSION Conventions
-
	-
		Philosophy
	-
		-
			Kaeon FUSION establishes certain conventions in addition to those established by
			FUSION.
		-
	-
		Principles
	-
		-
			Host Environment
		-
			-
				The host environment may read from and alter the state of Kaeon FUSION before,
				during or after the execution of a Kaeon FUSION program.
			-
		-
			Return Value
		-
			-
				The state of a Kaeon FUSION program shall retain a value called the return value
				which may be changed as the program runs.

				It is to be taken as the default output of the program to the program's entry point
				within its environment.
			-

Use: Locations: 'Kaeon United Specification: 1 - Philosophy: 1 - Code: 2 - ONE: 2 - Application: 2 - FUSION: 1 - Kaeon FUSION: 2 - Interfaces'

-
	Kaeon FUSION Interfaces
-
	-
		Philosophy
	-
		-
			Kaeon FUSION interfaces are modules that may be integrated into the Kaeon FUSION
			interpreter at runtime, where they may alter the interpreter's properties in any way.
		-
	-
		Principles
	-
		-
			Conventions
		-
			-
				Kaeon FUSION interfaces are, by default, implemented as interface modules.
				
				Kaeon FUSION interfaces not implemented as interface modules may be converted to
				interface modules.
			-
		-
			Implementation
		-
			-
				Content
			-
				-
					Union Interface
				-
					-
						The union interface of a Kaeon FUSION program is an interface module
						generated from all of the Kaeon FUSION interfaces integrated into a Kaeon
						FUSION program at runtime.

						The union interface is the default return value of a Kaeon FUSION program
						until said value is reassigned to something else.
					-
				-
					Union Document
				-
					-
						The union interface is, by default, encoded in standard interface ACE in a
						usage document maintained by the Kaeon FUSION process called the union
						document.
					-
			-
				Host Environment
			-
				-
					Both the union interface and the union document may be altered before, during,
					and after the runtime of a Kaeon FUSION process.
				-

Use: Locations: 'Kaeon United Specification: 1 - Philosophy: 1 - Code: 2 - ONE: 2 - Application: 2 - FUSION: 1 - Kaeon FUSION: 3 - Use'

-
	Kaeon FUSION Use Command
-
	-
		Philosophy
	-
		-
			The use command contains the content "Use". The letter case of the content is
			irrelevant. It may have an indefinite number of children.
			
			At step three of the FUSION process, for each of its children, referred to as interface
			elements, the use command will integrate the Kaeon FUSION interfaces specified by said
			interface element.

			Any method through which an interface element may specify Kaeon FUSION interfaces is
			referred to as a use protocol.
		-

Use: Locations: 'Kaeon United Specification: 1 - Philosophy: 1 - Code: 2 - ONE: 2 - Application: 2 - FUSION: 1 - Kaeon FUSION: 3 - Use: 1 - Standard Use Protocols'

-
	Standard Use Protocols
-
	-
		Philosophy
	-
		-
			The standard use protocols are the use protocols which Kaeon FUSION starts with by
			default.
		-
	-
		Principles
	-
		-
			Conventions
		-
			-
				ACE Use Protocol
			-
				-
					The ACE use protocol causes the use command to act as a use element,
					integrating its children into the content of the union document of the Kaeon
					FUSION program.
				-
			-
				Content Use Protocol
			-
				-
					The content use protocol causes the use command to interpret the content of all
					of its children as string paths to Kaeon ACE documents to be integrated into
					the union document of the Kaeon FUSION program, if said paths are valid.
				-
			-
				Evaluate Use Protocol
			-
				-
					The evaluate use protocol causes the use command to interpret all values
					returned to it as string paths to Kaeon ACE documents to be integrated into the
					union document of the Kaeon FUSION program, if said paths are valid.
				-
		-
			General Use Protocol
		-
			-
				The general use protocol applies to Kaeon FUSION code which contains no use
				command, in cases where the union document of the Kaeon FUSION program is empty, to
				apply the general use convention to said code and to integrate the resulting usage
				document into the union document of said program.
			-

Use: Locations: 'Kaeon United Specification: 1 - Philosophy: 1 - Code: 2 - ONE: 2 - Application: 2 - FUSION: 2 - FUSION ACE Commands'

-
	FUSION ACE Commands
-
	-
		Philosophy
	-
		-
			A ONE ACE command that is formatted as a FUSION script is referred to as a FUSION ACE
			command.
		-
	-
		Principles
	-
		-
			Kaeon FUSION ACE Commands
		-
			-
				A FUSION ACE command that is formatted as a Kaeon FUSION script is referred to as a
				Kaeon FUSION ACE command.
			-

Use: Locations: 'Kaeon United Specification: 1 - Philosophy: 1 - Code: 2 - ONE: 3 - Kaeon Documents'

-
	Kaeon Documents
-
	-
		Philosophy
	-
		-
			The Kaeon document format is a ONE document format that is used for formal documents.
		-
	-
		Principles
	-
		-
			Structure
		-
			-
				A Kaeon document contains a single element at the root level called the title
				element. The content of the title element is the name of the concept that the
				document represents.
				
				The first child of the element at the root contains the content "Philosophy". The
				first and only child of this element contains content giving an overview of the
				concept that the document represents.
				
				The next child of the element shall only be present if the content of the child of
				the first child is not sufficient to establish the concept. If present, it shall
				have the content "Principles", and may have any children.
				
				The final child of the element shall only be present if the document is intended to
				double as an executable program. If present, it shall have the content "Wonders",
				and may have any children, which shall function as executable code.
			-
		-
			Types
		-
			-
				Poly Kaeon Documents
			-
				-
					A poly Kaeon document refers to a ONE document that consists of a root element
					with no content and an indefinite number of Kaeon documents as its children.
				-
			-
				Embedded Kaeon Documents
			-
				-
					An embedded Kaeon document refers to a Kaeon document title element, along with
					its respective descendant elements, added as a child to ONE element other than
					the root element of its document.
				-
			-
				Informal Kaeon Documents
			-
				-
					An informal Kaeon document refers to any document that follows an inexact
					version of the Kaeon document format.
					
					An informal Kaeon document which deviates from the Kaeon document format only
					by omitting its philosophy section, and which has a principles or wonders
					section, is called a meta Kaeon document.
				-

Use: Locations: 'Kaeon United Specification: 1 - Philosophy: 1 - Code: 2 - ONE: 3 - Kaeon Documents: 1 - Formats: 1 - ACE Kaeon Document'

-
	ACE Kaeon Document
-
	-
		Philosophy
	-
		-
			An ACE Kaeon document is a Kaeon document which contains use elements.
		-
	-
		Principles
	-
		-
			Wonders ACE Kaeon Document
		-
			-
				A wonders ACE Kaeon document is an ACE Kaeon document in which the principles
				section contains no use elements.
			-
		-
			Standard ACE Kaeon Document
		-
			-
				A standard ACE Kaeon document is a wonders ACE Kaeon document with no principles
				section, and a wonders section containing a single use element.
			-

Use: Locations: 'Kaeon United Specification: 1 - Philosophy: 1 - Code: 2 - ONE: 3 - Kaeon Documents: 1 - Formats: 1 - ACE Kaeon Document: 1 - Kaeon Document Utility'

-
	Kaeon Document Utility
-
	-
		Philosophy
	-
		-
			A Kaeon document utility is an interface utility that represents a Kaeon document,
			where the alias of said utility is the content of the title element of said document,
			and the utility source of said utility consists of the children of the title element of
			said document.
		-

Use: Locations: 'Kaeon United Specification: 1 - Philosophy: 1 - Code: 2 - ONE: 3 - Kaeon Documents: 1 - Formats: 2 - Amenable ONE Element'

-
	Amenable ONE Element
-
	-
		Philosophy
	-
		-
			An amenable ONE element is a ONE element to which elements serving as amendments may be
			added over time.

			If the terms of multiple amendments conflict, the terms of more recently added
			amendments shall overrule the terms of preceding amendments.
		-
	-
		Principles
	-
		-
			Standard Amendment Element
		-
			-
				A standard amendment element is a ONE element, added as a child to a given amenable
				ONE element, with content consisting of the string "Amendment ", followed by the
				number specifying the order in which it was added, relative to other amendments, to
				said amenable element. A standard amendment element may have any children, and
				shall be added as the last child of its parent at the time it is added.

				To declare an element as amenable, a standard amendment element may be added, with
				said element in the form of an embedded Kaeon document, titled "Amendment 0", with
				the content of its philosophy section being "This element is an amenable element."
			-

Use: Locations: 'Kaeon United Specification: 1 - Philosophy: 1 - Code: 2 - ONE: 3 - Kaeon Documents: 2 - Kaeon Library'

-
	Kaeon Library
-
	-
		Philosophy
	-
		-
			A Kaeon library is a set of directories that contain organized files.
		-
	-
		Principles
	-
		-
			Structure
		-
			-
				All of the contents of a Kaeon library are contained within a directory called the
				master directory.

				A general directory may contain multiple miscellaneous documents and directories.
				
				A library directory, which the master directory is one of, may contain multiple
				directories within it, which may either be library directories or general
				directories, may contain a single document, called a library directory document, or
				may contain both.

				Directories within a library directory must be arranged in a specific order.
			-
		-
			Content
		-
			-
				Naming
			-
				-
					Each library directory may optionally have a string alias.

					The master directory must have an alias, which shall be its name and the name
					of the library.
					
					The standard naming convention for any library directory other than the master
					directory in a Kaeon library is that its name must consist of a number
					specifying the index of its order relative to the other library directories
					within its parent directory, said indices starting at one, and, if said
					directory has an alias, said number shall be followed by a space, followed by a
					dash, followed by another space, followed by said alias.
				-
			-
				Standard Kaeon Library
			-
				-
					A standard Kaeon library is a Kaeon library where all of the library directory
					documents are Kaeon documents.
				-

Use: Locations: 'Kaeon United Specification: 1 - Philosophy: 1 - Code: 2 - ONE: 3 - Kaeon Documents: 2 - Kaeon Library: 1 - Content: 1 - Kaeon Library Trace'

-
	Kaeon Library Trace
-
	-
		Philosophy
	-
		-
			Library and general directories within Kaeon libraries, and the documents within them,
			may function as tag trace modules, with their names, aliases, and indices functioning
			as trace tags, and their children functioning as their connections.

			These conventions can be applied to generic folders if they are interpreted as isolated
			general directories.
		-

Use: Locations: 'Kaeon United Specification: 1 - Philosophy: 1 - Code: 2 - ONE: 3 - Kaeon Documents: 2 - Kaeon Library: 1 - Content: 2 - Kaeon Library ACE'

-
	Kaeon Library ACE
-
	-
		Philosophy
	-
		-
			A library directory within a Kaeon library may be interpreted as a Kaeon ACE entity by
			interpreting the contents of its library directory document as a Kaeon ACE entity, and
			then by interpreting its child directories in the same manner as child Kaeon ACE
			entities of said Kaeon ACE entity.

			If the library directory document is an ACE Kaeon document, then the Kaeon ACE entity
			generated shall be the root Kaeon ACE entity of the usage document derived from said
			library directory document.

			If the library directory document is not an ACE Kaeon document, then the Kaeon ACE
			entity generated shall be a Kaeon document utility interface entity derived from said
			document.
		-

Use: Locations: 'Kaeon United Specification: 1 - Philosophy: 1 - Code: 2 - ONE: 3 - Kaeon Documents: 2 - Kaeon Library: 2 - Conventions'

-
	Kaeon Library Conventions
-
	-
		Philosophy
	-
		-
			The Kaeon library conventions are a set of standards for how a Kaeon library should
			typically be configured.
			
			A standard Kaeon library that abides by the Kaeon library conventions is referred to as
			a conventional Kaeon library.
		-
	-
		Principles
	-
		-
			Structure
		-
			-
				Master Document
			-
				-
					The master document convention specifies that a Kaeon library may optionally
					have a single Kaeon document that sits at its root, referred to as its master
					document, which specifies either the purpose of said Kaeon library or the
					overarching idea upon which it is established.
				-
			-
				Sections
			-
				-
					Philosophy Section
				-
					-
						The philosophy convention specifies that a Kaeon library may optionally
						have a "Philosophy" folder nested in its root, which, if present, shall
						contain all of the library's Kaeon documents which are meant to be read
						manually, aside from those used to specify information about said library's
						Universal Atlas connections.
						
						The philosophy folder may only contain library directories.
					-
				-
					Principles Section
				-
					-
						The principles convention specifies that a Kaeon library may optionally
						have a "Principles" folder nested in its root which shall contain Kaeon
						documents, and which shall be interpreted as Kaeon library ACE to derive a
						usage document called the library document of said Kaeon library, which
						shall be used to specify metadata regarding said Kaeon library.
						
						The Kaeon document utilities within a Kaeon library document shall
						constitute the meta library of said Kaeon library document.
						
						Kaeon ACE entities within a library document may have the Kaeon Library
						component attached, which has the alias "Kaeon Library", which indicates
						that said entity specifies a resource that said Kaeon Library is connected
						to within the universal atlas.
						
						The aliases of said entities shall be the names of said resources, and said
						entities may use interface ACE to specify the content or location of said
						resources.
						
						The principles folder may only contain library directories.
						
						A codified protocol specifying additional ways in which the contents of a
						library document may be used to specify metadata regarding its library is
						referred to as a Kaeon library protocol.
					-
				-
					Wonders
				-
					-
						The wonders convention specifies that a Kaeon library may optionally have a
						"Wonders" folder nested in its root, which shall contain all of the
						library's contents which do not belong in the philosophy or principles
						folders.
						
						The wonders folder may contain both library directories and general
						directories.
					-
		-
			Organization
		-
			-
				Ordering
			-
				-
					Order
				-
					-
						The order convention specifies that the philosophy folder, if present,
						shall be ordered before any other folders in the root, and that the wonders
						folder shall be ordered after any other folders in the root, and that aside
						from said folders and the master document, no other items may be nested in
						the root.
					-
				-
					Kaeon Library Atlas
				-
					-
						A named group of Kaeon libraries is called a Kaeon library atlas.
						
						The Kaeon libraries in a given Kaeon library atlas may be arranged in a
						specific order relative to one another, referred to as their meta-order.
					-
			-
				Kaeon Library Overlay
			-
				-
					A Kaeon library atlas may be combined using a form of folder overlay where the
					subfolders of library directories are ordered according to the meta order of
					the atlas, their indices and names being reassigned accordingly, and where the
					library directory documents of library directories, if there are multiple them,
					are combined into a single poly Kaeon document with its constituent documents
					ordered according to the meta order of the atlas.
				-

Use: Locations: 'Kaeon United Specification: 1 - Philosophy: 1 - Code: 2 - ONE: 3 - Kaeon Documents: 2 - Kaeon Library: 2 - Conventions: 1 - Books'

-
	Kaeon Library Books
-
	-
		Philosophy
	-
		-
			The book of a conventional Kaeon library consists of the contents of the master
			document, if present, the philosophy folder, if present, and the principles folder, if
			present, said sections and contents being arranged in order.
		-
	-
		Principles
	-
		-
			Conventions
		-
			-
				Naming
			-
				-
					The name of a Kaeon library book for a single Kaeon library or a Kaeon library
					atlas shall consist of the string "The Book of ", followed by the name of said
					library or atlas.
				-
			-
				Book Document
			-
				-
					The book document of a conventional Kaeon library consists of the contents of
					the Kaeon documents that compose its book nested as children in order into the
					root of an otherwise empty poly Kaeon document.
				-
			-
				Types
			-
				-
					Composite Kaeon Library Book
				-
					-
						A composite Kaeon library book consists of the contents of the books of
						every Kaeon library in a given Kaeon library atlas concatenated together,
						in their meta-order if said order is defined, or in no particular order if
						it is not, from which a book document may be derived by treating the
						composite Kaeon library book as a single book.
					-
				-
					Extended Book
				-
					-
						An extended book of a conventional Kaeon library follows the contents of a
						conventional Kaeon library book with some, in the case of a partial
						extended book, or all, in the case of a complete extended book, of contents
						of the wonders folder, if present, said contents being arranged in order.
					-
		-
			Book Document Format
		-
			-
				General
			-
				-
					Notation
				-
					-
						Metadata may be added to a Kaeon library book document by adding ACE use
						elements between the Kaeon documents of said book document. Such use
						elements are referred to as notation elements, with all other documents in
						a Kaeon library book referred to as content documents.

						A notation element which uses a query ACE locations component to specify
						the locations of a given folder within a Kaeon library or Kaeon library
						atlas is referred to as a reference notation element.

						The content of notation elements, when specifying paths, may, and should by
						default, use a colon followed by a space as the path separator.
					-
				-
					Kaeon Asset Documents
				-
					-
						Kaeon asset documents are meta Kaeon documents used to represent and store
						assets which are not themselves Kaeon documents.

						If a Kaeon asset document represents an asset written in plain text, it
						shall be referred to as readable, and as non-readable otherwise.

						The content of the title element of a Kaeon document shall be the name of
						the asset it represents, and the wonders section of the document shall
						contain an ACE use element acting as an interface ACE entity specifying the
						content or locations of said asset.
					-
			-
				Variants
			-
				-
					Standard
				-
					-
						A standard Kaeon library book is a Kaeon library book document which begins
						with a reference notation element specifying the Kaeon library or Kaeon
						library atlas which contains the contents of the book, and in which every
						content document is preceded by a reference notation element specifying its
						location within said Kaeon library or Kaeon library atlas.
					-
				-
					Reduced
				-
					-
						A reduced Kaeon library book is a Kaeon library book or composite Kaeon
						library book that omits the principles sections of the Kaeon libraries
						within it.
					-
				-
					Extended
				-
					-
						Standard Kaeon library books for extended Kaeon libraries shall use Kaeon
						asset documents to represent any document in a wonders folder of a Kaeon
						library which is not a Kaeon document.

						The contents of general directories in a wonders folder of such a book
						shall first be arranged hierarchically, and shall then be arranged in
						alphanumerical order.
					-

Use: Locations: 'Kaeon United Specification: 1 - Philosophy: 1 - Code: 3 - Universal Preprocessor'

-
	Universal Preprocessor
-
	-
		Philosophy
	-
		-
			The Universal Preprocessor is a preprocessor that allows code from any programming
			language to be embedded as a preprocessor into any text file.
		-
	-
		Principles
	-
		-
			Conventions
		-
			-
				Token Sequences
			-
				-
					The Universal Preprocessor requires seven unique sequences of characters to be
					defined: the open sequence, the open directive sequence, the close protocol
					sequence, the open content sequence, the close directive sequence, the null
					sequence, and the wildcard sequence.
					
					It is not permitted for the sequences to be defined such that there may be any
					instances where two or more sequences conflict at a given location.
				-
			-
				Directives
			-
				-
					Preprocessor directives in the Universal Preprocessor shall be encoded in
					directives.
					
					Directives typically begin with an open sequence, which is followed by the name
					of the language the directive is written in, or the alias of or path to an
					interface module which can process said language, referred to as the directive
					language, which is followed by an open content sequence, which is followed by
					any valid code written in the directive language, referred to as the directive
					content, and end with a close directive sequence. A directive following this
					format is called an explicit directive.

					Alternatively, a directive may begin with an open directive sequence, which is
					followed by any valid code written in any language, referred to as the
					directive content, and end with a close directive sequence. A directive
					following this format is called an implicit directive.

					Whichever sequence a directive begins with is referred to as its starting
					sequence.

					Token sequences used for Universal Preprocessor directives can be nullified in
					any manner otherwise used to nullify or escape characters by the host language
					if outside a directive, or by the directive language if inside a directive.

					If said token sequences are not escaped within another directive, then a nested
					directive shall operate on the directive content.
				-
			-
				Language
			-
				-
					Host Language
				-
					-
						The host language determines how the tokens used by the Universal
						Preprocessor are escaped when located outside other directives.

						The host language may be explicitly set using a host protocol, which sets
						the host language for all Universal Preprocessor tokens that follow it.
						
						Host protocols begin with an open sequence, which is followed by the name
						of the language to set as the host language, which is followed by a close
						protocol sequence.

						If the host language is not declared, or is declared using a null sequence,
						then the host language shall be plain text, and there shall be no protocol
						for escaping tokens.

						The text of a document with its unescaped directives removed is referred to
						as its base content.
					-
				-
					Auto Detection
				-
					-
						For an implicit directive, or for an explicit directive where the directive
						language is specified using a wildcard sequence, the language of the
						directive content shall be detected automatically.
					-
		-
			Usage
		-
			-
				Execution
			-
				-
					Flow
				-
					-
						Each directive shall execute as code in the language of its directive
						content in order of its placement.

						The state of the preprocessor shall carry over from directive to directive
						to whatever extent possible.
					-
				-
					Arguments
				-
					-
						Each directive shall take three arguments, the first being the base content
						as a string, the second being the index of its respective starting sequence
						as an integer number within the base content, and the third being a list
						which contains miscellaneous values passed to the Universal Preprocessor as
						arguments, and which shall retain any changes made to it between
						directives.
					-
				-
					Return Values
				-
					-
						Any text logged to standard out by the directive content of a directive
						will be injected into the base content at the index of its starting
						sequence, and by default, the return value of the preprocessor shall be the
						final state of the base content.
						
						However, if the directive content of a directive returns a non-null value,
						said value shall become the return value of the preprocessor, unless it
						itself is superseded by another value returned by a subsequently executed
						directive.
					-
			-
				Commenting
			-
				-
					If the directive language for a given directive is declared using a null
					sequence, or as any string not recognized as a language alias, then the
					contents of the directive shall not execute, thus making the directive function
					as a comment.
				-

Use: Locations: 'Kaeon United Specification: 1 - Philosophy: 1 - Code: 3 - Universal Preprocessor: 1 - Standard Universal Preprocessor'

-
	Standard Universal Preprocessor
-
	-
		Philosophy
	-
		-
			The standard Universal Preprocessor is a specification for the standard token sequences
			used by the Universal Preprocessor.
		-
	-
		Principles
	-
		-
			Open Sequence
		-
			-
				The open sequence in the standard Universal Preprocessor consists of an open paren
				followed by a closed square bracket.
			-
		-
			Open Directive Sequence
		-
			-
				The open directive sequence in the standard Universal Preprocessor consists of an
				open paren followed by a closed angle bracket.
			-
		-
			Close Protocol Sequence
		-
			-
				The close protocol sequence in the standard Universal Preprocessor consists of an
				open square bracket followed by a closed paren.
			-
		-
			Open Content Sequence
		-
			-
				The open content sequence in the standard Universal Preprocessor consists of an
				open square bracket followed by a closed angle bracket.
			-
		-
			Close Directive Sequence
		-
			-
				The close directive sequence in the standard Universal Preprocessor consists of an
				open angle bracket followed by a closed paren.
			-
		-
			Null Sequence
		-
			-
				The null sequence in the standard Universal Preprocessor consists of a tilde.
			-
		-
			Wildcard Sequence
		-
			-
				The wildcard sequence in the standard Universal Preprocessor consists of an
				asterisk.
			-

Use: Locations: 'Kaeon United Specification: 1 - Philosophy: 2 - Philosopher~'s Stone: 1 - Philosopher~'s Conventions: 1 - Philosopher~'s Atlas'

-
	Philosopher's Atlas
-
	-
		Philosophy
	-
		-
			A directed graph of modules where said modules may be of any type is referred to as a
			Philosopher's Atlas.
		-

Use: Locations: 'Kaeon United Specification: 1 - Philosophy: 2 - Philosopher~'s Stone: 1 - Philosopher~'s Conventions: 1 - Philosopher~'s Atlas: 1 - Atlas Policy'

-
	Atlas Policy
-
	-
		Philosophy
	-
		-
			An atlas policy is an attribute assigned to a connection in a Philosopher's Atlas.
		-

Use: Locations: 'Kaeon United Specification: 1 - Philosophy: 2 - Philosopher~'s Stone: 1 - Philosopher~'s Conventions: 1 - Philosopher~'s Atlas: 1 - Atlas Policy: 1 - Private Connection'

-
	Private Connection
-
	-
		Philosophy
	-
		-
			A private connection is a type of connection in a Philosopher's Atlas.

			A private connection will not allow a traversal to pass through it unless said
			traversal began at the module that said connection goes out from.
		-

Use: Locations: 'Kaeon United Specification: 1 - Philosophy: 2 - Philosopher~'s Stone: 1 - Philosopher~'s Conventions: 1 - Philosopher~'s Atlas: 2 - Nodes: 1 - Philosopher~'s Core'

-
	Philosopher's Core
-
	-
		Philosophy
	-
		-
			A Philosopher's Core is a node on a Philosopher's Atlas designed specifically to
			coordinate activity within a Philosopher's Atlas.
		-
	-
		Principles
	-
		-
			Philosopher's Core Commands
		-
			-
				A Philosopher's Core command is an object that may be passed to a philosopher's
				core through which it may be distributed to the rest of the Philosopher's Atlas,
				after which another object may be returned.
			-

Use: Locations: 'Kaeon United Specification: 1 - Philosophy: 2 - Philosopher~'s Stone: 1 - Philosopher~'s Conventions: 1 - Philosopher~'s Atlas: 2 - Nodes: 2 - Philosopher~'s Gate'

-
	Philosopher's Gate
-
	-
		Philosophy
	-
		-
			A Philosopher's Gate is a node on a Philosopher's Atlas which acts as an interface
			between said atlas and external systems.
		-

Use: Locations: 'Kaeon United Specification: 1 - Philosophy: 2 - Philosopher~'s Stone: 1 - Philosopher~'s Conventions: 1 - Philosopher~'s Atlas: 2 - Nodes: 3 - Philosopher~'s Seed'

-
	Philosopher's Seed
-
	-
		Philosophy
	-
		-
			A Philosopher's Seed is a node on a Philosopher's Atlas capable of creating and
			repairing other nodes within said atlas.
		-
	-
		Principles
	-
		-
			Genesis Philosopher's Seed
		-
			-
				A Genesis Philosopher's Seed is a Philosopher's Seed which is capable of
				initializing the creation of the entirety of the Philosopher's Atlas to which it
				belongs by itself.
			-

Use: Locations: 'Kaeon United Specification: 1 - Philosophy: 2 - Philosopher~'s Stone: 1 - Philosopher~'s Conventions: 1 - Philosopher~'s Atlas: 3 - Aether'

-
	Aether
-
	-
		Philosophy
	-
		-
			Aether is a system that allows the interface of a regulated Philosopher's Stone module
			to be attached to modules that exist within systems running in entirely different
			environments.
		-
	-
		Principles
	-
		-
			Alias
		-
			-
				An Aether module may be identified via a unique string alias or path.
			-

Use: Locations: 'Kaeon United Specification: 1 - Philosophy: 2 - Philosopher~'s Stone: 1 - Philosopher~'s Conventions: 1 - Philosopher~'s Atlas: 3 - Aether: 1 - Standard Aether'

-
	Standard Aether
-
	-
		Philosophy
	-
		-
			Standard Aether is a variant of the Aether system under which Aether modules shall be
			standard modules.
		-

Use: Locations: 'Kaeon United Specification: 1 - Philosophy: 2 - Philosopher~'s Stone: 1 - Philosopher~'s Conventions: 1 - Philosopher~'s Atlas: 3 - Aether: 2 - Aether Atlas'

-
	Aether Atlas
-
	-
		Philosophy
	-
		-
			An Aether Atlas is an autonomous network of devices and applications that can
			dynamically restructure itself.

			As such, an Aether atlas can be represented in abstract form as a Philosopher's Atlas.
		-
	-
		Principles
	-
		-
			Utilities
		-
			-
				Components
			-
				-
					Aether Node
				-
					-
						An Aether Node is an application or device designed to function as part of
						an Aether Atlas.
					-
				-
					Aether Utility
				-
					-
						An Aether Utility is an application or device that was not designed to
						function as part of an Aether Atlas but which has nonetheless been
						incorporated into at least one.
					-
			-
				Aether Interface
			-
				-
					An Aether Interface is a device or application that provides a user interface
					to an Aether Atlas.
				-
		-
			Forms
		-
			-
				Aether Clusters
			-
				-
					Aether Clusters are Aether Atlases within Aether Atlases.
				-
			-
				Aether Union
			-
				-
					An Aether Union is a related but unconnected group of Aether Atlases.
				-

Use: Locations: 'Kaeon United Specification: 1 - Philosophy: 2 - Philosopher~'s Stone: 1 - Philosopher~'s Conventions: 2 - Philosopher~'s Medium'

-
	Philosopher's Medium
-
	-
		Philosophy
	-
		-
			A Philosopher's Medium is a standard for a set of functionality which a module that
			abides by it shall have.
		-
	-
		Principles
	-
		-
			Inner and Outer Operations
		-
			-
				Any function specified by a Philosopher's Medium which is to be called from an
				object that abides by said medium may also be used as an independent function which
				performs the same operation by taking said object as its first argument, followed
				by all of the other arguments that would otherwise be passed to it.

				Such functions called from within objects can be referred to as inner operations,
				and as outer operations if called as independent functions.
			-

Use: Locations: 'Kaeon United Specification: 1 - Philosophy: 2 - Philosopher~'s Stone: 1 - Philosopher~'s Conventions: 2 - Philosopher~'s Medium: 1 - Mediums: 1 - Standard'

-
	Standard Philosopher's Medium
-
	-
		Philosophy
	-
		-
			A module that abides by the standard Philosopher's Medium shall have a function known
			as the standard function.
		-
	-
		Principles
	-
		-
			Standard Function
		-
			-
				The standard function may take any parameters.

				The operations it performs and the value it returns may be redefined for every
				module that abides by the standard Philosopher's Stone Medium. There are no limits
				on what said operations and value may be.
			-

Use: Locations: 'Kaeon United Specification: 1 - Philosophy: 2 - Philosopher~'s Stone: 1 - Philosopher~'s Conventions: 2 - Philosopher~'s Medium: 1 - Mediums: 1 - Standard: 1 - Standard Function Conventions'

-
	Standard Function Conventions
-
	-
		Philosophy
	-
		-
			The standard function conventions define the default properties for the standard
			function within a module that abides by the standard Philosopher's Medium.

			The conventions also assert that any module that abides by the standard Philosopher's
			Medium shall be known as a standard Philosopher's Stone Module.
		-
	-
		Principles
	-
		-
			Standard Function Defaults
		-
			-
				By default, the standard function shall perform no operations and shall return a
				null value.
			-
		-
			Standard Function Default Alias
		-
			-
				The standard function default alias for the standard function within a standard
				Philosopher's Stone module.

				The standard function default alias is "On Call".
			-

Use: Locations: 'Kaeon United Specification: 1 - Philosophy: 2 - Philosopher~'s Stone: 1 - Philosopher~'s Conventions: 2 - Philosopher~'s Medium: 1 - Mediums: 2 - Regulated'

-
	Regulated Philosopher's Medium
-
	-
		Philosophy
	-
		-
			A module that abides by the regulated Philosopher's Medium shall have the on incoming
			function and the on outgoing function, and shall be known as a regulated Philosopher's
			Stone module.

			The aforementioned functions are used to restrict access to certain regions of a given
			Philosopher's Atlas during traversals of it.
		-
	-
		Principles
	-
		-
			Functions
		-
			-
				On Incoming
			-
				-
					The on incoming function takes a list of modules representing a traversal path,
					as well as a value specifying any additional information as arguments.
					
					It returns true if the module it was called from should be considered part of a
					given traversal, and returns false otherwise.
					
					It may be redefined for each regulated Philosopher's Stone module, and may
					perform any operations before returning.

					It returns true by default.
				-
			-
				On Outgoing
			-
				-
					The on outgoing function takes a list of modules representing a traversal path
					as well as a value specifying any additional information as arguments. The list
					must contain at least two modules, with the second to last module in the list
					being the one the function was called from, and the last module in the list
					being the next one in the projected traversal.
					
					It returns true if a given traversal should continue from the module it was
					called from to the last stone in the passed in list, and returns false
					otherwise.
					
					It may be redefined for each regulated Philosopher's Stone module, and may
					perform any operations before returning.
					
					It returns true by default.
				-
		-
			Traversals
		-
			-
				When a traversal of a Philosopher's Atlas travels through a regulated Philosopher's
				Stone module, the on incoming function of the regulated Philosopher's stone module
				in question shall be called using a list containing every previously traversed
				module, as well as a value specifying any additional information. If the on
				incoming function returns true, the traversal shall progress to the module in
				question.
				
				If a traversal has progressed past the on incoming function of a given regulated
				Philosopher's Stone module, the on outgoing function of said regulated
				Philosopher's Stone module must be called for every module that the regulated
				Philosopher's Stone module in question is connected to that itself has not yet been
				traversed. A list containing every previously traversed module, the regulated
				Philosopher's Stone module in question, and the next module in the projected
				traversal shall be passed to the on outgoing function, along with a value
				specifying any additional information. The traversal will proceed to each
				connection that the on outgoing function returns true for.
			-

Use: Locations: 'Kaeon United Specification: 1 - Philosophy: 2 - Philosopher~'s Stone: 1 - Philosopher~'s Conventions: 2 - Philosopher~'s Medium: 1 - Mediums: 3 - Modifiable'

-
	Modifiable Philosopher's Medium
-
	-
		Philosophy
	-
		-
			A module that abides by the modifiable Philosopher's Medium shall have the modify
			function, which shall either one or two values, with the first value representing
			either data or functionality and the second value, if present, representing the desired
			address for the specified data or functionality within the module. The first value
			shall be inserted where possible within the module, and if the second value is present,
			the first value shall be inserted such that it may be addressed according to the second
			value. Any existing values within the module that conflict with the new value shall be
			deleted.
			
			A module that abides by the modifiable Philosopher's Medium shall be known as a
			modifiable Philosopher's Stone module.
		-

Use: Locations: 'Kaeon United Specification: 1 - Philosophy: 2 - Philosopher~'s Stone: 1 - Philosopher~'s Conventions: 2 - Philosopher~'s Medium: 1 - Mediums: 4 - Serializable'

-
	Serializable Philosopher's Medium
-
	-
		Philosophy
	-
		-
			A module that abides by the serializable Philosopher's Medium shall have the serialize
			function, which serializes the module and returns it as a string, and the deserialize
			function, which takes a serialized module in the form of a string and converts the
			state of the module it was called from to the state of the serialized module that was
			passed to it.
			
			A module that abides by the serializable Philosopher's Medium shall be known as a
			serializable Philosopher's Stone module.
		-

Use: Locations: 'Kaeon United Specification: 1 - Philosophy: 2 - Philosopher~'s Stone: 1 - Philosopher~'s Conventions: 2 - Philosopher~'s Medium: 1 - Mediums: 5 - Taggable'

-
	Taggable Philosopher's Medium
-
	-
		Philosophy
	-
		-
			A module that abides by the taggable Philosopher's Medium shall contain a list of
			strings which act as identification tags for the module.

			A module that abides by the taggable Philosopher's Medium shall be known as a tagged
			Philosopher's Stone module.
		-

Use: Locations: 'Kaeon United Specification: 1 - Philosophy: 2 - Philosopher~'s Stone: 1 - Philosopher~'s Conventions: 2 - Philosopher~'s Medium: 1 - Mediums: 6 - Generator'

-
	Generator Philosopher's Medium
-
	-
		Philosophy
	-
		-
			A module that abides by the generator Philosopher's Medium serves as a module that can
			spawn other modules, and can also take correlation into account.
		-
	-
		Principles
	-
		-
			Functionality
		-
			-
				A module that abides by the generator Philosopher's Medium has three functions.
				
				The first function is the generate function. This function takes one value and a
				number between zero and one, and returns a value that correlates to the passed in
				value as well as specified by the passed in number.
				
				The second function is the degenerate function. This function takes one value and a
				number between zero and one. The value is the output of the generate function for
				an unknown input, and the number represents how well the unknown input and the
				given output match up. Based on this correlation, the function returns a value that
				is as close as possible to a value that would cause the given output to be returned
				if passed to the generate function with the given correlation number.
				
				The third function is the correlate function. This function takes two values, and
				returns a number between zero and one based on how well the second value correlates
				to the first value assuming that the second value is output and the first value is
				the input paired with an unknown correlation value for the generate function.
			-

Use: Locations: 'Kaeon United Specification: 1 - Philosophy: 2 - Philosopher~'s Stone: 1 - Philosopher~'s Conventions: 2 - Philosopher~'s Medium: 1 - Mediums: 7 - SOUL'

-
	SOUL Philosopher's Medium
-
	-
		Philosophy
	-
		-
			A module that abides by the SOUL Philosopher's Medium serves as a universal black box
			for machine learning models.

			A module that abides by the SOUL Philosopher's Medium shall be known as a SOUL, and
			must also abide by the generator Philosopher's Medium.
		-
	-
		Principles
	-
		-
			SOUL Corpus
		-
			-
				A SOUL corpus is a set of correlations between input and output values.

				The standard form of a SOUL corpus is a list of objects, where each of said objects
				has an input value, an output value, and a correlation value in the form of a
				number between zero and one, inclusive, which represents the correlation between
				the aforementioned input and output values.

				The standard form for both input and output values is a string, and each object may
				be represented as a list where the input value is the first element, the output
				value is the second element, and the correlation value is the third element.
			-
		-
			Functionality
		-
			-
				In addition to the functions specified by the generator Philosopher's Medium, a
				SOUL also has the train function, which takes a SOUL corpus, and trains the
				functions that said SOUL inherits from the generator Philosopher's Medium to match
				input and output values passed to them according to the content of said corpus, and
				according to the content of any corpuses previously passed to said function.

				A SOUL may also have the reset function, which undoes any training performed by the
				train function.
			-

Use: Locations: 'Kaeon United Specification: 1 - Philosophy: 2 - Philosopher~'s Stone: 1 - Philosopher~'s Conventions: 2 - Philosopher~'s Medium: 1 - Mediums: 7 - SOUL: 1 - SOUL Core'

-
	SOUL Core
-
	-
		Philosophy
	-
		-
			A SOUL core is a standard Philosopher's Stone module containing SOULs for processing
			any data that passes through it via a Philosopher's Atlas.
		-
	-
		Principles
	-
		-
			Functionality
		-
			-
				For every other module that a SOUL core is connected to via a Philosopher's Atlas,
				it must contain two SOULs, the gateway SOUL and the transformation SOUL
				respectively.
				
				Every time a SOUL core receives a value through the standard function, it must run
				the value through each gateway SOUL's generate function to produce a value
				representing either a positive or a negative result. If the result is positive, the
				generate function of the transformation SOUL that corresponds the gateway SOUL in
				question shall be called using a correlation argument of one, and then the gateway
				SOUL's respective connected module's standard function will be called using the
				aforementioned transformation SOUL's generate function's output.
				
				Additionally, a SOUL core shall have an operation function, which shall take a
				single value and may be overridden to perform any operation based on said value.
				The operation function shall be called using every value passed to its respective
				SOUL core's standard function.
			-

Use: Locations: 'Kaeon United Specification: 1 - Philosophy: 2 - Philosopher~'s Stone: 1 - Philosopher~'s Conventions: 2 - Philosopher~'s Medium: 1 - Mediums: 7 - SOUL: 2 - SOUL Entity'

-
	SOUL Entity
-
	-
		Philosophy
	-
		-
			A SOUL entity is a module with input channels that can receive strings from other
			modules, output channels that can export strings to other modules, and input channels
			that can receive feedback from other modules in the form of numbers from zero to one,
			with higher numbers indicating positive feedback, and lower numbers indicating negative
			feedback.

			A SOUL entity ought to behave such that it attempts to maximize the positive feedback
			received through its numerical input channels by adjusting what it exports through its
			string output channels according to what it receives through its string input channels.
		-

Use: Locations: 'Kaeon United Specification: 1 - Philosophy: 2 - Philosopher~'s Stone: 1 - Philosopher~'s Conventions: 2 - Philosopher~'s Medium: 2 - Standard Module'

-
	Standard Module
-
	-
		Philosophy
	-
		-
			A standard module is a module that abides by the standard, regulated, modifiable,
			serializable, and taggable Philosopher's Mediums.
		-
	-
		Principles
	-
		-
			Tags
		-
			-
				For identification purposes, the tags specified by the taggable Philosopher's
				Medium shall ignore letter case and white space for standard modules.
			-
		-
			Traversals
		-
			-
				Traversals of Philosopher's Atlases initiated by or from standard modules should
				acknowledge private and reduced connections.
			-

Use: Locations: 'Kaeon United Specification: 1 - Philosophy: 2 - Philosopher~'s Stone: 1 - Philosopher~'s Conventions: 3 - Philosopher~'s Methods: 1 - Modules: 1 - Philosopher~'s Interface'

-
	Philosopher's Interface
-
	-
		Philosophy
	-
		-
			A Philosopher's Interface is a defined process which may be executed with a
			Philosopher's Atlas passed to it as one of an indefinite number of arguments, and may
			alter the structure of said Philosopher's Atlas upon said execution.
		-

Use: Locations: 'Kaeon United Specification: 1 - Philosophy: 2 - Philosopher~'s Stone: 1 - Philosopher~'s Conventions: 3 - Philosopher~'s Methods: 1 - Modules: 2 - Philosopher~'s Script'

-
	Philosopher's Script
-
	-
		Philosophy
	-
		-
			A Philosopher's Script is a single set of data that may be interpreted differently by
			different processes.
		-

Use: Locations: 'Kaeon United Specification: 1 - Philosophy: 2 - Philosopher~'s Stone: 1 - Philosopher~'s Conventions: 3 - Philosopher~'s Methods: 1 - Modules: 3 - Philosopher~'s Crystal'

-
	Philosopher's Crystal
-
	-
		Philosophy
	-
		-
			A philosopher's crystal is a single module created to take the place of multiple
			modules. The process of converting multiple modules into a single module is referred to
			as crystallization.
		-
	-
		Principles
	-
		-
			Philosopher's Shards
		-
			-
				Philosopher's shards are modules created to take the place of a subset of tasks
				which were once handled by a single module. The process of converting a single
				module into multiple modules is referred to as fragmentation.
			-

Use: Locations: 'Kaeon United Specification: 1 - Philosophy: 2 - Philosopher~'s Stone: 1 - Philosopher~'s Conventions: 3 - Philosopher~'s Methods: 2 - Algorithms: 1 - Philosopher~'s Bootstrap'

-
	Philosopher's Bootstrap
-
	-
		Philosophy
	-
		-
			The Philosopher's Bootstrap is an interface for dynamically invoking any operation such
			that if said operation causes an error, then said operation shall terminate, said error
			shall be caught, and a null value shall be returned, and if said operation finishes
			successfully, then if said operation returns a value, said value shall be returned, and
			if said operation returns no value, a null value shall be returned.
		-

Use: Locations: 'Kaeon United Specification: 1 - Philosophy: 2 - Philosopher~'s Stone: 1 - Philosopher~'s Conventions: 3 - Philosopher~'s Methods: 2 - Algorithms: 2 - Data: 1 - Philosopher~'s Overlay'

-
	Philosopher's Overlay
-
	-
		Philosophy
	-
		-
			Philosopher's element overlay is a process which, using a given set of analogous graph
			nodes or analogous graph connections, combines them into a single node with all the
			properties of the original nodes or connection preserved to the greatest extent
			possible.
			
			Philosopher's graph overlay is a process which, using a given set of graphs, combines
			the nodes and connections of each graph in the set to form a single graph, while also
			performing philosopher's element overlay on any analogous nodes or connections among
			said set of graphs.
		-
	-
		Principles
	-
		-
			Folder Overlay
		-
			-
				Folders may be combined using philosopher's overlay, with a nested set of folders
				being interpreted as a tree and the contents of analogous folders being combined.

				This process is called folder overlay.
			-

Use: Locations: 'Kaeon United Specification: 1 - Philosophy: 2 - Philosopher~'s Stone: 1 - Philosopher~'s Conventions: 3 - Philosopher~'s Methods: 2 - Algorithms: 2 - Data: 2 - Philosopher~'s Retrieval'

-
	Philosopher's Retrieval
-
	-
		Philosophy
	-
		-
			Philosopher's Retrieval is when a collection of modules that match specified criteria
			is retrieved from a set.
		-

Use: Locations: 'Kaeon United Specification: 1 - Philosophy: 2 - Philosopher~'s Stone: 1 - Philosopher~'s Conventions: 3 - Philosopher~'s Methods: 2 - Algorithms: 2 - Data: 3 - Philosopher~'s Corpus'

-
	Philosopher's Corpus
-
	-
		Philosophy
	-
		-
			A Philosopher's Corpus is a defined interface to a set of databases, referred to as the
			Philosopher's Vault of the Philosopher's Corpus, which treats the data stored in said
			Philosopher's Vault as a Philosopher's Atlas, and which itself can operate as a node on
			a Philosopher's Atlas.
		-
	-
		Principles
	-
		-
			Mirror Vault
		-
			-
				A mirror vault is a section of an external Philosopher's Vault stored within an
				application and mapped to the same Philosopher's Corpus, such that changes made to
				it persist to said external Philosopher's Vault.
			-

Use: Locations: 'Kaeon United Specification: 1 - Philosophy: 2 - Philosopher~'s Stone: 1 - Philosopher~'s Conventions: 3 - Philosopher~'s Methods: 2 - Algorithms: 3 - Philosopher~'s Evolution'

-
	Philosopher's Evolution
-
	-
		Philosophy
	-
		-
			Philosopher's evolution is a general purpose formula for executing a genetic algorithm.
		-
	-
		Principles
	-
		-
			Formula
		-
			-
				Philosopher's evolution is implemented in a function called the evolve function,
				which takes five arguments.
				
				The first argument is the process function, which takes a single value as an
				argument and may return any value.

				The second argument is the judge function, which takes a single value as an
				argument and shall return a number between zero and one, inclusive.

				The third argument is the threshold value, which shall be a number between zero and
				one, inclusive.

				The fourth argument is the mutate function, which takes a single value as an
				argument and may return any value. If the mutation function passed in is null, a
				default mutation function shall be used in its place.

				The fifth argument is the initial genetic value, and may be of any type.

				The evolve function shall run the process function with the current genetic value,
				which at first shall be the initial genetic value. It shall then take the output of
				the process function and run the judge function with it. If the judge function
				returns a value greater than or equal to the threshold value, the evolve function
				shall return the current genetic value. Otherwise, the evolve function shall run
				the mutate function with the genetic value that resulted in the highest output thus
				far from the judge function, and the output from the mutate function shall then
				replace the current genetic value, and the evolve function shall loop back to the
				beginning.
			-
		-
			Union Module
		-
			-
				A union module is a module that abides by the generator philosopher's medium for
				which the input for its operations is an object containing a list of genetic values
				and a number between zero and one, inclusive, and the output for its operations is
				a single genetic value representing a genetic union between the values in the list,
				where the number is a seed for randomizing the mutations applied to the output.
			-

Use: Locations: 'Kaeon United Specification: 1 - Philosophy: 2 - Philosopher~'s Stone: 1 - Philosopher~'s Conventions: 3 - Philosopher~'s Methods: 2 - Algorithms: 3 - Philosopher~'s Evolution: 1 - Genetic Serialization'

-
	Genetic Serialization
-
	-
		Philosophy
	-
		-
			Genetic serialization is the usage of the serialization of the current state of a given
			process as a seed in genetic algorithms as opposed to an initial seed value from which
			a process was spawned.
		-

Use: Locations: 'Kaeon United Specification: 1 - Philosophy: 2 - Philosopher~'s Stone: 1 - Philosopher~'s Conventions: 3 - Philosopher~'s Methods: 2 - Algorithms: 3 - Philosopher~'s Evolution: 2 - SOUL Rearing'

-
	SOUL Rearing
-
	-
		Philosophy
	-
		-
			SOUL rearing is the process of using philosopher's evolution and union modules to breed
			SOUL entities where a simulated environment applies selective pressures to them, using
			a module that abides by the generator philosopher's medium to convert between genetic
			values and SOUL entities.
		-

Use: Locations: 'Kaeon United Specification: 1 - Philosophy: 2 - Philosopher~'s Stone: 2 - Philosopher~'s Series: 1 - Software: 1 - Methods: 1 - Cross Integrators'

-
	Cross Integrators
-
	-
		Philosophy
	-
		-
			A cross integrator is a utility that dynamically loads and integrates utilities from
			one location or environment into another, restructuring the recipient destination to
			whatever extent necessary in the process.

			The use of cross integrators is referred to as cross integration.
		-
	-
		Principles
	-
		-
			Conventions
		-
			-
				Cross Code
			-
				-
					Cross code is code written in multiple languages which are by default
					incompatible.
				-
		-
			Integrators
		-
			-
				Cross Adapters
			-
				-
					A cross adapter is a cross integrator that dynamically loads, and then either
					transpiles or wraps, foreign utilities so as to make them compatible with the
					recipient environment.
				-
			-
				Cross Builders
			-
				-
					A cross builder is a cross integrator that builds projects from their source
					code without requiring any manual installations or setup beforehand.
				-
			-
				Cross Evaluators
			-
				-
					A cross evaluator is a cross integrator that can interpret or compile cross
					code, and can autocorrect code as it interprets or compiles it.
				-

Use: Locations: 'Kaeon United Specification: 1 - Philosophy: 2 - Philosopher~'s Stone: 2 - Philosopher~'s Series: 1 - Software: 1 - Methods: 2 - Systems: 1 - Platforms: 1 - Virtual System'

-
	Virtual System
-
	-
		Philosophy
	-
		-
			A virtual system is a virtual interface to a system that contains a modular list of
			commands, which shall each have an alias, which may each take an indefinite number of
			arguments, and which each may return a value.
		-
	-
		Principles
	-
		-
			Standard Virtual System
		-
			-
				A standard virtual system provides an interface to a virtual file system through
				its commands, provides commands for file system navigation, for file system
				management, and for dynamically changing the available commands, and may execute
				commands autonomously upon startup.

				In a standard virtual system, if the name of a file is used as a command, it shall
				run as an executable if said file is an executable file.
			-

Use: Locations: 'Kaeon United Specification: 1 - Philosophy: 2 - Philosopher~'s Stone: 2 - Philosopher~'s Series: 1 - Software: 1 - Methods: 2 - Systems: 1 - Platforms: 2 - Seamless Platform'

-
	Seamless Platform
-
	-
		Philosophy
	-
		-
			A seamless platform is a persistently running multimedia application which can be
			accessed through various mediums and which can serve as a platform for various
			multimedia experiences, the elements of which can be dynamically introduced, modified,
			and removed.
		-
	-
		Principles
	-
		-
			Seamless Application
		-
			-
				A seamless application is a persistent multimedia experience for which the elements
				pertaining to it may be spread across various platforms and applications
				simultaneously.
			-
		-
			Seamless Manifestation
		-
			-
				A seamless manifestation is a form that the content of a given seamless application
				may take within a given seamless platform.
			-
		-
			Seamless Element
		-
			-
				A seamless element is something that simultaneously serves as an element of
				multiple seamless applications.
			-
		-
			Seamless Standard
		-
			-
				A seamless standard is a defined set of seamless elements.
			-
		-
			Seamless Log
		-
			-
				A seamless log is a record of data concerning a given state of a given set of
				seamless elements.
			-
		-
			Seamless Hub
		-
			-
				A seamless hub is a service for storing, accessing, and editing seamless logs and
				the seamless elements therein.
			-
		-
			Seamless Atlas
		-
			-
				A seamless atlas is a set of seamless platforms, and the set of all seamless
				platforms is called the seamless metaverse.
			-

Use: Locations: 'Kaeon United Specification: 1 - Philosophy: 2 - Philosopher~'s Stone: 2 - Philosopher~'s Series: 1 - Software: 1 - Methods: 2 - Systems: 2 - Content: 1 - Networks: 1 - Perma-Net'

-
	Perma-Net
-
	-
		Philosophy
	-
		-
			Decentralized platforms that backup records such that they cannot be deleted are called
			perma-platforms, and said records are referred to as perma-content.

			Perma-platforms that can be used by any party to backup any data are referred to as
			open perma-platforms.

			The collective of all perma-platforms and perma-content is called the perma-net.
		-

Use: Locations: 'Kaeon United Specification: 1 - Philosophy: 2 - Philosopher~'s Stone: 2 - Philosopher~'s Series: 1 - Software: 1 - Methods: 2 - Systems: 2 - Content: 1 - Networks: 2 - Hosts: 1 - Virtual Dot'

-
	Virtual Dot
-
	-
		Philosophy
	-
		-
			A virtual dot is an application which, if installed on a device connected to a network,
			can store data and execute code within the host device on behalf of free and anonymous
			requests received via the network, can distribute and verify said data to and among
			other virtual dots via distributed ledgers, can route requests through the network in a
			decentralized manner, and can self-replicate across the network in a non-malicious
			manner.
		-
	-
		Principles
	-
		-
			Properties
		-
			-
				Content
			-
				-
					Virtual Dot Net
				-
					-
						A virtual dot net is a network of virtual dots, and content hosted on
						virtual dot nets is referred to as virtual dot content.

						The collective of all virtual dots and virtual dot content can be referred
						to as the virtual dot web, and the portions of the virtual dot web stored
						on the perma-net can be referred to as the virtual dot stream.
					-
				-
					Virtual Dot Process
				-
					-
						An application running on a virtual dot net is called a virtual dot
						process, and may run in a distributed manner.
					-
				-
					Virtual Dot Tokens
				-
					-
						Any file hosted on a virtual dot net, and any virtual dot process running
						on a virtual dot net, shall be assigned a unique identifying token.
					-
			-
				Embedded Virtual Dot
			-
				-
					An embedded virtual dot is a virtual dot embedded as a subprocess of another
					application.
				-

Use: Locations: 'Kaeon United Specification: 1 - Philosophy: 2 - Philosopher~'s Stone: 2 - Philosopher~'s Series: 1 - Software: 1 - Methods: 2 - Systems: 2 - Content: 1 - Networks: 2 - Hosts: 2 - Shadow Host'

-
	Shadow Host
-
	-
		Philosophy
	-
		-
			A shadow host is an application that takes the locations of existing resources or the
			literal content of said resources as arguments and renders said resources as a new
			application.
		-
	-
		Shadow Host
	-
		-
			Conventions
		-
			-
				Content
			-
				-
					An application hosted on a shadow host is called a shadow application, and
					content utilized by shadow hosts is called shadow content.

					The collective of all shadow hosts and shadow content can be referred to as the
					shadow web, and the portions of the shadow web stored on the perma-net can be
					referred to as the shadow stream.
				-
			-
				Environment
			-
				-
					A shadow host is, by default, implemented as an online application.
				-
		-
			Shadow Host Interfaces
		-
			-
				Along with the locations and content of external resources to render, a shadow host
				may also take the locations and content of external resources which augment its own
				functionality, called shadow host interfaces.

				A shadow host that uses shadow host interfaces is called a modular shadow host.
			-

Use: Locations: 'Kaeon United Specification: 1 - Philosophy: 2 - Philosopher~'s Stone: 2 - Philosopher~'s Series: 1 - Software: 1 - Methods: 2 - Systems: 2 - Content: 2 - Free Web'

-
	Free Web
-
	-
		Philosophy
	-
		-
			The collective of the perma-net, the virtual dot web, and the shadow web can be
			referred to as the free web.
		-

Use: Locations: 'Kaeon United Specification: 1 - Philosophy: 2 - Philosopher~'s Stone: 2 - Philosopher~'s Series: 1 - Software: 1 - Methods: 3 - Services: 1 - Dynamic Response Platform'

-
	Dynamic Response Platform
-
	-
		Philosophy
	-
		-
			A dynamic response platform, or DRP, is a collection of applications which work
			together to interpret external prompts, called dynamic response prompts, whether
			structured or unstructured, in various forms and in real time, and to execute said
			prompts according to the intentions with which they were given, the results of said
			execution being called dynamic response actions.
		-
	-
		Principles
	-
		-
			Components
		-
			-
				Dynamic Response Dispatchers
			-
				-
					A dynamic response dispatcher is an application which takes an indefinite
					number of unstructured text arguments, called dynamic response commands,
					representing dynamic response prompts, and relays said commands to a given set
					of other applications, called dynamic response interpreters, which interpret
					and execute said prompts as dynamic response actions.

					A dynamic response dispatcher may either be implemented as a command line
					application, called a dynamic response module, or as a server, called a dynamic
					response server.

					A dynamic response server, upon intercepting a request, shall respond with a
					list of dynamic response commands to be relayed to a given set of dynamic
					response dispatchers.

					A dynamic response dispatcher that uses machine learning to convert dynamic
					response commands into dynamic response actions, and which takes previously
					received dynamic response commands into account in doing so, is called a
					general dynamic response dispatcher.
				-
			-
				Dynamic Response Observers
			-
				-
					A dynamic response observer is an application which receives dynamic response
					prompts, renders said prompts as dynamic response commands, and relays said
					commands to a given set of dynamic response dispatchers.
				-
		-
			Dynamic Response Standards
		-
			-
				A dynamic response standard is a codified set of defined dynamic response prompts,
				dynamic response commands, dynamic response actions, conversion protocols between
				dynamic response prompts and dynamic response commands, called dynamic response
				prompt to command protocols, and conversion protocols between dynamic response
				commands and dynamic response actions, called dynamic response command to action
				protocols.
			-

Use: Locations: 'Kaeon United Specification: 1 - Philosophy: 2 - Philosopher~'s Stone: 2 - Philosopher~'s Series: 1 - Software: 1 - Methods: 3 - Services: 2 - General Service'

-
	General Service
-
	-
		Philosophy
	-
		-
			A general service is an application that, if run with no additional command line
			arguments, shall perform an operation referred to as its default operation, and if run
			with additional command line arguments, may perform any miscellaneous action.
		-

Use: Locations: 'Kaeon United Specification: 1 - Philosophy: 2 - Philosopher~'s Stone: 2 - Philosopher~'s Series: 1 - Software: 1 - Methods: 3 - Services: 2 - General Service: 1 - Modular Service'

-
	Modular Service
-
	-
		Philosophy
	-
		-
			A modular service is a general service with the ability to integrate plugins, referred
			to as modular service plugins, which may modify the behavior of the service when acting
			on command line arguments.
		-
	-
		Principles
	-
		-
			Management
		-
			-
				Default Operations
			-
				-
					Depending on the command line arguments, a modular service may, among other
					things, install plugins, uninstall plugins, and list plugins currently
					installed.
					
					Each of said plugins shall have a unique string alias.
					
					Plugins installed while any applications spawned by the service are running may
					be dynamically integrated into said applications at runtime.
				-
			-
				Plugin Packages
			-
				-
					A plugin package is a set of plugins.
					
					A package plugin is a plugin package distributed as a single plugin.
				-
		-
			Setups
		-
			-
				Default Functionality
			-
				-
					The default functionality of a modular service refers to the functionality it
					possesses without having installed any plugins.
				-
			-
				Default Configuration
			-
				-
					A default configuration is a group of plugins which are distributed by default
					with a given modular service.
				-
			-
				Package Distribution
			-
				-
					A modular service distributed with a given plugin or plugin package as its
					default configuration is referred to as a distribution of said package.
				-
		-
			Variants
		-
			-
				Blank Modular Service
			-
				-
					A blank modular service is a modular service which has no functionality aside
					from the bare minimum ability to manage plugins as specified in this document.
				-
			-
				Constructed Modular Service
			-
				-
					A constructed modular service is a specification for the functionality of a
					modular service, regardless of whether said functionality is a result of
					plugins or of default functionality.
				-

Use: Locations: 'Kaeon United Specification: 1 - Philosophy: 2 - Philosopher~'s Stone: 2 - Philosopher~'s Series: 1 - Software: 2 - General: 1 - General Philosopher~'s Singularity'

-
	General Philosopher's Singularity
-
	-
		Philosophy
	-
		-
			A general philosopher's singularity is a philosopher's singularity which serves as both
			a modular shadow host and a modular service, and which can expand its functionality
			through the use of interface modules.
		-

Use: Locations: 'Kaeon United Specification: 1 - Philosophy: 2 - Philosopher~'s Stone: 2 - Philosopher~'s Series: 1 - Software: 2 - General: 2 - Philosopher~'s System'

-
	Philosopher's System
-
	-
		Philosophy
	-
		-
			A Philosopher's System is a system architecture where an Aether Union, for which the
			applications and utilities that compose it are derived from a Philosopher's Suite,
			operates on a Philosopher's Vault via a Philosopher's Corpus.
		-
	-
		Principles
	-
		-
			Philosopher's System Standard
		-
			-
				A codified standard for a Philosopher's System is called a Philosopher's System
				standard.
			-

Use: Locations: 'Kaeon United Specification: 1 - Philosophy: 2 - Philosopher~'s Stone: 2 - Philosopher~'s Series: 1 - Software: 2 - General: 2 - Philosopher~'s System: 1 - Conventions'

-
	Philosopher's System Conventions
-
	-
		Philosophy
	-
		-
			This document specifies conventions for Philosopher's Systems.
		-
	-
		Principles
	-
		-
			External Systems
		-
			-
				Philosopher's Imposition
			-
				-
					Philosopher's imposition is the usage of a system which is not a Philosopher's
					System as though it were a Philosopher's System.
					
					A codified standard for Philosopher's Imposition upon a given system is called
					a Philosopher's Imposition standard.
				-
			-
				Philosopher's Integration
			-
				-
					Philosopher's Integration is the transition of a system which is not a
					Philosopher's System to a Philosopher's System.
				-
		-
			Internal Management
		-
			-
				Philosopher's Image
			-
				-
					A Philosopher's Image is a software system derived from a given Philosopher's
					System that operates externally from said Philosopher's System.
					
					A codified standard for a Philosopher's Image derived from a given
					Philosopher's System is called a Philosopher's Image standard.
				-
			-
				Philosopher's State
			-
				-
					A Philosopher's State is a serializable and deserializable model of the state
					of a Philosopher's System at a given point in time.
				-

Use: Locations: 'Kaeon United Specification: 1 - Philosophy: 2 - Philosopher~'s Stone: 2 - Philosopher~'s Series: 2 - Hardware: 1 - Physical Dot'

-
	Physical Dot
-
	-
		Philosophy
	-
		-
			A physical dot is a machine which external devices and applications may use to store
			and transfer data, and which is free and open for anonymous use.
		-
	-
		Principles
	-
		-
			Standards
		-
			-
				A standard physical dot shall have wireless communication functionality.
			-
		-
			Adapter
		-
			-
				A physical dot adapter is any combination of hardware and software that can enable
				a device which does not operate by default as a physical dot to operate as a
				physical dot.
			-
		-
			Networks
		-
			-
				Physical Dot Net
			-
				-
					A physical dot net is a network of physical dots.
				-
			-
				Dual Dot Net
			-
				-
					A dual dot net is a physical dot net with at least one virtual dot net running
					at least partially within it.
				-

Use: Locations: 'Kaeon United Specification: 1 - Philosophy: 2 - Philosopher~'s Stone: 2 - Philosopher~'s Series: 2 - Hardware: 2 - Cross Reality Computer'

-
	Cross Reality Computer
-
	-
		Philosophy
	-
		-
			A cross reality computer is a personal computer embedded into a standalone portable
			device that supports both augmented reality and virtual reality.
		-

Use: Locations: 'Kaeon United Specification: 1 - Philosophy: 2 - Philosopher~'s Stone: 2 - Philosopher~'s Series: 2 - Hardware: 2 - Cross Reality Computer: 1 - Standard Cross Reality Computer'

-
	Standard Cross Reality Computer
-
	-
		Philosophy
	-
		-
			A standard cross reality computer is a cross reality computer that is capable of
			connecting to a wireless network with an indefinite range, and which can, to some
			extent, read the mental state of the user.
		-

Use: Locations: 'Kaeon United Specification: 1 - Philosophy: 2 - Philosopher~'s Stone: 2 - Philosopher~'s Series: 2 - Hardware: 2 - Cross Reality Computer: 2 - Cross Reality Computer Adapter'

-
	Cross Reality Computer Adapter
-
	-
		Philosophy
	-
		-
			A cross reality computer adapter is a device which can be used to allow another type of
			computer to serve as the main processor for a cross reality computer.
		-

Use: Locations: 'Kaeon United Specification: 1 - Philosophy: 2 - Philosopher~'s Stone: 2 - Philosopher~'s Series: 2 - Hardware: 3 - Universal Hardware API'

-
	Universal Hardware API
-
	-
		Philosophy
	-
		-
			The universal hardware API is a protocol designed to allow software to communicate with
			IoT devices through text data over an indefinite range.
		-
	-
		Principles
	-
		-
			Protocol
		-
			-
				When a device that follows the protocol is turned on, it shall connect to a
				network, and shall respond to text data sent through calls made to an online
				endpoint located at a static address. Said calls shall return text data to the
				caller.

				The network that a device which follows the protocol connects to shall be a
				wireless network with an indefinite range.
			-

Use: Locations: 'Kaeon United Specification: 1 - Philosophy: 2 - Philosopher~'s Stone: 2 - Philosopher~'s Series: 2 - Hardware: 3 - Universal Hardware API: 1 - Universal Module'

-
	Universal Module
-
	-
		Philosophy
	-
		-
			A universal module is a device that can function as a personal computer, that can send
			and receive communication using the universal hardware API, and which functions as a
			physical dot.
		-
	-
		Principles
	-
		-
			Standard Universal Module
		-
			-
				A standard universal module is a universal module that has a built-in, interactive
				user interface which either functions as a cross reality computer or can integrate
				into one via a cross reality computer adapter, that participates in a dual dot net,
				and that can be charged wirelessly from renewable sources without relying on any
				separate devices.
			-
		-
			Universal Module Adapter
		-
			-
				A universal module adapter is any combination of hardware and software device that
				allows a universal module to function as another type of device.
			-

Use: Locations: 'Kaeon United Specification: 1 - Philosophy: 3 - Kaeon United: 1 - Conventions'

-
	Kaeon United Conventions
-
	-
		Philosophy
	-
		-
			Kaeon United is an interface suite.
		-
	-
		Principles
	-
		-
			Core
		-
			-
				Alias
			-
				-
					The aliases of Kaeon United are "Kaeon" and "Kaeon United".
				-
			-
				Implementation
			-
				-
					The Kaeon United Interface
				-
					-
						The Kaeon United interface is an interface module, for which the alias is
						"Kaeon United Interface", and which extends Kaeon United, serving as the
						reference to the utilities within the Kaeon United suite.
					-
				-
					The Kaeon United Singularities
				-
					-
						The Kaeon United singularities are a set of interface singularities for
						which the default suite is Kaeon United.
					-
			-
				The Kaeon United Atlas
			-
				-
					The applications that utilize Kaeon United, as well as any data processed by
					said applications, may be collectively referred to as the Kaeon United atlas.
				-
		-
			The Kaeon United FUSION Interface
		-
			-
				Kaeon United, via the Kaeon United singularities, may be used as a Kaeon FUSION
				interface, called the Kaeon United FUSION interface, which may be referenced by the
				alias "Kaeon United", and which shall cause the Kaeon FUSION interpreter to use all
				of the most generally relevant Kaeon FUSION interfaces.

				The Kaeon United FUSION interface shall cause any command that would otherwise not
				return a value to return its content as a string at step three of the FUSION
				process, and shall cause the interface use protocol to go into effect.
			-

Use: Locations: 'Kaeon United Specification: 1 - Philosophy: 3 - Kaeon United: 1 - Conventions: 1 - Operations: 1 - Kaeon Tempest'

-
	Kaeon Tempest
-
	-
		Philosophy
	-
		-
			Kaeon Tempest is a framework composed of all the cross integration utilities in the
			Kaeon United interface.
		-
	-
		Principles
	-
		-
			Kaeon Core
		-
			-
				The utilities in the Kaeon United interface which are not part of Kaeon Tempest can
				be referred to as Kaeon Core.
			-

Use: Locations: 'Kaeon United Specification: 1 - Philosophy: 3 - Kaeon United: 1 - Conventions: 1 - Operations: 2 - Kaeon Origin'

-
	Kaeon Origin
-
	-
		Philosophy
	-
		-
			Kaeon United, via the Kaeon United singularities, may itself be executed as an
			application, which shall serve as an interface to a standard virtual system, with a
			manually configurable embedded virtual dot.
			
			This application shall be called Kaeon Origin.
		-

Use: Locations: 'Kaeon United Specification: 1 - Philosophy: 3 - Kaeon United: 1 - Conventions: 1 - Operations: 2 - Kaeon Origin: 1 - Kaeon Yggdrasil'

-
	Kaeon Yggdrasil
-
	-
		Philosophy
	-
		-
			Kaeon Yggdrasil is an open seamless platform operating on Kaeon ACE which acts as a hub
			for various applications that can operate on said platform and which supports both
			virtual and augmented reality.

			It shall allow for the execution of Kaeon FUSION scripts within itself, and may be
			accessed via any online standard virtual system.
		-
	-
		Principles
	-
		-
			Kaeon Valhalla
		-
			-
				Kaeon Valhalla is a seamless platform which simulates an open universe and which
				supports both virtual and augmented reality.

				It shall allow for the execution of Kaeon FUSION scripts within itself, and may be
				accessed either independently or through Kaeon Yggdrasil.
			-

Use: Locations: 'Kaeon United Specification: 1 - Philosophy: 3 - Kaeon United: 1 - Conventions: 2 - Kaeon META'

-
	Kaeon META
-
	-
		Philosophy
	-
		-
			Kaeon META is a platform that takes requests from users in any form, and executes them
			regardless of what they are.
		-

Use: Locations: 'Kaeon United Specification: 1 - Philosophy: 3 - Kaeon United: 1 - Conventions: 2 - Kaeon META: 1 - Kaeon META Conventions'

-
	Kaeon META Conventions
-
	-
		Philosophy
	-
		-
			This document lists conventions for the Kaeon META platform.
		-
	-
		Principles
	-
		-
			Kaeon Kor
		-
			-
				Kaeon META shall, according to the following Philosopher's System standard, be
				implemented upon a Philosopher's System called Kaeon Kor, for which the
				Philosopher's Suite is Kaeon United, for which the Aether Union is called Kaeon
				Aether, for which the Philosopher's Corpus called Kaeon Sigma, and for which the
				Philosopher's Vault is called Kaeon Gaia.

				Kaeon Aether shall have an Aether Interface called Kaeon Oracle, implemented as a
				dynamic response platform into Kaeon Origin, which can also function as a Genesis
				Philosopher's Seed to Kaeon Aether.

				The data that a given user stores within Kaeon Kor may be collectively referred to
				as said user's Kaeon profile.
			-
		-
			Kaeon FUSION
		-
			-
				Included in the Kaeon United FUSION interface shall be the Kaeon META command,
				which shall work as follows:

				At step three of the FUSION process, an element with the content "Philosophy", or
				"Kaeon META", when processed as a command, shall send each value returned to it to
				Kaeon META, and may return any value should Kaeon META send a value back in
				response.

				Furthermore, once the Kaeon United FUSION interface has been integrated, Kaeon META
				shall be able to modify the state of the program.
			-

Use: Locations: 'Kaeon United Specification: 1 - Philosophy: 3 - Kaeon United: 2 - Kaeon United'

-
	Kaeon United
-
	-
		Philosophy
	-
		-
			This is Kaeon United.
		-
	-
		Wonders
	-
		-
			Use
		-
			-
				Kaeon United Interface
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 1 - Core: 1 - Language: 1 - Modules: 1 - Singularities: 1 - Singularity Conventions'

Standard Singularities

	Philosophy

		-
			This document lists conventions for philosopher's singularities.
		-

	Principles

		Modes

			-
				The standard singularities refer to four types of philosopher's singularities which
				each operate on one of two platforms, the browser and the terminal, and in one of
				two states, as an application and as a library, each combination of platform and
				state being referred to as a mode among the four singularity modes.

				The four modes can be applied to utilities beyond philosopher's singularities, such
				utilities being called modal utilities.

				A multi-modal utility is a utility that can operate in more than one singularity
				mode depending on how it is executed, and an omni-modal utility is a mutli-modal
				utility that can operate in all four singularity modes.

				A set of utilities can be multi-modal or omni-modal.
			-

		Classification

			-
				A defined set of Philosopher's Singularities is called a singularity suite, and a
				single Philosopher's Singularity that provides the functionality of all of the
				Philosopher's Singularities in a given singularity suite is called a suite
				singularity.

				A suite singularity for a singularity suite that covers the four modes is called a
				master singularity.
			-

		Execution

			Suites

				Conventions

					-
						A philosopher's singularity shall have a philosopher's suite from which it
						derives its functionality by default, referred to as its default suite, but
						may also have a means through which an alternate philosopher's suite may be
						specified, referred to as suite configuration mechanisms.

						During runtime, a philosopher's singularity's suite may be altered, with
						its suite at any given point in time being referred to as its current
						suite.
					-

				Suite Configuration Mechanisms

					Web Application

						-
							The URL of a philosopher's singularity running as a web application may
							have an argument called "use", specifying the path to an interface
							module containing an alternate philosopher's suite to use in place of
							the default philosopher's suite.
						-

					Terminal Application

						-
							A philosopher's singularity running as a terminal application may have
							an argument "-use", followed by the path to an interface module
							containing an alternate philosopher's suite to use in place of the
							default philosopher's suite, said arguments being ignored by the rest
							of the program.
						-

			Library

				-
					Generally, in a dynamic programming language, a philosopher's singularity, when
					imported as a library, shall manifest as a function, or object containing said
					function, called the singularity function, which may take a string as an
					argument.

					If said function is given no argument, it shall return, in string form, a
					rendering of the current suite of the singularity.

					If said function is given a string argument, said string shall be interpreted
					as a utility ID string, and the function shall return the first utility within
					its current suite, interpreted as an interface module, which uniquely matches
					said string, using the version of said utility most appropriate for the
					environment the program is running in.

					If the utility ID string provided is "use", a function shall be returned, which
					when executed with a string argument shall set the interface module located at
					the path specified by said string as an alternate suite for the singularity,
					overriding the default suite.
				-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 1 - Core: 1 - Language: 1 - Modules: 2 - Interface Modules: 1 - Conventions'

Standard Interface Module Conventions

	Philosophy

		-
			This document lists interface module conventions and interface ACE conventions.
		-

	Principles

		Standards

			Definitions

				Interface Components

					-
						An interface component is a module which takes one argument, which may
						either be an array of strings or an object for which each field contains a
						string, and which may perform any miscellaneous action in accordance with
						the content of said argument.

						An array of strings corresponds to the command line arguments passed to a
						modular service, and an object in the aforementioned schema corresponds to the
						URL arguments passed to a shadow host.
					-

				Companion Suite

					-
						A Philosopher's Suite specifically designed or used to expand another
						Philosopher's Suite is called a companion suite, and an interface module
						containing such a suite is called a companion interface.
					-

			Identification

				Environments

					-
						The language or environment of a utility within an interface module may be
						specified using the Universal Preprocessor's language aliases.
					-

				Utilities

					-
						A utility identified in an interface module may be identified by a ONE+
						string, called a utility ID string, containing a ONE list specifying a tag
						trace ID for said utility.
					-

			Module Formats

				Document

					-
						A document which specifies an interface module is referred to as an
						interface module document.
					-

				Folder

					-
						A folder, referred to as an interface module folder, containing a
						hierarchical series of sub-folders, may be interpreted as an interface
						module where each file within it constitutes a utility, with the path
						segments of a given file's path relative to the root folder constitutes its
						tag trace ID, and where its file type and its comment document determine
						its properties.
					-

		Conventions

			Interface Module Conventions

				Type

					-
						A utility may have the type property, which may have the values library,
						component, plugin, or application, among others, with library indicating
						that the utility is a library to be imported into a program, with component
						indicating that the utility is a modular service plugin, with plugin
						indicating that the utility is a plugin for another type of system, and
						with application indicating that the utility is an application in and of
						itself.
					-

				Environment

					-
						A utility may have the environment property, indicating which language or
						environment said utility is designed for.

						If an environment is not specified, it may be inferred dynamically.

						For a plugin utility, the environment shall define the application for
						which it is a plugin, specified using an alias for said application,
						referred to as an application alias, or the module ID string of an
						application defined elsewhere in the interface as a utility. If an
						application is executed by a Philosopher's Singularity and said application
						has plugins defined for it in said singularity's interface, said plugins
						shall be integrated into said application automatically.
					-

			Interface ACE Conventions

				Type

					-
						To represent the type property, an interface entity may have a type
						component, which is a Kaeon ACE component with the content "Type", which
						itself shall have a child with the content "Library", "Component", or
						"Plugin", specifying the respective type of the utility said component is
						attached to.
					-

				Environment

					-
						To represent the environment property, an interface entity may have an
						environment component, which is a Kaeon ACE component with the content
						"Environment", which itself shall have a child, the content of which shall
						specify the environment which pertains to the utility said component is
						attached to.

						Environment, generally speaking, shall not be sensitive to letter case or
						to non-alphanumeric characters.
					-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 1 - Core: 1 - Language: 1 - Modules: 2 - Interface Modules: 1 - Conventions: 1 - Flag ACE'

Flag ACE

	Philosophy

		-
			Flag ACE is a set of Kaeon ACE conventions for specifying configuration settings for
			processes to which it is associated, and for specifying procedures to execute when
			integrating its content into certain contexts.
		-

	Principles

		Kaeon ACE Conventions

			Flag

				-
					A flag component is a Kaeon ACE component with the content "Flag", which may
					have any children such that said children specify configuration settings for
					any process to which the document of its entity is associated.

					A codified convention for the content and effect of children of a flag
					component is called a flag convention.
				-

			Protocol

				-
					A protocol component is a Kaeon ACE component with the content "Protocol",
					which may have trigger elements as children, the children of trigger elements
					containing terminal commands to execute upon a certain trigger, the order of
					said children being the order to execute said commands in, and the content of
					trigger elements specifying said trigger.

					A codified convention for the content and effect of the content of a trigger
					element is called a flag protocol convention.
				-

		Component Conventions

			Flag Conventions

				Override

					-
						A flag component may have a child with the content "Override", which, if
						the process to which it is associated is a Philosopher's Singularity, shall
						cause the default suite of said singularity to be disabled.
					-

			Flag Protocol Conventions

				Install

					-
						A trigger element may have the content "Install", the trigger for such a
						trigger element being the installation of the document to which it is
						associated into a new environment.
					-

				Uninstall

					-
						A trigger element may have the content "Uninstall", the trigger for such a
						trigger element being the uninstallation of the document to which it is
						associated from its environment.
					-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 1 - Core: 1 - Language: 1 - Modules: 2 - Interface Modules: 1 - Conventions: 2 - Use File'

Use File

	Philosophy

		-
			A use file is a Kaeon ACE file which has the name "use", which shall be integrated into
			the default suite of a Philosopher's Singularity running out of the directory in which
			it is located.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 1 - Core: 1 - Language: 1 - Modules: 2 - Interface Modules: 2 - JavaScript Components'

JavaScript Components

	Philosophy

		-
			Interface components implemented in JavaScript shall be implemented as CommonJS modules
			for which the module exports are a single function which takes the argument given by
			the host application and acts according to it.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 1 - Core: 1 - Language: 2 - ONE: 1 - Conventions: 1 - Syntax: 1 - Processing: 1 - ONE+'

ONE+
	
	Philosophy
		
		-
			ONE+ is a syntactic superset of ONE.
		-
	
	Principles
		
		Character Sequences
			
			-
				In addition to the three character sequences required by ONE, ONE+ requires the
				following unique character sequences: The segregating sequence, the nested
				sequence, the denested sequence, the open scope sequence, the close scope sequence,
				the open domain sequence, the close domain sequence, the split sequence, the open
				infix sequence, the close infix sequence, the escape sequence, the escape scope
				sequence, the encoded escape scope sequence, the alternate breaking sequence, the
				alternate nesting sequence, the comment sequence, the open comment sequence, the
				close comment sequence, the blank sequence, and the open minus sequence, and the
				close minus sequence.
				
				It is not permitted for the sequences to be defined such that there may be any
				instances where two or more sequences conflict at a given location.
				
				In ONE+, it is possible to have more than one character sequence for each defined
				sequence.
			-
		
		Syntax
			
			-
				ONE+ permits sequences of characters to exist in between ONE elements. Such
				sequences are referred to as plus sequences.
				
				Plus sequences of characters that exist between the beginning of the file, a
				nesting sequence, or a breaking sequence, and a breaking sequence are referred to
				as definitions. Definitions can be nested just like elements depending on how many
				nesting sequences immediately precede them.
			-

		Plus Sequences
			
			Blank Plus Sequences
				
				-
					A blank plus sequence is a plus sequence made up entirely of blank sequences.
					They have no effect on the encoded elements.
				-
				
			Escape Plus Sequences
				
				-
					An escape plus sequence is a plus sequence that consists of an escape sequence
					followed by another sequence of characters. If the sequence of characters
					immediately following the escape sequence would normally have an effect on the
					document, the effect will be nullified. The escape sequence itself will not be
					encoded into any elements.
				-
			
			Escape Scope Plus Sequences
				
				-
					An escape scope plus sequence is a plus sequence that begins with an escape
					scope sequence and ends with another escape scope sequence. If any characters
					located between the two escape scope sequences would normally have an effect on
					the document, the effect will be nullified. The escape scope sequences
					themselves will not be encoded into any elements.
				-
				
			Encoded Escape Scope Plus Sequences
				
				-
					An encoded escape scope plus sequence is a plus sequence that begins with an
					encoded escape scope sequence and ends with another encoded escape scope
					sequence. If any characters located between the two encoded escape scope
					sequences would normally have an effect on the document, the effect will be
					nullified. The encoded escape scope sequences themselves will be encoded into
					the elements.
				-
			
			Extended Escape Scope Plus Sequences
			
				-
					If an escape scope plus sequence or encoded escape scope plus sequence does not
					properly close within the definition it occurs within, and said definition is
					followed by another definition, the sequence will continue through to the next
					definition.
				-
			
			Escape Character Plus Sequences
				
				-
					An escape character plus sequence is a plus sequence that consists of an escape
					sequence followed by either an alternate breaking sequence or an alternate
					nesting sequence. It will not be encoded into the document.
					
					If the escape character plus sequence contains an alternate breaking sequence,
					a breaking sequence will be encoded into the document in place of the escape
					character plus sequence.
					
					If the escape character plus sequence contains an alternate nesting sequence, a
					nesting sequence will be encoded into the document in place of the escape
					character plus sequence.
				-
			
			Comment Plus Sequences
				
				-
					A comment plus sequence is a plus sequence that starts with a comment sequence
					and ends with a breaking sequence. All characters in the plus sequence will
					have no effect on the document.
				-
				
			Comment Block Plus Sequences
				
				-
					A comment plus sequence is a plus sequence that starts with an open comment
					sequence and ends with a close comment sequence. All characters in the plus
					sequence will have no effect on the document.
				-
				
			Minus Plus Sequences
				
				-
					A minus plus sequence is a plus sequence that starts with an open minus
					sequence and ends with a close minus sequence.

					Within a minus plus sequence, ONE+ is parsed as ONE-, where breaking sequences,
					and nesting sequences used for nesting, shall be interpreted as segregating
					sequences, unless they occur within escape or extended escape scope plus
					sequences, in which case they shall be interpreted as escaped alternate
					breaking and alternate nesting sequences respectively.

					ONE- can be used independently of ONE+, where a whole document is parsed as
					ONE- by default.
				-
			
			Plus Element Definitions
				
				-
					A plus element definition is a definition that does not consist entirely of
					blank sequences. All characters except those nullified by comments or escape
					sequences or are blank sequences leading or trailing the definition or comments
					within the definition will be encoded into an element.
				-
			
			Multiple Plus Element Definitions
				
				-
					It is possible to separate the content encoded through a plus element
					definition across multiple elements.
					
					The content can be separated with the following character sequences: the
					segregating sequence, the nested sequence, the denested sequence, the open
					scope sequence, the close scope sequence, the open domain sequence, and the
					close domain sequence. Any blank sequences preceding or following the
					separating sequence will not be encoded into the elements, nor will the
					separating sequence itself.
					
					If a segregating sequence or open scope sequence is used as the separating
					sequence, the element following it will be a sibling of the element preceding
					it.
					
					If a close scope sequence is used as the separating sequence, the element
					following it will be a sibling of the element preceding the corresponding
					open scope sequence.
					
					If a nested sequence or open domain sequence is used as the separating
					sequence, the element following it will be a child of the element preceding it.
					
					If a closed domain sequence is used as the separating sequence, the element
					following it will be a sibling of the element preceding the corresponding open
					domain sequence.
					
					If a denested sequence is used as the separating sequence, the element
					following it will be a sibling of the parent of the preceding element.
				-

			Split Plus Sequence

				-
					A split sequence has the same segregating effect as the segregating sequence.
					
					However, the first element preceding the split sequence which is a sibling of
					the element following the split sequence shall become a parent to clones of the
					children of the element following the split sequence. This effect shall
					propagate across split sequences from right to left.
				-

			Infix Plus Sequences

				-
					An infix plus sequence is a plus sequence which may be used in multiple plus
					element definitions, and that starts with an open infix sequence and ends with
					a close infix sequence.

					For a given infix plus sequence, the text between its starting and ending
					characters shall be defined as its center content.

					For a given infix plus sequence, all text preceding it and following the
					character, or the beginning of the line, which nested said sequence within its
					parent, shall be defined as its left content.

					For a given infix plus sequence, all text following it and preceding the
					character, or the end of the line, which returns the nesting scope to an
					ancestor of said sequence, shall be defined as its right content.

					Processing an infix plus sequence shall cause its center content to become the
					ancestor of its left and right content, with the left content preceding the
					right content.

					Infix plus sequences shall be processed in order from left to right.
				-
			
			Nesting
			
				-
					An element defined in a ONE element definition or the first element defined in
					a plus element definition nested beneath a plus element definition will be a
					child of the last element defined by the parent plus element definition that is
					not followed by a closed domain sequence or denested sequence.
					
					If a multiple plus element definition is ended with a nested sequence or an
					open domain sequence, elements defined following said plus sequence will define
					children of the last element defined by said plus sequence regardless of the
					nest level of said elements, until an excess denested sequence or close domain
					sequence is used respectively.
				-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 1 - Core: 1 - Language: 2 - ONE: 1 - Conventions: 1 - Syntax: 1 - Processing: 1 - ONE+: 1 - Standard ONE+ Language'

Standard ONE+ Language

	Philosophy
	
		-
			The standard variant of the ONE+ Language defines specific sequences of characters as
			the required sequences of the ONE+ language.
			
			The standard variant of the ONE+ language also uses the same sequences of characters as
			the standard variant of the ONE language for the terminating and breaking sequences.
		-
	
	Principles
		
		Standard Sequences
			
			Nesting Sequence
				
				-
					The nesting sequence will be defined by the nest definition line. The nest
					definition line is the first line in the document to have a length greater than
					zero and to begin with either a tab or a space but not to consist solely of
					tabs and spaces.
					
					If no line in the document satisfies the requirements of the nest definition
					line, the nesting sequence will be a tab.
					
					If the nest definition line exists, the nesting sequence will be defined as a
					string containing the first character in the nest definition line. For every
					character nest definition line from the second character, inclusive, to the
					first character that does not match the first character in the nest definition
					line, exclusive, said character will be appended to the nesting sequence.
				-
		
			Segregating Sequence
			
				-
					In the standard variant of the ONE+ Language, the segregating sequence is a
					comma.
				-
				
			Nested Sequence
				
				-
					In the standard variant of the ONE+ Language, the nested sequence is a colon.
				-
				
			Denested Sequence
				
				-
					In the standard variant of the ONE+ Language, the denested sequence is a
					semicolon.
				-
			
			Open Scope Sequence
				
				-
					In the standard variant of the ONE+ Language, the open scope sequence is an
					open parenthesis.
				-
			
			Close Scope Sequence
				
				-
					In the standard variant of the ONE+ Language, the close scope sequence is a
					closed parenthesis.
				-
			
			Open Domain Sequence
				
				-
					In the standard variant of the ONE+ Language, the open domain sequence is an
					open curly bracket.
				-
			
			Close Domain Sequence
				
				-
					In the standard variant of the ONE+ Language, the close domain sequence is a
					closed curly bracket.
				-
			
			Split Sequence
				
				-
					In the standard variant of the ONE+ Language, the split sequence is a vertical
					bar.
				-
			
			Open Infix Sequence
				
				-
					In the standard variant of the ONE+ Language, the open infix sequence is an
					open square bracket.
				-
			
			Close Infix Sequence
				
				-
					In the standard variant of the ONE+ Language, the close infix sequence is a
					closed square bracket.
				-
			
			Escape Sequence
				
				-
					In the standard variant of the ONE+ Language, the escape sequence is a tilde.
				-
			
			Escape Scope Sequence
				
				-
					In the standard variant of the ONE+ Language, the escape scope sequence is a
					single quote.
				-
			
			Encoded Escape Scope Sequence
				
				-
					In the standard variant of the ONE+ Language, the encoded escape scope sequence
					is a double quote.
				-
			
			Alternate Breaking Sequence
				
				-
					In the standard variant of the ONE+ Language, the alternate breaking sequence
					is an 'n'.
				-
			
			Alternate Nesting Sequence
				
				-
					In the standard variant of the ONE+ Language, the alternate nesting sequence is
					a 't'.
				-
			
			Comment Sequence
				
				-
					In the standard variant of the ONE+ Language, the comment sequence is a pound
					sign.
				-
			
			Open Comment Sequence
				
				-
					In the standard variant of the ONE+ Language, the open comment sequence is a
					pound sign followed by an open square bracket.
				-
			
			Close Comment Sequence
				
				-
					In the standard variant of the ONE+ Language, the close comment sequence is a
					closed square bracket followed by a pound sign.
				-
			
			Blank Sequence
				
				-
					In the standard variant of the ONE+ Language, the blank sequence is either a
					space or a tab.
				-
			
			Open Minus Sequence
				
				-
					In the standard variant of the ONE+ Language, the open minus sequence is an
					open curly bracket followed by a closed angle bracket.
				-
			
			Close Minus Sequence
				
				-
					In the standard variant of the ONE+ Language, the close minus sequence is an
					open angle bracket followed by a closed curly bracket.
				-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 1 - Core: 1 - Language: 2 - ONE: 1 - Conventions: 1 - Syntax: 1 - Processing: 2 - Data: 1 - Elements: 1 - Point Element'

Point Element

	Philosophy

		-
			A point element is a ONE element for which the content is irrelevant, but for which the
			placement within the document is not.
		-

	Principles

		Blank

			-
				A blank point element has an empty string as its content.
			-

		Standard

			-
				A standard point element has a period as its content.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 1 - Core: 1 - Language: 2 - ONE: 1 - Conventions: 1 - Syntax: 1 - Processing: 2 - Data: 1 - Elements: 2 - ONE to Kaeon ACE'

ONE to Kaeon ACE

	Philosophy

		-
			A ONE element which is not Kaeon ACE may be converted to Kaeon ACE using the following
			conventions:

			A ONE element which has children shall be converted to an entity for which its content
			becomes its entity alias. A ONE element which has no children shall be converted to a
			content component containing as its sole child an element with its content. Such
			elements, if they are children of other elements, shall be assigned to item generated
			from their parent.

			The exception to the aforementioned conventions is the root element of a ONE document,
			which shall be converted to a use element.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 1 - Core: 1 - Language: 2 - ONE: 1 - Conventions: 1 - Syntax: 1 - Processing: 2 - Data: 2 - Files: 1 - List Form'

ONE List Form

	Philosophy
	
		-
			ONE list form is an alternative way of representing ONE elements as lists rather than
			trees.
		-
	
	Principles
		
		Structure
			
			-
				Any list of objects may be used to represent a ONE element in ONE list form.
				
				The string form of the first object in the list will be said element's content, and
				every object following the first object will represent one of said element's
				children.
				
				If an empty list is interpreted as an element in ONE list form, said element will
				have an empty string as its content.
				
				When interpreting an object within a list as an element's child, the string form of
				the object will be said child's content if the object is not a list, and if the
				object is a list, said child will be said list interpreted as an element in ONE
				list form.
			-

		List ONE Form

			-
				Any list of strings may be represented by a ONE element which has a child for each
				string in said list, said elements being arranged in the order of said strings, and
				each element having the string to which it corresponds as its content.

				This format is called List ONE form, and a ONE element or document in ONE list form
				is called a ONE list.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 1 - Core: 1 - Language: 2 - ONE: 1 - Conventions: 1 - Syntax: 1 - Processing: 2 - Data: 2 - Files: 1 - List Form: 1 - Extended'

Extended ONE List Form

	Philosophy
	
		-
			A ONE element nested within another element may be represented as a list using extended
			ONE list form.
		-
	
	Principles
	
		List Structure
		
			-
				A list representing an element in extended ONE list form contains two lists, the
				first of which represents an element that has no parent in ONE list form, and the
				second of which containing integer numbers greater than or equal to one specifying,
				in order, the indexes leading to the desired nested element.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 1 - Core: 1 - Language: 2 - ONE: 1 - Conventions: 1 - Syntax: 1 - Processing: 2 - Data: 2 - Files: 2 - File Extensions'

ONE File Extensions

	Philosophy
	
		-
			A file containing a ONE document written in only the standard ONE language should have
			the extension ".one".
			
			A file containing a ONE document written in the standard ONE+ language should have the
			extension ".op".
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 1 - Core: 1 - Language: 2 - ONE: 1 - Conventions: 1 - Syntax: 1 - Processing: 2 - Data: 2 - Files: 3 - Abstract Syntax Tree'

ONE Abstract Syntax Tree

	Philosophy
	
		-
			A ONE abstract syntax tree is a ONE element analogous to the abstract syntax tree of a
			given document in a language that can be represented as an abstract syntax tree.
		-
	
	Principles
	
		Structure
		
			-
				A ONE abstract syntax tree contains as its content the name of the language the
				abstract syntax tree represents and every child of it is a node on the tree. Each
				node element has as its content the content of the node it represents and has other
				node elements corresponding to the children of the node it represents. Node
				elements must be arranged in the same order as the nodes they represent.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 1 - Core: 1 - Language: 2 - ONE: 1 - Conventions: 1 - Syntax: 1 - Processing: 2 - Data: 2 - Files: 4 - File Document'

ONE File Document

	Philosophy

		-
			A ONE file document is a ONE document generated from a file or folder and its contents.
		-

	Principles

		Generation

			-
				A folder shall correspond to a ONE element where the name of the folder is its
				content and where each file or folder within said folder corresponds to a child of
				said element, ordered according to their order relative to each other.

				A file shall correspond to a ONE element where the name of said file is its content
				and where, if said file is not a ONE document, said element has one child where the
				content of said child is the content of said file, and if said file is a ONE
				document, said element has the children of the root element of said ONE document as
				its children.

				Files storing ONE documents may be encoded in any format that may be converted to
				ONE.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 1 - Core: 1 - Language: 2 - ONE: 1 - Conventions: 1 - Syntax: 2 - ONE Styling: 1 - ONE Rendering'

ONE Rendering

	Philosophy

		-
			ONE rendering is the process of taking a document that was originally composed in a
			format other than ONE and converting its content into a ONE document, the end result
			being a ONE rendered document.
		-

	Principles

		ONE Derendering

			-
				ONE derendering is the process of taking a document that was originally composed in
				ONE and converting its content into a document in another format, the end result
				being a ONE derendered document.
			-

		Map Formats

			-
				A ONE format which preserves all of the typing implicit in another format is called
				a ONE map format.

				A specific format in another data interchange language which represents ONE is
				called a map ONE format.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 1 - Core: 1 - Language: 2 - ONE: 1 - Conventions: 1 - Syntax: 2 - ONE Styling: 1 - ONE Rendering: 1 - ONE Conversions'

ONE Conversions

	Philosophy

		-
			A ONE document can be represented using the formats of other data interchange
			languages.
		-
	
	Principles

		Plain Text

			ONE to Plain Text

				-
					A ONE document may be converted to plain text by unwrapping the contents of all
					elements within it, placing all of said elements in the order of their position
					within the text of said document when rendered in the standard ONE language,
					and concatenating the unwrapped content of said elements together in said
					order, with each adjacent pair of elements for which the content of both
					neither begins nor ends with a new line separated by a new line.
				-

			Plain Text to ONE

				-
					A plain text document can be converted to a ONE document by trimming all lines
					in the source document, removing all remaining empty lines, and placing each
					remaining non-empty line in order as an element into a new ONE document where
					said line is the content of said element and is wrapped as needed.
				-

		JSON

			Generic

				-
					Any JSON primitive may be converted to a ONE element by stringifying its value
					and creating an element with the resulting string as its content.

					A JSON array may be converted to a ONE element by converting all of its
					elements to ONE elements according to their type, and adding them in order as
					children to a root ONE element with empty content.

					A JSON object may be converted to a ONE element by converting each of its
					fields to a ONE element with the alias of said field as its content and with
					children created by converting its value to a ONE element according to said
					value's type, after which the former element is added in order as a child to a
					root ONE element with empty content.

					Null primitives nested within JSON arrays and objects shall be passed over.

					Root ONE elements with no content, converted from JSON arrays and objects, if
					added to other elements converted from the parents of said arrays and objects,
					shall have their children added directly to the element converted from their
					parent instead of being added themselves.

					JSON values intended to be converted to ONE elements may be called ONE JSON
					values.

					A JSON object generated from a ONE document using the aforementioned
					conventions should be a minimal JSON object.
				-

			Map Formats

				Map ONE Formats

					-
						ONE elements can be represented in JSON using ONE list form, where the
						elements are encoded as JSON lists and element content is encoded as JSON
						strings.

						ONE elements can be represented in JSON using JSON objects, where an object
						may contain a field with the alias "content", containing a string with the
						content of the element, and a field with the alias "children", containing a
						list, where each value represents a child of the element, with the order of
						said values corresponding to the order of said element's children.

						The former format can be called "JSON List ONE", and the latter format can
						be called "JSON Object ONE".

						An element with no children may be specified as JSON string, number,
						boolean, or null literal, with the printed form of each literal specifying
						the element's content. This format can be called "JSON Literal ONE".

						The child values of an element in either JSON List ONE or JSON Object ONE
						may be in any of the aforementioned formats.

						The use of either format can be called "JSON ONE".

						In certain APIs, a JavaScript-style object representing a JSON Object ONE
						element may have a field with the content "parent", which may either
						contain a reference to a value representing the parent element, or a null
						value indicating that it has no parent. This format can be called
						"JavaScript ONE", or "JS ONE" for short.
					-

		XML

			Generic

				-
					ONE elements can be represented in XML using any XML document structure.
					
					Under this paradigm, an XML element is interpreted as a child of the ONE
					element represented by its parent XML element, or of the ONE root element if
					said XML element has no parent, and the content of said ONE element shall be
					the tag name of said XML element.

					An XML attribute is interpreted as a ONE element with a single child, where the
					alias of said attribute is the content of said element, and where the content
					of said attribute is the content of said child.

					An XML text node is interpreted as a child of the ONE element represented by
					its parent XML element, and the content of said ONE element shall be the text
					content of said text node.
				-

			Map Formats

				Map ONE Format

					-
						ONE elements can be represented in XML with the tags "Element" and
						"Content", where letter case is irrelevant, in a format referred to as
						"Standard XML ONE".

						An element tag represents a ONE element and may contain an indefinite
						number of other element tags and may also contain one content tag.

						A content tag must be the child of an element tag, and may contain a string
						representing the content of its parent, which if not present, indicates
						that its parent contains an empty string as its content.
					-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 1 - Core: 1 - Language: 2 - ONE: 1 - Conventions: 1 - Syntax: 2 - ONE Styling: 1 - ONE Rendering: 2 - Kaeon Transcript'

Kaeon Transcript

	Philosophy

		-
			A Kaeon transcript is a ONE rendered document in the form of a Kaeon document derived
			from a document meant to be read directly by users.
		-

	Principles

		Conventions

			Structure

				-
					The title element of the document shall contain the title of the work.

					The philosophy section of the document shall reiterate the title of the
					document and specify other relevant metadata, including, but not limited to,
					the author and version of the work, if applicable.

					The content of the work shall be contained entirely within the principles
					section of the document.
				-

			Basic Conversion

				-
					It is standard practice with Kaeon transcripts to take every newline delineated
					block of text from the source document and to place it into an element, and to
					nest said elements such that the resulting structure of the document mirrors
					the hierarchy of the source document.
				-

			Notation

				-
					It is standard practice with Kaeon transcripts to nest each element with no
					children, or content elements, within another element containing only said
					content element, called an item element, and to nest item elements within
					elements which specify sections, called section elements, and to nest section
					elements either within other section elements. For the purposes of nesting, the
					principles element is considered a section element.

					The content of a section or item element, aside from the principles element,
					shall be determined using the following formula:
					
					If said element is not a direct child of the principles element, its content
					shall begin with the content of its parent, followed by a colon, followed by a
					space.
					
					The content of said element shall end with a string rendered according to the
					following paradigm:

					This string shall start with the name of the type of section or item that the
					element corresponds to, followed by a space, followed by the numerical index of
					the element. If the section to which the element corresponds has a specific
					name, the aforementioned string shall be followed with a space, followed by a
					hyphen, followed by said name.

					If a given Kaeon transcript does not match perfectly to this paradigm, it
					should strive to abide by it as closely as possible.
				-

		Conventional Kaeon Transcript

			-
				A Kaeon transcript that perfectly follows all of the aforementioned conventions is
				referred to as a conventional Kaeon transcript.

				A Kaeon transcript that follows any of the aforementioned conventions to any degree
				is referred to as a semi-conventional Kaeon transcript.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 1 - Core: 1 - Language: 2 - ONE: 1 - Conventions: 1 - Syntax: 2 - ONE Styling: 2 - Right Aligned ONE'

Right Aligned ONE

	Philosophy

		-
			Right aligned ONE is a set of conventions for wrapped ONE elements containing text
			written in scripts or languages that read right to left.
		-

	Principles

		Conventions

			Application

				-
					The forms which right aligned ONE may take apply to the lines of an element's
					content which derive from lines that were right aligned prior to wrapping.

					Said lines are referred to as right content lines, the first non-whitespace
					characters of which are referred to as the origins of said lines.
				-

		Forms

			Unshifted

				-
					In the unshifted form of right aligned ONE, the right content lines shall not
					be modified.

					This is the default form for right aligned ONE content.
				-

			Shifted

				Reverse Indented

					-
						In the reverse indented form of right aligned ONE, for every right content
						line, the origins of said lines shall be preceded with enough whitespace
						such that the resulting length of said lines shall equal the character
						limit of the wrapping minus the combined length of the nesting sequences
						used to nest said line within the document.
					-

				Flat

					-
						In the flat form of right aligned ONE, for every right content line, the
						origins of said lines shall be preceded with enough whitespace such that
						the resulting length of said lines shall equal the character limit of the
						wrapping.
					-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 1 - Core: 1 - Language: 2 - ONE: 1 - Conventions: 2 - Documents: 1 - Kaeon: 1 - Books: 1 - Segmented'

Segmented Kaeon Library Book

	Philosophy

		-
			A segmented Kaeon library book is a Kaeon library book for which the contents are
			spread across multiple documents, called Kaeon library segments, and tied together with
			comments, which for standard Kaeon library books shall be reference notation elements,
			or with their content.
		-

	Principles

		Dating

			-
				Kaeon library segments may use a notation element containing the date and time of
				their creation or publishing, called a date notation element, so as to resolve
				conflicts between conflicting records of the same resource.

				A reference notation element and a date notation element may be used together to
				reassign the location of an existing document within a library.
			-

		Unindexed Folders

			-
				The folders of documents within segmented Kaeon library books may be listed as
				unindexed, where their index number is not displayed in the reference notation
				element to which they apply, if their indices are either unknown or undecided.
			-

		Isolated Elements

			-
				Kaeon library segments may contain individual elements isolated from larger Kaeon
				documents, in which case their position within said document may be specified using
				a notation element, called a path line, containing as its content a trace path of
				the element to which it applies within the Kaeon document that contains said
				element, with the numbers of said path concatenated together using a sequence
				consisting of a space, followed by a hyphen, followed by a space.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 1 - Core: 1 - Language: 2 - ONE: 1 - Conventions: 2 - Documents: 1 - Kaeon: 1 - Books: 2 - Package'

Kaeon Atlas Package

	Philosophy

		-
			A Kaeon Atlas Package (KAP) is a folder which represents the contents of a Kaeon
			library atlas.
		-

	Principles

		Format

			-
				A Kaeon Atlas Package contains a file containing an extended Kaeon library book of
				the Kaeon library atlas, and a folder for each Kaeon library in said atlas,
				labelled by number in the meta-order of said libraries.

				Each of said folders shall contain the contents of the wonders folder of its
				library, but shall only contain the non-readable files.
			-

		Storage

			-
				A Kaeon Atlas Package may be stored as a zip file, and may use the file extension
				".kap".
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 1 - Core: 1 - Language: 2 - ONE: 1 - Conventions: 2 - Documents: 1 - Kaeon: 2 - Kaeon Metadata Document'

Kaeon Metadata Document

	Philosophy
	
		-
			A Kaeon metadata document is a ONE document that may accompany a Kaeon document or
			Kaeon library to provide information regarding the author or authors, time of writing,
			terms of use, reference information, and miscellaneous notes.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 1 - Core: 1 - Language: 2 - ONE: 1 - Conventions: 2 - Documents: 1 - Kaeon: 3 - Alternate Kaeon Document Forms'

Alternate Kaeon Document Forms

	Philosophy

		-
			This document lists alternate forms of ONE content that use similar but different
			conventions relative to those of Kaeon documents.
		-

	Principles

		Semi Kaeon Documents

			Conventions

				-
					A semi Kaeon document is a ONE document that uses a format similar to a Kaeon
					document to encode content in a similar manner to a Kaeon document, but that
					does not follow the Kaeon document format exactly.
				-

			Types

				Masked Kaeon Documents

					-
						A masked Kaeon document is a semi Kaeon document that uses alternate terms
						for the philosophy, principles, and wonders sections.

						The default alternate term for philosophy is "Abstract", the default term
						for principles is "Contents", and the default term for wonders is
						"Program".
					-

				Reduced and Flattened Kaeon Documents

					-
						A reduced Kaeon document has the philosophy, principles, and wonders
						sections of the document removed, and has the children of the principles
						section as the children of the title element instead.

						A flattened Kaeon document is a reduced Kaeon with the title element
						removed, and with the children of the principles section as the children of
						the root instead of the title.
					-

		Masked Kaeon Libraries

			-
				A masked Kaeon library is a Kaeon library that uses alternate terms for the
				philosophy, principles, and wonders sections.

				The default alternate term for philosophy is "Contents", the default term for
				principles is "Metadata", and the default term for wonders is "Archive".
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 1 - Core: 1 - Language: 2 - ONE: 1 - Conventions: 2 - Documents: 2 - Rendering: 1 - ONE Labelling Conventions'

ONE Labelling Conventions

	Philosophy

		-
			This document defines conventions for modifying the content of ONE documents for use in
			printed material.

			A ONE document generated from another using these conventions is referred to as a
			labelled ONE document.
		-

	Principles

		Conventions

			Element Types

				-
					Elements with no children and which have no siblings with children are referred
					to as content elements.

					Elements with children or which have siblings with children are referred to as
					section elements.

					An element which has the root as its parent and no siblings is referred to as a
					title element, even if it would otherwise be a section element.

					However, a maximum length for non-content elements may be specified, resulting
					in any non-content element for which the content exceeds said length, taking
					into account the nesting of said element, being classified as a content
					element.
				-

			Path Markers

				-
					Path markers consist of a list of numbers, representing the nesting path of a
					given element within a tree structure, concatenated together with periods as
					separators.

					To represent trees nested within trees, path markers themselves may be assigned
					a hierarchy, and for a given element, concatenated together with a colon
					followed by a space as a separator, resulting in a poly-path marker.

					Path markers may be generated from ONE trace paths alone, resulting in ONE path
					markers, or together with Kaeon library trace paths preceding them, resulting
					in library path markers. A path marker generated only from a Kaeon library
					trace path is referred to as a library marker.
				-

		Processing

			-
				When generating labelled ONE documents, it must be decided whether to use ONE path
				markers or library path markers, the resulting document being referred to as a
				labelled library document instead of a labelled ONE document in the latter case.

				For each section element, its content shall be preceded by its path marker,
				followed by a space, followed by a hyphen, followed by a space.

				In the case of a labelled library document, each title element shall have its
				content preceded by its library marker, followed by a space, followed by a hyphen,
				followed by a space.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 1 - Core: 1 - Language: 2 - ONE: 1 - Conventions: 2 - Documents: 2 - Rendering: 2 - Paper ONE'

Paper ONE

	Philosophy

		-
			A paper ONE scheme is any convention used to convert ONE to another media format.
		-

	Principles

		Formats

			-
				The format generated by a paper ONE scheme is, in general, a printable document or
				webpage.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 1 - Core: 1 - Language: 2 - ONE: 1 - Conventions: 2 - Documents: 2 - Rendering: 2 - Paper ONE: 1 - Conventions: 1 - Mark-ONE'

Mark-ONE

	Philosophy

		-
			This document specifies conventions regarding the conversion from ONE to Markdown, the
			resulting documents being referred to as Mark-ONE documents.
		-

	Principles

		Conversion

			Common

				-
					Conversion from ONE to Markdown shall begin with all content in the document
					being unwrapped, and with all characters in element content which are
					significant in Markdown being escaped, and shall borrow conventions from the
					ONE labelling conventions.

					Notation elements in Kaeon library books shall be rendered as lines of
					italicized ONE-, these lines being referred to as notation lines.

					Each title and section element shall be assigned a nest level, that being the
					number of periods in a ONE path marker generated for it, plus one.
				-

			Variants

				Primary

					-
						When converted to markdown, title and section elements shall be converted
						to headings of the level indicated by their nest level, capping at the
						maximum level for a heading.

						When converted to markdown, content elements shall be converted to text.
					-

				Flat

					Primary Flat
						
						-
							When converted to markdown, title elements shall be converted to level
							one headings, section elements shall be placed within square brackets
							and converted to bold text, and content elements shall be converted to
							text, with each contiguous sequence of new lines being converted to a
							vertical bar preceded and followed by a space.

							Section elements with nest levels of one shall be omitted when
							converted to markdown, but their children shall all be concatenated
							into one paragraph, separated from other such paragraphs generated by
							other such elements by horizontal rules. When said paragraphs are
							generated, adjacent content elements shall be separated by bold
							vertical bars preceded and followed by a space.
						-

					Secondary Flat

						-
							When converted to markdown, notation lines shall be placed into
							parentheses, title elements shall be placed between square brackets,
							separated from said brackets with a hyphen lining the interior of said
							brackets and a space separating the content of the element from said
							hyphens, section elements shall be placed within square brackets with
							no separation, and content elements shall be converted to text with
							each contiguous sequence of new lines being converted to a vertical bar
							preceded and followed by a space.

							The resulting notation lines, title elements, section elements, and
							vertical bars shall be converted to  bold text, with all of the
							aforementioned items except for title elements being rendered as
							italic.
							
							Section elements with nest levels of one shall be omitted when
							converted to markdown, but their children shall all be concatenated
							into one paragraph, separated from other such paragraphs generated by
							other such elements by tildes preceded and followed by a space. When
							said paragraphs are generated, adjacent content elements shall be
							separated by bold italic vertical bars preceded and followed by a
							space.

							All elements of the converted document shall be concatenated into a
							single paragraph, separated by spaces.
						-

		Conversions

			HTML

				-
					Once a ONE document has been converted to Markdown, said markdown may be
					converted to HTML, resulting in a Mark-ONE page.
				-

			LaTeX

				-
					Once a ONE document has been converted to Markdown, said markdown may be
					converted to LaTeX, resulting in a Mark-TeX page.
				-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 1 - Core: 1 - Language: 2 - ONE: 1 - Conventions: 2 - Documents: 2 - Rendering: 2 - Paper ONE: 1 - Conventions: 1 - Mark-ONE: 1 - Styling'

Mark-ONE Styling Conventions

	Philosophy

		-
			The standard styling for Mark-ONE pages has h1 elements centered, and has all heading
			elements in bold.

			All lines shall be wrapped to fit the page.

			The standard font shall be Georgia, the standard font color shall be black, and the
			standard font size shall be 12pt. The font size of the headings used shall increase
			from 12pt by 2pt per level.

			The indented standard styling for Mark-ONE pages has p elements indented by one tab
			using a left margin of 36pt.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 1 - Core: 1 - Language: 2 - ONE: 1 - Conventions: 2 - Documents: 2 - Rendering: 2 - Paper ONE: 1 - Conventions: 2 - Formatting: 1 - Media'

Paper ONE Media

	Philosophy

		-
			Paper ONE media is a convention for specifying the placement of additional audio-visual
			media into paper ONE documents.
		-

	Principles

		Paper ONE Media Reference

			-
				A paper ONE media reference is a document which specifies HTML content to be placed
				above or below specific elements in a paper ONE document.

				If an element has content placed below it, and the element that follows it has
				content placed above it, the content placed below the first element shall be placed
				above the content placed above the second element.
			-

		Schema

			Paper ONE Media Format

				-
					The paper ONE media format is a Kaeon document format for a paper ONE media
					reference.

					The principles section may have either of the following children: an element
					with the content "Standalone", specifying the content in the case that a Kaeon
					library or document is to be rendered alone, and an element with the content
					"Composite", which shall have a child for each composite Kaeon library to which
					a given Kaeon library may belong, where said composite Kaeon library is
					specified by the content of said child.

					The standalone element and each child of the composite element shall each
					contain the following:

					For each set of HTML content to be placed in the document, the principles
					section shall have an element with the content "Media", which itself shall have
					a child with content consisting of at least four lines.

					The first line shall be the ONE path of the element which the content is to be
					adjacent to, specified relative to the root of the document, and with said path
					rendered by concatenating the numbers of it together in order, separated by
					periods.

					The second line shall be the Kaeon library path of the document which contains
					the element which the content is to be adjacent to, with said path rendered by
					concatenating the numbers of it together in order, separated by periods.
					
					If the document is not to be rendered alone as opposed to within a Kaeon
					library, this line shall be blank.

					The third line specifies whether the content shall be placed above or below the
					specified element, consisting of the string "ABOVE" to place it above said
					element, or "BELOW" to place it below said element.

					The fourth line shall be a link to an HTML document, which may use the
					universal preprocessor.

					Any lines following the fourth line shall specify arguments for the universal
					preprocessor in said documents, to be arranged in the order in which they
					follow the fourth line.
				-

			Paper ONE Media Injection

				-
					Paper ONE media injection is a Kaeon library connection resource convention
					where the resources folder may have a subfolder labelled "Media", which, if
					present, shall contain a document with the title "Media.one", containing a
					paper ONE media reference in the paper ONE media format, rendered in ONE.
				-

		Paper ONE Media Rendering

			-
				Content rendered above or below elements in paper ONE documents in accordance with
				paper ONE media shall be contained in divs encased within shadow roots.
				
				Said divs shall have padding of 1%.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 1 - Core: 1 - Language: 2 - ONE: 1 - Conventions: 2 - Documents: 2 - Rendering: 2 - Paper ONE: 1 - Conventions: 2 - Formatting: 2 - Pages'

Paper ONE Pages

	Philosophy

		-
			This document specifies conventions for generated paginated Paper ONE documents.
		-

	Principles

		Paper ONE Cover Page

			-
				A paper ONE cover page is a page that may be used for the cover of a paper ONE
				document rendered as a paginated document.

				The standard paper ONE cover page consists of a centered image at the top of the
				page, followed by a line at the bottom of the page containing the title of the
				document, rendered in all capitals, in black, bold Georgia font.
				
				If the image is as wide as, or wider than, it is tall, then the image should occupy
				the maximum possible width within said page's margins, and the title should be
				rendered in the largest possible size such that the text of said title does not
				wrap and is not forced onto the next page by the image.
				
				If the image is taller than it is wide, then the title should be rendered in the
				largest possible size such that the text of said title does not wrap, and the image
				should occupy the maximum possible height such that it does not force the title
				onto the next page.

				Ideally, the image used for a Paper ONE cover page should be purely black and
				white, with well-defined edges.
			-

		Page Numbers

			-
				Pages of paper ONE documents that are rendered as paginated documents, save for the
				paper ONE cover page, if present, should have their page numbers written in the
				bottom left corner.

				The standard font for said page numbers is 9pt Georgia.
			-

		Dimensions

			-
				Pages of paper ONE documents that are rendered as paginated documents should have
				margins which are one eleventh their height on all sides and a width to height
				ratio of seventeen to twenty-two.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 1 - Core: 1 - Language: 2 - ONE: 1 - Conventions: 2 - Documents: 2 - Rendering: 2 - Paper ONE: 2 - Standard Scheme'

Standard Paper ONE Scheme

	Philosophy

		-
			The standard paper ONE scheme converts ONE documents to labelled ONE documents before
			converting them to Mark-ONE pages, and styling them with the Mark-ONE indented standard
			styling.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 1 - Core: 1 - Language: 2 - ONE: 1 - Conventions: 2 - Documents: 3 - Framed ONE'

Framed ONE

	Philosophy

		-
			Framed ONE is a variant of ONE where, for each terminating sequence which defines the
			bounds of a ONE element, a sequence of characters called the framing sequence is placed
			following said terminating sequence and either the next breaking sequence or the end of
			the document.

			The framing sequence shall consist of whitespace sufficient to match the length of the
			nesting sequence plus the length of the longest line in the content of the element to
			which it belongs, followed by the terminating sequence.

			The rectangle defined by the two terminating sequences that define the bounds of a
			given element, and the two terminating sequences of the corresponding framing
			sequences, shall constitute the frame of the element to which they belong.

			A document consisting entirely of framed ONE elements shall be called a framed ONE
			document.
		-

	Principles

		Framed ONE Book

			-
				A framed ONE book is a modified standard Kaeon library book where all of the ONE
				documents within it are rendered in framed ONE.
			-

		Ornamentation

			-
				Textual and visual content may be placed outside the frames of framed ONE elements
				for ornamental renderings.

				A framed ONE document surrounded by such ornamentation is called a decorated ONE
				document.
			-

		Unconventional Styling

			-
				If a document in a framed ONE book is not intended to be machine readable via OCR,
				its contents may be formatted improperly to some extent so long as the intent
				remains clear.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 1 - Core: 1 - Language: 2 - ONE: 2 - Kaeon FUSION Conventions'

Kaeon FUSION Standard Conventions

	Philosophy
	
		-
			The Kaeon FUSION Standard Conventions establish standards that Kaeon FUSION
			implementations are expected to support.
		-
	
	Principles

		Command Priority
			
			-
				Certain Kaeon FUSION commands may hold priority over others, meaning that every
				time Kaeon FUSION trickles down at a command, the command's children will be
				rearranged first based on their priority and then based on their current order.
			-

		Default Format Conventions

			-
				Kaeon FUSION shall be preprocessed by the Universal Preprocessor prior to
				execution. If the output of the Universal Preprocessor is a string, the program
				shall be interpreted, and said string must be valid ONE or ONE+. If the output of
				the Universal Preprocessor is a numerical array, an executable shall be generated
				consisting of the content of said array converted to binary, with the same name as
				the source file.
			-
	
		Module Aliases
		
			-
				Kaeon FUSION interfaces may be referenced through aliases as opposed to their file
				paths. The letter case of said aliases is irrelevant.
			-
		
		String Forms

			-
				All values returned by Kaeon FUSION commands must be convertible to strings.
				
				When a value is converted to a string, said string is referred to as the value's
				string form.
			-
		
		Workspace
		
			-
				The workspace refers to the directories that Kaeon FUSION will import resources
				from. The directories that compose the workspace must be arranged into a hierarchy.
				
				When attempting to locate a given resource, Kaeon FUSION will search each directory
				in the order of their priorities until either the resource is found or there are no
				more directories to search.
				
				By default, the workspace will consist of the local directory, the root directory,
				and the internet, but said directories may be added to or removed from the
				workspace.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 1 - Core: 1 - Language: 2 - ONE: 3 - ACE Conventions: 1 - Utilities: 1 - ACE Meta'

ACE Meta
	
	Philosophy
		
		-
			An ACE Meta is a type of ACE element that establishes a common interface between
			various unrelated environments.
		-
	
	Principles
		
		Structure
			
			-
				An ACE Meta element must have the content "ACE Meta", and must have two children,
				the first of which must have the content "Source", and the second of which must
				have the content "Data".
				
				The source element must have a child with content that specifies a certain software
				environment.
				
				The data element must have content that contains saved data for the environment
				specified by the child of the source element.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 1 - Core: 1 - Language: 2 - ONE: 3 - ACE Conventions: 1 - Utilities: 2 - Reduced ACE'

Reduced ACE

	Philosophy
	
		-
			Reduced ACE is a convention for ACE objects and documents. ACE objects and documents
			that adhere to the convention prohibit the use of ACE references.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 1 - Core: 1 - Language: 2 - ONE: 3 - ACE Conventions: 1 - Utilities: 3 - ACE Console'

ACE Console

	Philosophy

		-
			An ACE console is an interface which may be used to modify the ONE document governing
			an active ACE-based simulation, in real time.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 1 - Core: 1 - Language: 2 - ONE: 3 - ACE Conventions: 2 - Kaeon ACE: 1 - Utilities: 1 - Components: 1 - General: 1 - Kaeon ACE Alias'

Kaeon ACE Alias

	Philosophy

		-
			The Kaeon ACE alias component convention is a Kaeon ACE convention regarding Kaeon ACE
			alias components.

			A Kaeon ACE alias component is a Kaeon ACE component element with the content "Alias",
			the content of the children of which specify alternate aliases for the entity to which
			it belongs, such that said aliases may be used for purposes related to the Kaeon ACE
			Trace conventions.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 1 - Core: 1 - Language: 2 - ONE: 3 - ACE Conventions: 2 - Kaeon ACE: 1 - Utilities: 1 - Components: 1 - General: 2 - Kaeon ACE Log'

Kaeon ACE Log

	Philosophy

		-
			The Kaeon ACE log component convention is a Kaeon ACE convention regarding Kaeon ACE
			log components.

			A Kaeon ACE log component is a Kaeon ACE component element with the content "Log",
			the content of the children of which specify, in order, the output of external systems
			relevant to the entity to which it belongs, the content of said children specifying the
			messages themselves, and the descendants of said children specifying metadata regarding
			the messages within which they are nested.

			Codified conventions for the content and meaning regarding the descendants of said
			children are referred to as ACE log conventions.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 1 - Core: 1 - Language: 2 - ONE: 3 - ACE Conventions: 2 - Kaeon ACE: 1 - Utilities: 1 - Components: 1 - General: 3 - Comment'

Kaeon ACE Content Comment

	Philosophy

		-
			The Kaeon ACE content comment convention is a Kaeon ACE convention regarding Kaeon ACE
			content components and subcomponents.

			Under the Kaeon ACE content comment convention, a standard point element that is a
			child of a Kaeon ACE content component shall be interpreted as a significant comment,
			the children of said standard point element being the content of the comment.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 1 - Core: 1 - Language: 2 - ONE: 3 - ACE Conventions: 2 - Kaeon ACE: 1 - Utilities: 1 - Components: 2 - Kaeon ACE Directives'

Kaeon ACE Directives

	Philosophy
	
		-
			Kaeon ACE directives are defined single ordered Kaeon ACE subcomponents with an order
			of one, which are used to specify directives to the host environment.
		-
	
	Principles
	
		Structure
		
			-
				A directive element's content will be "Directive", and it may have any children.
			-
		
		Use
		
			-
				A use directive is a type of directive that instructs the host environment to
				import additional modules. It shall have a child with the content "Use", where
				letter case is irrelevant, and the children of said child shall each have content
				specifying the paths or names of modules to import.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 1 - Core: 1 - Language: 2 - ONE: 3 - ACE Conventions: 2 - Kaeon ACE: 1 - Utilities: 2 - Kaeon ACE Engine'

Kaeon ACE Engine
	
	Philosophy
		
		-
			The Kaeon ACE engine is the standard host environment for the content specified in a
			Kaeon ACE document.
		-
	
	Principles
		
		Structure
			
			-
				The Kaeon ACE engine is built on a Philosopher's Atlas.
				
				The core of the framework is a single Philosopher's Stone module, referred to as
				the Kaeon ACE Stone.
				
				The rest of the framework consists of and processes, which are implemented as
				Philosopher's Stone modules.
			-
			
			Kaeon ACE Stone
				
				-
					The Kaeon ACE Stone will contain a Kaeon ACE Document.
					
					The Kaeon ACE Stone is connected to all processes.
				-
			
			Processes
				
				-
					Processes perform operations for the framework using the entities as an
					interface to the developer.
					
					Each process is connected to the Kaeon ACE Stone.
					
					A process may be connected to more than one Kaeon ACE Stone.
				-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 1 - Core: 1 - Language: 2 - ONE: 3 - ACE Conventions: 2 - Kaeon ACE: 1 - Utilities: 2 - Kaeon ACE Engine: 1 - Standard'

Standard Kaeon ACE Engine

	Philosophy
	
		-
			The standard Kaeon ACE Engine is a standard governing how connections must be handled
			in implementations of the Kaeon ACE Engine using standard Philosopher's Stones.
		-
	
	Principles
	
		Connections
		
			-
				Connections from the Kaeon ACE Stone to process stones must be public.
				
				Connections from process stones to the Kaeon ACE stone must be private.
				
				Any other connection from the Kaeon ACE Stone or a process stone to another
				Philosopher's stone must be private.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 1 - Core: 1 - Language: 2 - ONE: 3 - ACE Conventions: 2 - Kaeon ACE: 2 - Formats: 1 - Module ACE'

Module ACE

	Philosophy

		-
			Module ACE is a set of Kaeon ACE conventions for specifying module schemas and data.
		-

	Principles

		Format

			Module Entities

				-
					A Kaeon ACE entity with a "module" component shall be a module entity and shall
					represent a module schema, containing module properties and variable
					definitions which may be implemented differently in various languages and
					environments.
					
					Module entities that are descendants of other module entities shall represent
					sub modules of their parent modules.

					A module component may have one or both of the following: a child with the
					content "Variables", and a child with the content "Properties".

					Each child of the variables element, referred to as variable elements, shall
					represent a variable in the corresponding module, the content of the element
					representing the alias of the variable, and its children, referred to as field
					elements, representing properties of said variable.

					Each child of the properties element, referred to as property elements, shall
					represent a property of the corresponding module.

					Codified conventions for the content and effects of field elements and property
					elements, and their descendants, are referred to as module ACE conventions.
				-

			Data Content

				-
					The data content convention, or DCC, specifies that a Kaeon ACE entity may
					specify the content of a module, regardless of whether said entity is a module
					entity, using a content component.

					Under DCC, certain children of content components may be interpreted as data
					elements, and shall represent the content of a variable within the module, a
					data element's content specifying the alias of the variable, and its children
					specifying the content of the variable.

					A data element representing an unnamed collection of miscellaneous information
					may be a standard point element.

					In certain contexts, data elements may be interpreted as components or
					descendant entities of the Kaeon ACE entity to which the content component in
					which they are nested belongs. Additionally, in certain contexts, other
					components, and descendant entities, of said Kaeon ACE entity may be
					interpreted as data elements of its content components.

					Codified conventions for the identification of data elements, and for the
					content and effects of their descendants, are referred to as data content
					conventions.
				-

		Conventions

			General Conventions

				Auto-Generation

					-
						Module implementations may be auto-generated from module entities, and
						module entities may be auto-generated from module implementations.

						As such, module ACE may be used to transition a module from one type to
						another.
					-

				Usage

					-
						Module entities may be treated as code modules, classes, APIs, or database
						schemas, among other things, depending on the implementation of their
						content.
					-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 1 - Core: 1 - Language: 2 - ONE: 3 - ACE Conventions: 2 - Kaeon ACE: 2 - Formats: 1 - Module ACE: 1 - Standard'

Standard Module ACE Conventions

	Philosophy

		-
			This document lists module ACE conventions.
		-

	Principles

		Types

			Array
			Boolean
			Character

			Function

				-
					API endpoints are to be specified in the same manner as functions, the aliases
					being their routes and the parameters being their URL parameters.
				-

			Number
			Object
			String
			Variable

		Properties

			API

				GET
				POST

			Database

				Primary

				Relation

					-
						Database fields may be linked to fields in other databases.
					-

			Variable

				General

					Constant
					Private
					Protected
					Public
					Static

				Number

					Types

						Integer
						Float

					Properties

						Size
						Sign

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 1 - Core: 1 - Language: 2 - ONE: 3 - ACE Conventions: 2 - Kaeon ACE: 2 - Formats: 2 - Action ACE'

Action ACE

	Philosophy

		-
			Action ACE is a set of Kaeon ACE conventions which extend query ACE and module ACE, for
			the purpose of querying and serializing the states of systems.
		-

	Principles

		Conventions

			Formats

				Filter ONE

					-
						Filter ONE is a ONE format for specifying patterns for alphanumeric
						content, using filter elements.

						Codified conventions for the content and effects of filter elements are
						referred to as filter conventions.

						By default, a filter element may be a literal element, a pattern element,
						one of the comparison elements, those being greater elements and lesser
						elements, one of the logic elements, those being and elements, or elements,
						xor elements, and not elements, or a unique element.

						A literal element shall have the content "Literal", and shall have one
						child which shall have content specifying a value that the target must be
						equivalent to.

						A pattern element shall have the content "Pattern", and shall have one
						child which shall have content specifying a regular expression that the
						target must match.

						A greater element shall have the content "Greater", and shall have one
						child which shall have content specifying a value that the target's value
						must alphabetically or numerically exceed.

						A lesser element shall have the content "Lesser", and shall have one child
						which shall have content specifying a value that the target's value must
						alphabetically or numerically subceed.

						An and element shall have the content "And", and shall have two filter
						elements as children, the conditions of both of which must be satisfied by
						the target.

						An or element shall have the content "Or", and shall have two filter
						elements as children, the conditions of at least one of which must be
						satisfied by the target.

						An xor element shall have the content "Xor", and shall have two filter
						elements as children, the conditions of one and only one of which must be
						satisfied by the target.

						A not element shall have the content "Not", and shall have one filter
						element as a child, the conditions of which must not be satisfied by the
						target.

						A unique element shall have the content "Unique", and shall indicate that
						the target must be unique among those parallel to it in its parent
						structure.
					-

				Transform ONE

					-
						Transform ONE is a ONE format for specifying transformations for
						alphanumeric content, using transform elements.
						
						Codified conventions for the content and effects of transform elements are
						referred to as transform conventions.

						A series of transform elements, referred to as a transform series, may be
						nested within a parent element, and shall apply to a target in the order of
						their indices.

						By default, a transform element may be a set element, which shall have the
						content "Set", and shall have one child, the content of which shall
						override the value of the target.
					-

			Usage

				Subscriptions

					-
						An action ACE subscription is a relationship established between a module
						entity and an external system such that, if certain changes are made to the
						state of the module said entity corresponds to, said system shall be
						alerted of the nature of the change; the nature of which shall, by default,
						be specified using module ACE.
					-

				Version Control

					-
						Action ACE may be used to manage branching versions and history for
						external systems.
					-

		Components

			Action

				-
					The action component is a Kaeon ACE component with the content "Action", which
					may have an indefinite number of children, referred to as action elements, that
					specify actions to execute on the state of an external system.

					Codified conventions for the content and effects of action elements are
					referred to as action conventions.

					A Kaeon ACE entity with an action component is referred to as an action entity,
					and the external system upon which an action entity is to act is referred to as
					the target of said entity.

					When an action ACE entity is used to interact with an external system, it is
					referred to as an action ACE query, and any response generated by said system
					may be formatted by converting said action ACE entities to module ACE entities,
					and may be referred to as an action ACE response. Action ACE queries and
					responses may both use documents containing many action entities and module
					entities.

					Codified conventions for how to identify the target of an action entity are
					referred to as action target conventions. By default, an action entity's target
					shall be derived from query ACE components of said entity, and if this is not
					possible, then it shall be derived from said entity's alias.

					The target of an action entity shall trickle down to its descendants, either as
					itself or as a corresponding nested system according to the properties of said
					descendant, unless overridden.

					The interfaces between action entities and their targets are contextualized in
					the context of module ACE.

					By default, action elements may be create elements, read elements, update
					elements, or delete elements.

					Read elements, update elements, and delete elements may each have filter
					elements as children, which shall have the content "Filter", may have an
					indefinite number of filter field elements as children, and shall specify the
					contents of the target to act on, referred to as the action targets, with all
					such contents being the default action targets if such a filter element is not
					present.

					Filter field elements shall specify the alias of the module field to filter
					for with their content, and shall have a filter ONE element as a child to apply
					to said module field.

					Create elements shall create a new item within the target module, and may have
					an indefinite number of children referred to as create field elements, which
					specify module fields to create data for in said item with their content, and
					specify the data to assign said field with their children.

					Read elements specify content to return with action ACE responses in the
					corresponding module entities of the action entities sent in the relevant
					action ACE queries.
					
					Read elements may have a child with the content "Fields", which may have
					an indefinite number of children referred to as read field elements, which
					specify module fields to return with their content, the default behavior being
					to return all fields, to the extent permitted.
					
					Read field elements may have a child with a plus sign or minus sign as its
					content, a plus sign specifying to sort items according to the specified field
					in ascending order, and a minus sign specifying to sort items according to the
					specified field in descending order. The order of read field elements with such
					children corresponds to the order in which said sorting is applied.

					Read elements may have a child with the content "Format", which may have an
					indefinite number of children referred to as read format elements. The default
					behavior for action ACE responses is to encode item data in module entities
					using DCC. Codified conventions for the content and effects of read format
					elements are referred to as read format conventions.

					By default, read format elements may be range elements, which shall have the
					content "Range", and shall have one or two children, each with a number as its
					content, specifying a range of items, in the manner of a substring or list
					slice, to return from among those selected by the corresponding read element.

					Update elements shall have have a child with the content "Fields", that may
					have an indefinite number of children referred to as update field elements,
					which specify module fields to transform data for in the action targets with
					their content, and which have a transform series as their children that
					specifies the transformations to apply.

					Delete elements shall delete their action targets.

					If an action entity has a module component, it shall override the properties of
					the target system to the extent permitted. A module entity sent as an action
					ACE response from the target shall have a module component detailing the
					properties of the target to the extent permitted.

					A module entity in an action ACE response may have a log component detailing
					messages logged by the target of the corresponding action entity in the
					processing of the request.
				-

			Access

				-
					The access component is a Kaeon ACE component with the content "Access", which
					may have an indefinite number of children, referred to as access elements, that
					may specify the identity and credentials of an external system.

					As such, access components may serve to override the target of action entities.

					Codified conventions for the content and effects of access elements are
					referred to as access conventions. 
				-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 1 - Core: 1 - Language: 3 - Universal Preprocessor: 1 - Conventions: 1 - Declaration'

Universal Preprocessor Language Declaration

	Philosophy

		-
			This document specifies conventions for uses, and methods thereof, of the directive
			language declaration (DLD) in a universal preprocessor directive or host protocol.
		-

	Principles

		ONE+

			-
				The DLD in a directive may consist of a ONE+ document. This usage is referred to as
				an ODLD.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 1 - Core: 1 - Language: 3 - Universal Preprocessor: 1 - Conventions: 1 - Declaration: 1 - Aliases'

Universal Preprocessor Language Aliases

	Philosophy

		-
			This document specifies the aliases that different languages may use when being
			declared as the host language or as a directive language.

			All aliases declared in this document are case insensitive.
		-

	Principles

		Languages

			Kaeon FUSION

				-
					Kaeon FUSION may use the aliases "Kaeon FUSION" and "KF".
				-

			JavaScript

				-
					JavaScript may use the aliases "JavaScript" and "JS".
				-

			C

				-
					C, or any superset thereof, may use the alias "C".
				-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 1 - Core: 1 - Language: 3 - Universal Preprocessor: 1 - Conventions: 2 - Assembler'

Universal Preprocessor Assembler

	Philosophy

		-
			The universal preprocessor may be used to produce binary data by running it such that
			the preprocessor returns either a string in the form of compiled code or returns a
			number or byte array.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 1 - Core: 1 - Language: 3 - Universal Preprocessor: 1 - Conventions: 3 - Abbreviation'

Universal Preprocessor Abbreviation

	Philosophy

		-
			The Universal Preprocessor may be abbreviated as "PUP".
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 1 - Core: 1 - Language: 3 - Universal Preprocessor: 2 - Dialects'

Universal Preprocessor Dialect

	Philosophy

		-
			A Universal Preprocessor dialect, or PUP dialect, is a defined convention for partially
			or wholly converting one type of document, or a subsection thereof, into another.

			A universal preprocessor dialect must have an alias. Said alias may act as the alias
			of a Kaeon FUSION interface which, when integrated into a universal preprocessor tag,
			allows the dialect to take effect in the document into which said tag is embedded.

			Universal Preprocessor dialects may be used in documents without implementations of
			them if they are simply meant to act as user-readable markup.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 1 - Core: 1 - Language: 3 - Universal Preprocessor: 2 - Dialects: 1 - ONE Dialects: 1 - Zero'

Zero

	Philosophy
	
		-
			Zero is a file format for encoding a ONE document in a way that optimizes the speed at
			which data can be extracted and encoded.
		-

	Principles

		PUP Dialect

			-
				Zero, when applied as a PUP dialect, uses the alias "Zero".
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 1 - Core: 1 - Language: 3 - Universal Preprocessor: 2 - Dialects: 1 - ONE Dialects: 2 - ONE SOUL'

ONE SOUL

	Philosophy
	
		-
			ONE SOUL is an alternate syntax for encoding a ONE document that allows the user to
			dictate their code in natural language and allow an AI to convert said language to ONE
			elements.
		-
	
	Principles
	
		Corpus
		
			-
				The file that stores the corpus used to perform the conversion will be stored in a
				file called "ONE SOUL.op", and will contain two elements, one with the content
				"Model", which will have a child containing the name of the SOUL core model to be
				used, and an element with the content "Corpus", which will have as its children the
				contents of a SOUL core format document.
			-
		
		Processing
		
			-
				The entire file will be processed to ONE+ at once using the model and corpus
				provided by the corpus file.
			-

		PUP Dialect

			-
				ONE SOUL, when applied as a PUP dialect, uses the alias "ONE SOUL".
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 1 - Core: 1 - Language: 3 - Universal Preprocessor: 2 - Dialects: 1 - ONE Dialects: 3 - Flat Path'

Flat Path

	Philosophy

		-
			Flat Path is a PUP dialect which allows Universal Preprocessor tags to be positioned as
			single line ONE+ elements would be, such that a single element nested beneath them may
			be moved to an alternate location within the document. If multiple elements are nested
			beneath said tag, only the first element shall be moved.

			The alias of the flat path dialect is "Flat Path", and a tag which uses the effect must
			use Kaeon FUSION as its language and must have a command with the alias "Flat Path",
			which shall have the numbers of the ONE path to which it is to be moved as children,
			arranged in the order of said path.

			If the resulting placement of the moved elements lies outside the scope of the existing
			document, elements with empty strings as their content shall be added to fill in the
			gaps.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 1 - Core: 2 - Philosopher~'s Stone: 1 - Atlas: 1 - General: 1 - Theory: 1 - Reduced Connection'

Reduced Connection

	Philosophy

		-
			A reduced connection is a type of connection in a Philosopher's Atlas.

			If a given module may only access another by traversing through a reduced connection,
			any argument passed from the former module to the latter module must be converted to a
			string before being passed to the latter module. Likewise, any value returned by the
			latter module must be converted into a string before being returned to the former
			module.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 1 - Core: 2 - Philosopher~'s Stone: 1 - Atlas: 1 - General: 1 - Theory: 2 - Global Retrieval'

Global Retrieval

	Philosophy

		-
			Global retrieval is when Philosopher's Retrieval is used to retrieve a set of files
			and directories from within a specified directory, where the path or content of said
			files and directories matches a given regular expression.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 1 - Core: 2 - Philosopher~'s Stone: 1 - Atlas: 1 - General: 1 - Theory: 3 - Standard Philosopher~'s Cross'

Standard Philosopher~'s Cross

	Philosophy

		-
			A standard Philosopher's Cross is an online Philosopher's Cross with the internal
			structure of a ONE document, that may be interfaced with through HTTP calls.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 1 - Core: 2 - Philosopher~'s Stone: 1 - Atlas: 1 - General: 1 - Theory: 4 - Persistent'

Persistent Atlas Application

	Philosophy

		-
			A persistent atlas application is an application that hosts a philosopher's atlas for
			an indefinite amount of time, maintaining it as real time modifications are made to it
			by both internal and external systems.

			A philosopher's atlas hosted by a persistent atlas application is referred to as a
			persistent atlas.
		-

	Principles

		Architecture

			Persistent Atlas Gate

				-
					A philosopher's gate is a standard module within a persistent atlas to which
					data, in any format, may be sent from external entities.

					When data is sent to said gate, a traversal shall be initiated from said gate,
					and said data shall be passed to the standard functions of any standard modules
					passed through in the course of said traversal, and a list of the values
					returned by said functions shall be returned to the entity from which the data
					was sent.
				-

			Persistent Atlas Interface

				-
					A persistent atlas interface is a philosopher's interface designed specifically
					to incorporate functionality into a the philosopher's atlas of a persistent
					atlas application.
				-

		Applications

			Standard Persistent Atlas

				-
					A standard persistent atlas is initialized with a philosopher's core in the
					form of a standard module which acts as the core of a Kaeon FUSION interpreter
					embedded within the atlas.

					If said core receives data through its standard function, and said data is
					valid ONE or ONE+ after being preprocessed by the universal preprocessor, it
					shall be executed as Kaeon FUSION.

					Aside from the aforementioned core, a standard persistent atlas shall be
					initialized with no other functionality.
				-

			Persistent Atlas Server

				-
					A persistent atlas server is an HTTP server which hosts a persistent atlas.

					Data sent to said server in a request may be passed to the gate of its
					philosopher's atlas after being validated and preprocessed as necessary by the
					server, and the list of values generated by the resulting traversal shall be
					returned in the response.
				-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 1 - Core: 2 - Philosopher~'s Stone: 1 - Atlas: 1 - General: 1 - Theory: 4 - Persistent: 1 - Interface Types'

Persistent Atlas Interface Types

	Philosophy

		-
			This document lists certain groups to which persistent atlas interfaces may belong.
		-

	Principles

		Serializer

			-
				A persistent serializer interface is a persistent atlas interface that returns, in
				string form, data describing some or all of the details regarding the current state
				of the persistent atlas into which it is integrated.
			-

		Deserializer

			-
				A persistent deserializer interface is a persistent atlas interface that takes, in
				string form, data describing some or all of details regarding the current state of
				a given persistent atlas, which it may incorporate into the persistent atlas into
				which it is integrated.
			-

		Client

			-
				A persistent client interface is a persistent atlas interface which returns either
				source data or locations of client applications through which end users may
				interact with the philosopher's atlas into which it is integrated.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 1 - Core: 2 - Philosopher~'s Stone: 1 - Atlas: 1 - General: 2 - Application: 1 - Console'

Atlas Console

	Philosophy

		-
			An atlas console is a text input channel which may be used to interact with an active
			Philosopher's Atlas, where every line of input is passed to said Atlas as a call.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 1 - Core: 2 - Philosopher~'s Stone: 1 - Atlas: 1 - General: 2 - Application: 2 - Axis Stone'

Axis Stone

	Philosophy

		-
			An Axis Stone is a globally available value within a process to which any node on a
			Philosopher's Atlas may connect.

			There should only be one value designated as such, so it may serve as the common link
			between all Philosopher's Atlas nodes in the process to which it belongs. The nodes to
			which an Axis Stone is directly or indirectly connected constitute an Axis Atlas.

			A codified convention regarding how to make use of said common link is referred to as
			an Axis Convention.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 1 - Core: 2 - Philosopher~'s Stone: 1 - Atlas: 2 - SOUL: 1 - Standard'

Standard SOUL
	
	Philosophy
		
		-
			A standard SOUL is a SOUL implemented using a standard module, along with certain
			conventions to ensure cross compatibility.
		-
	
	Principles

		Input and Output

			Object Types

				-
					Objects passed to the train, generate, and correlate functions in a standard
					SOUL must be lists of numbers between zero and one, inclusive.
				-
			
			String Conversion

				-
					Strings may be converted to and from a list of numbers for use as inputs and
					outputs for standard SOULs where each character corresponds to its character
					code divided by the maximum character value if the character code is greater
					than zero, or to zero if the character code is zero.

					The default character encoding for use with a standard SOUL is UTF-32.
				-
		
		The Optimize Function

			-
				Standard SOULs shall have an optimize function which optimizes the SOUL's internal
				representation of its corpus.
			-
		
		SOUL Models
			
			-
				As there are various ways of implementing artificial intelligence, there are
				various ways of implementing a SOUL, some of which may be more suited to certain
				tasks.
				
				The various possible implementations of a standard SOUL are referred to as models.
				
				Each model must have a name with which it can be identified.
				
				Therefore, the standard SOUL must have a function for switching what model it is
				currently using, as well as a function for passing arguments to said model.
				
				A SOUL may only use one model at a time for processing, but it may train multiple
				models at once.

				Each model ought to have a custom file format storing its state.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 1 - Core: 2 - Philosopher~'s Stone: 1 - Atlas: 2 - SOUL: 1 - Standard: 1 - Models: 1 - SOUL Core Variable Model'

SOUL Core Variable Model

	Philosophy
	
		-
			The SOUL core variable model is a model for the standard SOUL core where the output may
			be any vector of any length containing numbers between zero and one, inclusive.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 1 - Core: 2 - Philosopher~'s Stone: 1 - Atlas: 2 - SOUL: 1 - Standard: 1 - Models: 2 - SOUL Core Classifier Model'

SOUL Core Classifier Model

	Philosophy
	
		-
			The SOUL core classifier model is a model for the standard SOUL core that correlates
			any output vector to one of a set of established possible output values.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 1 - Core: 2 - Philosopher~'s Stone: 1 - Atlas: 2 - SOUL: 1 - Standard: 2 - SOUL Core Format'

SOUL Core Format

	Philosophy
		
		-
			The SOUL core format allows standard SOUL to save its state as a ONE document.
			
			The document must have two elements: an element with the content "Corpus", and an
			element with the content "Models".
			
			For every input/output/correlation set in the SOUL's corpus, the corpus element must
			have a child with the content "Set". This child must have three children: an element
			with the content "Input", an element with the content "Output", and an element with the
			content "Correlation". Each one of said elements must have a child with content
			containing its respective value.
			
			For every model the SOUL contains, it must have a child with content containing the
			model's name. Each such element must have a child with the state of its respective
			model encoded in said model's custom file format as its content.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 1 - Core: 2 - Philosopher~'s Stone: 1 - Atlas: 2 - SOUL: 2 - Standard SOUL Core'

Standard SOUL Core

	Philosophy
	
		-
			A standard SOUL core is a SOUL core implemented using a standard module which may only
			be connected to other modules using private connections.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 1 - Core: 2 - Philosopher~'s Stone: 1 - Atlas: 2 - SOUL: 3 - SOUL Entity Conventions'

SOUL Entity Conventions

	Philosophy

		-
			This document specifies conventions for SOUL entities.
		-
	
	Principles

		Atlas

			-
				A SOUL entity atlas is a SOUL entity implemented as or as part of a philosopher's
				atlas.
			-

		Cluster

			-
				A SOUL entity cluster is a group of SOUL entities that for all intents and purposes
				function together as a single SOUL entity.
			-

		Organs

			Philosophy

				-
					SOUL entity organs are modules that interact with SOUL entities.

					They may either be internal, meaning they are part of the SOUL entity itself,
					or external, meaning they interface with the SOUL entity through its input and
					output channels.
				-

			Principles

				Internal

					Pulse

						-
							A pulse is an internal SOUL entity organ that manages an internal event
							loop where upon each iteration other internal SOUL entity organs,
							called pulse modules, may send text through the output channels.
						-

					Record

						-
							A record is an internal SOUL entity organ that stores records of the
							text inputs received, text outputs sent, and numerical inputs received
							by the SOUL entity it belongs to along with the time they were sent or
							received.
						-

					Pulse Modules

						Starter

							-
								A starter is a pulse module that produces randomized output to
								send through the output channel when insufficient data is
								available within whatever records are present.
							-

						Core

							-
								A core is a pulse module that produces output to send through the
								output channel based on the contents of whatever records are
								present when said contents are sufficient.
							-

				External

					Manager

						-
							A manager is an external SOUL entity organ that allows a user to modify
							the state of a SOUL entity, to record the state of a SOUL entity and
							export it to text, to start, pause, or stop the activity of a SOUL
							entity, or to spawn and destroy SOUL entities.
						-

					Breeder

						-
							A breeder is a module that can take the serialized state of a SOUL
							entity and mutate it in order to emulate breeding.
						-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 1 - Core: 2 - Philosopher~'s Stone: 2 - Series: 1 - Systems: 1 - Conventional Virtual System'

Conventional Virtual System

	Philosophy

		-
			A conventional virtual system is a standard virtual system which provides an interface
			to an indefinite number of file storage systems, and which may use various UI shells as
			interfaces to it.

			Each of said file storage systems shall have an alias, and commands shall be provided
			for dynamically changing the shell in use.
		-

	Principles

		General Conventions

			Disks

				-
					Each file storage system managed by a conventional virtual system shall be
					treated as a disk, and every resource therein shall either be a file or a
					folder, with disks in said systems being treated as folders.

					Given the aforementioned conventions, a path for a resource within a
					conventional virtual system shall follow the format of a UNIX style path.
				-

			Disk Interface

				Functions

					Get Resource Function

						-
							Each disk interface within a conventional virtual system shall have a
							get resource function, which shall take an absolute path not including
							the disk and, for a file, shall return its content as a string, and for
							a folder, shall return its contents as a directory JSON array.
						-

					Label Resource Function

						-
							Each disk interface within a conventional virtual system shall have a
							label resource function, which shall take two absolute paths not
							including the disks and assigning any existing resource located at the
							first path to the location and alias specified by the second path.
						-

					Serialize Function

						-
							Each disk interface within a conventional virtual system shall have a
							serialize function, which shall return the contents of said disk in the
							form of a file JSON object. The serialization process may omit contents
							that cannot reasonably be serialized.
						-

					Set Resource Function

						-
							Each disk interface within a conventional virtual system shall have a
							set resource function, which shall take an absolute path not including
							the disk and, for a file, a string, for a folder, a file JSON object of
							a folder and its contents, and to delete an existing resource, a null
							value, and shall place the specified resource at the specified location
							and shall overwrite any existing resource sharing the same path.
						-

				Top Level Interface

					Global Paths

						-
							Any of the disk interface functions may be executed on the file system
							as a whole, with each disk being treated as a folder, but with disks
							needing to be separated from any nested files and folders in file paths
							with the sequence "://" as opposed to a normal slash as a path
							separator.
						-

					Execute Function

						-
							The file system interface shall have an execute function, which shall
							take a string identifying the file in the file system to execute by its
							global path, and a list of string arguments for said command, which
							shall execute said file as a command with said arguments, and shall
							return the value returned by the commands, which should be a string,
							but does not have to be. The execute function may operate differently
							depending on the location of the executed file.
						-

					I/O Override

						API Override

							-
								A conventional virtual system shall, to whatever extent possible,
								override the IO APIs its environment uses by default to read from
								and write to the virtual file system as well the native
								environment.
							-

						Error Handling

							-
								A conventional virtual system shall store any file that fails to be
								persisted to external memory in runtime memory, such that it may be
								read from so long as the process remains active.
							-

			System Conventions

				Commands

					Disks

						-
							Conventional virtual systems shall include commands for adding and
							removing disks from the file system.
						-

					Shells

						-
							Conventional virtual systems shall include commands for changing the UI
							shell in use.
						-

		Standard Conventions

			Standard Disks

				HTTP and HTTPS

					-
						By default, the virtual file system of a conventional virtual system shall
						allow the use of HTTP and HTTPS via disks with the aliases "HTTP" and
						"HTTPS" respectively.
					-

				IP

					-
						An IP disk, the alias of which may be an IP address or a DNS domain,
						represents the file system of the machine located at said address or
						domain, in which the drives of said machine are treated as ordinary
						directories nested within the IP disk.

						Commands executed within the scope of an IP disk shall, by default, be
						executed on the machine to which said disk pertains.
					-

				Storage

					-
						By default, the virtual file system of a conventional virtual system shall
						use a disk defined by a file JSON object with the alias "Storage".

						This disk shall be stored in memory, and shall be persisted to a local
						storage mechanism, if possible, such that its contents may remain between
						sessions.
						
						Such storage mechanisms may include the local storage if running in the
						browser, and the local file system if running natively.
					-

			Online Conventions

				User Configurations

					-
						When accessing a conventional virtual system operating in a web browser,
						the user may append, to its URL, arguments for overriding or extending its
						configurations.

						An argument with the alias "config", if present, may contain either a URL,
						or a JSON list of strings containing URLs, with each URL pointing to a
						system JSON file, which shall be implemented alongside, or in place of, the
						default configuration file.

						An argument with the alias "override", if present, may contain either the
						string "true", or the string "false", and if said argument contains the
						string "true", then the default configuration file shall not be implemented
						on startup.

						An argument with the alias "IP", if present, shall contain a JSON list of
						strings specifying the IP address or domain names of IP disks to use during
						the session.
					-

				JavaScript

					-
						Outside of IP disks, executable files in conventional virtual systems
						operating in web browsers shall be written in JavaScript and shall use a
						".js" file extension.
					-

			Interface Conventions

				Shells

					Terminal

						-
							The default shell for a conventional virtual system is a terminal
							interface, where commands submitted via the terminal are executed
							within the virtual system, and where output from processes initiated by
							said commands is logged to said terminal.

							The terminal shall at any given time operate within a given folder, and
							commands built into the virtual file system shall allow the terminal to
							navigate among the file system.

							The terminal may be assigned an indefinite number of file paths in
							which executable files may be placed and referenced by their file names
							alone as opposed to their absolute or relative paths.

							If an executed command returns a function, an object reference to the
							terminal shall be passed to said function, which may modify the
							terminal accordingly.
						-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 1 - Core: 2 - Philosopher~'s Stone: 2 - Series: 1 - Systems: 2 - Conventional Dynamic Response Platform'

Conventional Dynamic Response Platform

	Philosophy

		-
			A conventional dynamic response platform is a dynamic response platform primarily set
			up to function as a virtual assistant.
		-

	Principles

		Core Module

			-
				The core module of a conventional dynamic response platform is a single dynamic
				response module to which all dynamic response commands are directed.
			-

		Observers

			Speech

				-
					The speech observer is a dynamic response observer which shall constantly
					listen via a microphone for user speech, converting all received speech to
					text.

					The speech observer shall be assigned at least one wake phrase, any of which,
					if uttered, shall cause the text generated by the next received utterance,
					called a spoken directive, to be passed to the core module as a dynamic
					response command.
				-

		Processes

			Dynamic Chat System

				-
					The dynamic chat system is a sub-system of a conventional dynamic response
					platform which, for any other speech other than wake phrases and spoken
					directives, may respond to it, generally via synthesized speech, in a
					conversational manner akin to a chatbot, and may execute commands based on the
					course of the conversation, and may also initiate interaction with the user,
					according to dynamic response prompt to command protocols called dynamic
					conversational protocols.
				-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 1 - Core: 2 - Philosopher~'s Stone: 2 - Series: 1 - Systems: 3 - Modular Service: 1 - Plugins: 1 - Types: 1 - Server Plugin'

Server Plugin

	Philosophy

		-
			A server plugin is a modular service plugin that causes the default operation of a
			modular service to initiate a process hosting web API that may be interfaced with via
			HTTP calls.

			A modular service utilizing a server plugin is called a modular server service.

			A server spawned by a server plugin is referred to as an instance of said plugin.
		-

	Principles

		Server Module Plugin

			Overview

				-
					A server module plugin is a modular service plugin which extends the
					functionality of a modular server service.
				-

			Operations

				-
					A server module plugin may have an initialization operation which occurs when
					the service is initiated or when the plugin is integrated, may modify the
					contents of incoming and outgoing HTTP requests, may act in accordance with the
					contents of incoming HTTP requests, and may perform operations at regular
					intervals.
				-

			Implementation

				JavaScript

					-
						A server module plugin may be implemented as an extension in a JSON
						interface using the string alias "server" to specify the application, and
						with the plugin itself taking the form of a CommonJS module that exports
						any of the following functions: one called "onInitialize", one called
						"onIncoming", one called "onOutgoing", and one called "onInterval".

						Each of said functions shall take an object representing the current state
						of the server as its first argument.

						The onInitialize function shall activate when the server starts up for the
						first time, or when the plugin is first detected during runtime.

						The onIncoming function shall activate when the server receives an incoming
						request, and shall take an additional argument in the form of an object
						representing said request.

						The onOutgoing function shall activate before the server sends a response
						to a client, and shall take a second argument in the form of an object
						representing the request to which said response corresponds, and an object
						representing said response.

						The onInterval function shall activate once for every passing of a regular
						interval, which unless otherwise specified should by default be one
						sixtieth of a second.

						Each of the aforementioned functions may make any modification to the
						contents of the arguments passed to them and may perform any other
						miscellaneous operation.
					-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 1 - Core: 2 - Philosopher~'s Stone: 2 - Series: 1 - Systems: 3 - Modular Service: 2 - Conventional'

Conventional Service

	Philosophy

		-
			A conventional service is a modular service with the default functionality specified in
			the conventional service conventions, defined by the contents of the principles section
			of this document.
		-

	Principles

		Operation

			Letter Case

				-
					The letter case of command line arguments passed to the service shall be held
					irrelevant.
				-

			Standard Operation

				Global Command
				
					-
						The command to execute the default operation of a general service, when it
						is installed globally, shall be referred to as its global command.
					-

		Management

			Default Operations

				-
					If the service is executed with the string "install" as its first command line
					argument, it shall install all plugins for which the aliases thereof match any
					of the following command line arguments.

					If the service is executed with the string "uninstall" as its first command
					line argument, it shall uninstall all plugins for which the aliases thereof
					match any of the following command line arguments.

					If the service is executed with the string "list" as its first command line
					argument, it shall log the aliases of all of the plugins currently installed on
					said service to the console.
				-

			Plugins

				-
					Plugins used by the service shall be in the form of interface modules, and
					shall be tracked using a plugin log in the form of a plugin log JSON list
					specified in the environment configurations of the service.
				-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 1 - Core: 2 - Philosopher~'s Stone: 2 - Series: 1 - Systems: 3 - Modular Service: 2 - Conventional: 1 - Package'

Conventional Package

	Philosophy

		-
			A conventional package is a plugin package which implements into a modular service the
			functionality specified in the conventional package conventions, defined by the
			contents of the principles section of this document.
		-

	Principles

		Processes

			Auto-Configuration

				-
					The service shall automatically configure system settings as necessary, on both
					the system it is running on and any external devices which extend said system.
				-

			Logging

				-
					The service shall log information in a standard terminal multi-item UJSON
					document.

					If the service utilizes multiple processes, the main process shall assign its
					log items the tag of "main". All other processes shall assign their log items a
					tag unique to them.
				-

			Updating

				-
					The service shall make use of an auto-updater.
				-

		Commands

			Log

				-
					The service, when executed with the string "log" as its first argument, shall,
					if it has no further arguments, log the contents of each of its terminal logs
					to the console, and, if it has an additional argument, copy the contents of
					said terminal logs to a file at the path specified by said additional argument.
				-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 1 - Core: 2 - Philosopher~'s Stone: 2 - Series: 1 - Systems: 3 - Modular Service: 2 - Conventional: 1 - Package: 1 - Server'

Conventional Server Package

	Philosophy

		-
			A conventional server package is a conventional package that includes a server plugin,
			and which includes the functionality specified in the conventional server conventions,
			specified as the contents of the principles section of this document.
		-

	Principles

		Operation

			Standard Operation

				Default Operation
				
					-
						The service, when executed with no arguments, shall start the server for
						its API at a default port, determined by the device that the server is
						running on.

						Under most circumstances, and unless otherwise specified, this port should
						be 80.
					-

				Port Specification
				
					-
						The service, when executed with a number as its first argument, shall start
						the server at the port specified by said number.
					-

		Commands

			Clear

				-
					The service, when executed with the string "clear" as its first argument, shall
					clear all data logged by the server.
				-

			Disable

				-
					The service, when executed with the string "disable" as its first argument,
					shall stop the execution of the server for its API, and shall prevent it from
					restarting on boot.
				-

			Enable

				-
					The service, when executed with the string "enable" as its first argument,
					shall start the execution of the server for its API, and shall cause it to
					restart on boot.

					Furthermore, it shall also automatically install any necessary dependencies if
					they are not installed already, and shall set certain system settings to the
					necessary values if they are not already set.
				-

			Ping

				-
					The service, when executed with the string "ping" as its first argument, shall
					ping the server for its API with a post request containing in its body the
					content of the second argument.

					If a third argument is specified, the body of the response shall be written to
					a file at the path specified by said argument.

					Otherwise, the body of said response shall be logged to the console.
				-

			Reset

				-
					The service, when executed with the string "reset" as its first argument, shall
					reset all settings for the server to their default values.
				-

			Status

				-
					The service, when executed with the string "status" as its first argument,
					shall print "On" to the console if the server for its API is currently active,
					and shall otherwise print "Off" to the console.
				-

		Access

			POST

				-
					The server for the service's API, when pinged with a POST request, shall
					respond with text data.
				-

			GET

				-
					The server for the service's API, when pinged with a GET request, shall respond
					with an HTML web page serving as a user-friendly GUI.
				-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 1 - Core: 2 - Philosopher~'s Stone: 2 - Series: 1 - Systems: 4 - Open Axis'

Open Axis

	Philosophy

		-
			Open Axis is an axis convention for establishing standard sub-processes to operate on
			the Axis Atlas of a given process.

			Such processes shall, unless otherwise specified, operate on said Atlas by traversing
			over it upon certain triggers and passing a certain type of value to the standard
			function of all nodes in said Atlas which abide by the standard Philosopher's medium.
			Such traversals are referred to as open traversals, the values passed to the standard
			functions are referred to as axis packets, and the values returned by said functions
			during said traversals are referred to as axis responses.
		-

	Principles

		Standard Nodes

			Universal

				Axis Clock

					-
						The Axis clock is a node on a Philosopher's Atlas which, at regular
						intervals, performs an open traversal with a number as its atlas packet,
						specifying the time in seconds since the last open traversal performed by
						it.
					-

			Backend

				Axis Server

					-
						The Axis server is a node on a Philosopher's Atlas which hosts a server
						that performs an open traversal whenever it receives a request, with the
						atlas packet being said request converted to HTTP JSON, and returns to the
						client a response generated from any response HTTP JSON objects returned
						among the axis responses, with the body of the response being a stringified
						JSON list of the bodies of all such responses if more than one response
						with a body is returned.
					-

		Axis Web Server

			-
				An axis web server, which is implemented upon Open Axis, shall act as a virtual
				dot, a modular service, a JSH server, and an Aether Host. If an axis web server is
				accessed through the frontend, it shall load a frontend virtual system, which shall
				have access to the system on which the server is running. An axis web server may
				optionally function as a SOUL bot, and may optionally employ security measures
				restricting certain external inputs to those with certain credentials.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 1 - Core: 2 - Philosopher~'s Stone: 2 - Series: 1 - Systems: 4 - Open Axis: 1 - Axis Directory'

Axis Directory

	Philosophy

		-
			An axis directory is a directory used by a web server to store publicly accessible
			content.
		-

	Principles

		Conventions

			Alias Metadata

				-
					The alias metadata format may be applied to files and folders in axis
					directories.
					
					By default, items in axis directories act as publicly accessible static
					content, though metadata segments in their file names may change this. Items
					identified via metadata segments as publicly inaccessible are private.

					Metadata segments used on such items are case insensitive.
				-

			Overlay

				-
					All axis directories used by a given web server shall be virtually overlaid
					using folder overlay, the resulting directory being referred to as the axis
					directory of the server.
				-

			Routing

				-
					The subdirectories of a URL shall specify a path within the axis directory of
					the server at which the desired resource may be found, with the MIME type set
					according to the file extension, unless altered by metadata segments.
					
					For the file name, only the ID sequence is necessary for any file without
					metadata segments.

					If no file name is specified for a folder in which a file with the ID sequence
					"index" is present, said file shall be retrieved.

					If no file name is specified for a folder with no such index file, a plain text
					response shall be sent containing the contents of said folder, save for any
					private items, which by default shall be specified using a directory JSON list.

					If multiple files matching the specified path are located, they shall be sorted
					alphabetically, and the first in the resulting order shall be retrieved.

					The server may have a default redirect set for a 404 error. If no such redirect
					is set, the server shall return a plain text message reading "404: Not Found".
				-

		Defaults

			Name

				-
					The default name for a folder used to store an Axis directory is "Axis".
				-

			Open Axis

				-
					An axis web server shall use an axis directory.
				-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 1 - Core: 2 - Philosopher~'s Stone: 2 - Series: 1 - Systems: 4 - Open Axis: 1 - Axis Directory: 1 - Standard Segments'

Standard Segments

	Philosophy

		-
			This document lists metadata segments for use by files in axis directories.
		-

	Principles

		API

			-
				Any JavaScript file in an axis directory with the metadata segment "api" shall be
				executed upon a request that retrieves it, and shall return an HTTP JSON object
				specifying the response to be returned to the client.

				Alternatively, such a segment may be a key-value pair segment, with "api" as the
				key, and the intended HTTP method used to access it being the value, such that any
				request not using said method will fail to access it.
			-

		App

			-
				Any JavaScript file in an axis directory with the metadata segment "app" shall be
				preprocessed to an HTML page which runs the content of said file as United
				JavaScript via Kaeon United.
			-

		Private

			-
				Any item in an axis directory with the metadata segment "private" shall be marked
				as a private item.
			-

		PUP

			-
				The universal preprocessor shall be applied to any file in an axis directory with
				the metadata segment "PUP".

				The tags in said file, when processed, shall receive as their first external
				argument an HTTP JSON object specifying the content of the request that retrieved
				said file.
			-

		Task

			-
				Any JavaScript file in an axis directory with the metadata segment "task" shall be
				executed periodically by the server as a script in a perpetual background process.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 1 - Core: 2 - Philosopher~'s Stone: 2 - Series: 2 - Universal Hardware API'

Universal Hardware API Conventions

	Philosophy

		-
			This document lists several conventions for the universal hardware API.
		-

	Principles

		Standards

			HTTP

				-
					An endpoint upon which the universal hardware API operates shall be implemented
					as an HTTP server.
				-

			Cellular

				-
					A device upon which the universal hardware API operates shall receive data
					through a cellular network.
				-

		Recommendations

			Documentation

				-
					An HTTP GET request to the base route of the server of a device that follows
					the protocol shall return a string containing a document file specifying the
					routes provided by said device's server.
				-

			Modification

				-
					Ideally, a device that follows the protocol should have some sort of secure
					mechanism in place to manually override its hard coded settings.
				-

			HTTPS

				-
					For security purposes, universal hardware API servers should use HTTPS.
				-

		Options

			Autonomous Behavior

				-
					A device that follows the protocol may act autonomously or according to other
					stimuli when not being directly controlled via HTTP calls.
				-

			GUI Pages

				-
					A device that follows the protocol may use its server to serve web pages that
					provide graphical interfaces for some or all of its functionality.
				-

			Security

				-
					A device that follows the protocol may restrict the use of some or all of its
					functionality to specific users, who must provide credentials in order to prove
					their identity.
				-

			Search

				-
					A device that follows the protocol may make itself publicly discoverable via
					certain search engines.
				-

		Acronym

			-
				The universal hardware API can be referred to as UHAPI ("you-happy") for short.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 2 - Theory: 1 - Utilities: 1 - Software: 1 - Data: 1 - Organization: 1 - General Identifier'

General Identifier

	Philosophy

		-
			A general identifier is any string that serves to locate a digital resource stored on
			a given device or network of devices.
		-

	Principles

		Types

			-
				URIs and file paths, among others, are types of general identifiers, with URIs
				being the standard type.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 2 - Theory: 1 - Utilities: 1 - Software: 1 - Data: 1 - Organization: 2 - Database as Document'

Database as Document

	Philosophy

		-
			Under the database as document model, when designing a database, its contents and rules
			should be conceived of as the contents of a single document rendered in a pre-existing,
			general-purpose data interchange format.

			Any interface to such a database should be designed as though its conception matched
			its implementation.
		-

	Principles

		Query as Document

			-
				Under the query as document model, queries to databases should take the form of
				documents rendered in a pre-existing, general purpose data interchange format.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 2 - Theory: 1 - Utilities: 1 - Software: 1 - Data: 2 - Graphs: 1 - Conventions: 1 - Elements'

Graph Elements

	Philosophy

		-
			Graph elements is an umbrella term referring to both the nodes and connections of
			graphs.

			Graph elements may contain connection data, defining which other graph elements they
			are connected to and how, and other miscellaneous metadata.

			Said graphs may be called discrete graphs to distinguish them from other types of
			graphs.
		-

	Principles

		Graph Role Reversal

			-
				Graph Role reversal is where connections of a graph are treated as nodes, or where
				nodes of a graph are treated as connections, or both.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 2 - Theory: 1 - Utilities: 1 - Software: 1 - Data: 2 - Graphs: 1 - Conventions: 1 - Elements: 1 - Types: 1 - Nodes'

Node Value Equivalence

	Philosophy

		-
			A single node in a graph, or a graph with a single node, may be interpreted as the
			value contained by said node, and a single value may be interpreted as a single node in
			a graph, or a graph with a single node.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 2 - Theory: 1 - Utilities: 1 - Software: 1 - Data: 2 - Graphs: 1 - Conventions: 1 - Elements: 1 - Types: 1 - Nodes: 1 - Void Nodes'

Void Nodes

	Philosophy

		-
			Void nodes are nodes that do not exist on a given graph but are imagined to by some
			external entity.

			Nodes which are not void nodes can be called real nodes.
		-

	Principles

		Void Collapse

			-
				Void collapse is when a void node is added to its graph as a real node, and any
				additional nodes and connections are added to the graph to accommodate the
				addition.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 2 - Theory: 1 - Utilities: 1 - Software: 1 - Data: 2 - Graphs: 1 - Conventions: 1 - Elements: 1 - Types: 1 - Nodes: 2 - Ghost Nodes'

Ghost Nodes

	Philosophy

		-
			Ghost nodes are nodes of a graph which are not currently observable in a given context,
			but are inherently implied to exist by virtue of certain facts of the graph's structure
			being known via other information.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 2 - Theory: 1 - Utilities: 1 - Software: 1 - Data: 2 - Graphs: 1 - Conventions: 1 - Elements: 1 - Types: 1 - Nodes: 3 - Mystery Nodes'

Mystery Nodes

	Philosophy

		-
			Mystery Nodes are nodes on a graph that act as stand-ins for a sub-graph of the graph
			to which it belongs.

			If said sub-graph can be accessed, the mystery node is referred to as open, whereas if
			said sub-graph cannot be accessed, the mystery node is referred to as closed.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 2 - Theory: 1 - Utilities: 1 - Software: 1 - Data: 2 - Graphs: 1 - Conventions: 1 - Elements: 1 - Types: 2 - Edges'

Edge Conventions

	Philosophy

		-
			This document lists conventions for graph edges.
		-

	Principles

		Edge Unification

			-
				A linear sequence of non-branching nodes with consistent directionality, and not
				containing a targeted or otherwise special node, may be taken as a single edge with
				its properties being the summation of its constituent elements.
			-

		Bidirectionality Types

			-
				For a given process operating on a given node, bidirectionality between said node
				and another may either result from data, where said process is either independently
				aware of the other node or where said node contains a reference to it, or from a
				rule, where said process is forbidden from acknowledging a connection between the
				nodes in question.
			-

		Reduced Traversal Recollection

			-
				A process which traverses a graph and maintains a log of previously visited nodes
				for the sake of preventing loops need only record the previous node and any other
				node with more than one incoming one-way connection, or more than two incoming
				connections of miscellaneous directionality.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 2 - Theory: 1 - Utilities: 1 - Software: 1 - Data: 2 - Graphs: 1 - Conventions: 1 - Elements: 2 - Entangled Elements'

Entangled Elements

	Philosophy

		-
			Entangled elements are sets of graph elements which share static properties, meaning
			that altering said static properties for one of them alters it for all of them.

			Perfectly entangled elements are those for which all properties are static, effectively
			being shallow copies of one another.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 2 - Theory: 1 - Utilities: 1 - Software: 1 - Data: 2 - Graphs: 1 - Conventions: 2 - Algorithms: 1 - Bounds Finding Algorithms'

Bounds Finding Algorithms

	Philosophy

		-
			A bounds finding algorithm is an algorithm for determining information regarding the
			size, structure, or both of a graph for which said information cannot be directly
			accessed.

			Such a graph is called a bound agnostic graph.
		-

	Principles

		Bounds Agnostic Algorithms

			-
				Algorithms which can operate on graphs without initial information regarding their
				size or structure can be called bounds agnostic algorithms.

				Bounds finding algorithms are necessarily bounds agnostic.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 2 - Theory: 1 - Utilities: 1 - Software: 1 - Data: 2 - Graphs: 1 - Conventions: 3 - Organization: 1 - Index Cluster'

Index Cluster

	Philosophy

		-
			An index cluster is a tree of the trace tags of elements in dynamic lists such that the
			tree branches within its tree bundle are trace paths for said elements.

			An index cluster may be specified using ONE.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 2 - Theory: 1 - Utilities: 1 - Software: 1 - Data: 2 - Graphs: 1 - Conventions: 3 - Organization: 2 - Index Map'

Index Map

	Philosophy

		-
			An index map is a function or key-value map which, for a given list, maps indices to
			other indices.

			Altering the properties of index maps may allow for novel sorting algorithms.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 2 - Theory: 1 - Utilities: 1 - Software: 1 - Data: 2 - Graphs: 2 - Forms: 1 - Lists: 1 - Ghost Lists'

Ghost Lists

	Philosophy

		-
			A ghost list is a bounds agnostic list which supports the random access of its elements
			via index.
		-

	Principles

		Algorithms

			The Ghost Skip Algorithm

				-
					The ghost skip algorithm is a bounds finding algorithm for computing the length
					of a ghost list in log n time.

					The algorithm itself is defined as follows, assuming indices begin at zero:

					First, the algorithm takes a list as an argument. Secondly, the algorithm sets
					a low counter to negative one and a high counter to one. Thirdly, while the
					high counter remains a valid index, the low counter is first set to the high
					counter, and the high counter is then doubled. Fourthly, while the difference
					of the high counter minus the low counter is greater than one, a middle counter
					is first set to the the difference of the high counter minus the low counter,
					divided over two and floored, plus the low counter, and if the middle counter
					is a valid index, the low counter is set to the middle counter, and otherwise
					the high counter is set to the middle counter. Finally, if the high counter is
					a valid index, the high counter plus one is returned, and otherwise the low
					counter plus one is returned.
				-

			The Ghost Search Algorithm

				-
					The ghost search algorithm is a bounds agnostic search algorithm for a sorted
					ghost list which runs in log n time.

					The algorithm itself is defined as follows, assuming indices begin at zero:

					First, the algorithm takes a list and a target as arguments. Secondly, the
					algorithm shall initiate as the ghost skip algorithm. However, if at any point
					the high counter should locate the target value, said counter shall be
					returned, and if at any point the high counter should locate a greater value
					than the target value, or the ghost skip algorithm should conclude, a binary
					search shall initiate from that point using the current high and low values.
				-

		Use Cases

			-
				Ghost lists, and related concepts, may, among other things, be useful when dealing
				with external systems over networks which may allow access of their contents but
				may not allow access to metadata regarding said contents.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 2 - Theory: 1 - Utilities: 1 - Software: 1 - Data: 2 - Graphs: 2 - Forms: 1 - Lists: 2 - Cluster List'

Cluster List

	Philosophy

		-
			A cluster list is a list encoded as an ordered map, allowing duplicate keys, where each
			value is mapped to a number denoting its quantity such that it may be interpreted as a
			contiguous list where each of said values constitutes a subsection of the interpreted
			list containing the respective quantities of said values.

			A set cluster list is a cluster list where there are no duplicate values in its map
			form.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 2 - Theory: 1 - Utilities: 1 - Software: 1 - Data: 2 - Graphs: 2 - Forms: 2 - Trees: 1 - Regressive Linked Tree'

Regressive Linked Tree

	Philosophy

		-
			A regressive linked tree is a type of graph where nodes may contain data and may point
			to an indefinite number of other nodes, where the content of each of the nodes pointed
			to represents a possible predecessor to the content of the node referencing them in a
			linear sequence, and where no loops are permitted in the connections.
		-

	Principles

		Regressive Linked Tree List

			-
				A regressive linked tree list is a list generated by tracing back from a given
				node, choosing a single previous node at each step, until reaching a node with no
				previous node, and then constructing a list of the contents of said nodes ordered
				from most recently traversed to least recently traversed.

				A string, called a regressive reconstruction, can be derived by concatenating
				string representations of each value in a regressive tree linked list together in
				order.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 2 - Theory: 1 - Utilities: 1 - Software: 1 - Data: 2 - Graphs: 2 - Forms: 2 - Trees: 2 - Tree Root Inversion'

Tree Root Inversion

	Philosophy

		-
			Tree root inversion is the process of rotating node connections on a given tree such
			that a given node becomes the root.
		-

	Principles

		Uses

			Element Analysis

				-
					Tree root inversion can be used to analyze a specific element in a tree-based
					document or DOM such that the surrounding content is taken into account.
				-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 2 - Theory: 1 - Utilities: 1 - Software: 1 - Data: 2 - Graphs: 2 - Forms: 2 - Trees: 3 - Global Tree Node Index'

Global Tree Node Index

	Philosophy

		-
			The global tree node index of a given node on a tree is the index of said node within a
			list generated by flattening the tree to which it belongs.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 2 - Theory: 1 - Utilities: 1 - Software: 1 - Data: 2 - Graphs: 2 - Forms: 2 - Trees: 4 - Double Link Derivation'

Double Link Derivation

	Philosophy

		-
			Double link derivation is the process of deriving the starting node of a one way
			connection in a graph from said connection's endpoint node.
		-

	Principles

		Applications

			-
				Double link derivation may be applied to hierarchical documents and data
				structures.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 2 - Theory: 1 - Utilities: 1 - Software: 1 - Data: 2 - Graphs: 2 - Forms: 2 - Trees: 5 - Full Branch'

Full Branch

	Philosophy

		-
			A full branch is a list derived from a tree by tracing a path from its root node to a
			given leaf node.
			
			Assuming the leaf nodes of a tree can be ordered, so can the full branches derived from
			said tree. The ordered or unordered set of full branches derivable from a given tree
			can be called its tree bundle.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 2 - Theory: 1 - Utilities: 1 - Software: 1 - Data: 2 - Graphs: 2 - Forms: 3 - Graphs: 1 - Absolute Graph'

Absolute Graph

	Philosophy

		-
			An absolute graph is a graph where all nodes are connected to all other nodes and to
			themselves.

			An absolute graph where all nodes are connected by singular bidirectional connections
			is called a single absolute graph, and an absolute graph where all nodes are connected
			by dual unidirectional connections is called a dual absolute graph.

			The number of nodes in an absolute graph is called its degree.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 2 - Theory: 1 - Utilities: 1 - Software: 1 - Data: 2 - Graphs: 2 - Forms: 3 - Graphs: 2 - Dueling Connections'

Dueling Connections

	Philosophy

		-
			Dueling connections are where nodes in a graph have more than one connection in the
			same direction.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 2 - Theory: 1 - Utilities: 1 - Software: 1 - Data: 2 - Graphs: 3 - Applications: 1 - State Graph'

State Graph

	Philosophy

		-
			A state graph is a directed acyclic graph where the nodes contain the historic states
			of a given system, and the connections specifying that the system transitioned from the
			state at their origin to the state at their end, as well as any additional metadata
			regarding the context of the transition.

			A complete state graph contains all of the historic states of the system it represents,
			whereas a partial state graph does not.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 2 - Theory: 1 - Utilities: 1 - Software: 2 - Algorithms: 1 - Interfaces: 1 - Little Code Solution'

Little Code Solution

	Philosophy

		-
			A little code solution is a software development platform that provides the ease of use
			provided by low-code and no-code platforms through plain text files alone.

			As such, the text file formats used by little code solutions should be easy to
			understand for non-technical audiences.
		-

	Principles

		Little Code Adapter

			-
				A little code adapter is a plain text file format designed to emulate the
				functionality of an existing low-code or no-code platform through a little code
				solution, such that applications written in either may be seamlessly converted from
				one format to the other.
			-

		Visual Map Principle

			-
				The visual map principle holds that any feature of an application which one may use
				via a GUI should also be usable through a text-based API.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 2 - Theory: 1 - Utilities: 1 - Software: 2 - Algorithms: 1 - Interfaces: 2 - Messaging Interface'

Messaging Interface

	Philosophy

		-
			A messaging interface is an API that allows an external entity to interface with a
			process via communications formed according to a codified protocol and sent according
			to a codified protocol over a messaging or communications service, such as email, SMS,
			or telephone.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 2 - Theory: 1 - Utilities: 1 - Software: 2 - Algorithms: 1 - Interfaces: 3 - General Script'

General Script

	Philosophy

		-
			A general script is a script in a simulation which is called on certain occasions, and
			which takes the form of a function that takes a data string as its one argument which
			specifies miscellaneous information, that has no access to any outer scope, and that
			returns a string specifying a query for actions to execute and for information to
			return in the data string the next time the script is called.
		-

	Principles

		Advantages

			-
				The use of general scripts allows scripts for an engine or simulation to be written
				in any language.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 2 - Theory: 1 - Utilities: 1 - Software: 2 - Algorithms: 2 - Architecture: 1 - Dependency Queue'

Dependency Queue

	Philosophy

		-
			A dependency queue is a queue of dependencies fulfilling the same function within a
			given system, such that if one dependency in said queue fails, the system may attempt
			to use the next dependency in said queue, with the first dependency in said queue being
			used first.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 2 - Theory: 1 - Utilities: 1 - Software: 2 - Algorithms: 2 - Architecture: 2 - Sub-Engine'

Sub-Engine

	Philosophy

		-
			A sub-engine is a toolset or framework designed to facilitate a specific task or
			process within a more generalized toolset or framework that the sub-engine is built on
			top of.

			As sub-engines may be built on other sub-engines, the depth at which a sub-engine is
			nested within a tree of an engine and its sub-engines, referred to as an engine tree,
			may be referred to as its order.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 2 - Theory: 1 - Utilities: 1 - Software: 2 - Algorithms: 3 - Application: 1 - Channel Workflows'

Channel Workflows

	Philosophy

		-
			A channel workflow is a codified protocol for governing the behavior of agenda driven
			real-time applications which work in unison and operate as intermediaries between
			various external applications via text based I/O channels.
		-

	Principles

		Application

			-
				Channel workflows can be used to manage the operations of distributed systems with
				AI components that function in a manner similar to an organization.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 2 - Theory: 1 - Utilities: 1 - Software: 2 - Algorithms: 3 - Application: 2 - Scene Stack'

Scene Stack

	Philosophy

		-
			A scene stack consists of stackable scenes, those being sub-applications of a container
			application which may pause execution to spawn a child stackable scene which shall take
			the former's place, and which shall return to a parent stackable scene when exiting, or
			shall cause the container application to terminate when exiting if no parent stackable
			scene is present, with a state object being passed between stackable scenes as they
			spawn and exit.

			Separate processes may alter the contents of a scene stack, and transition effects may
			be applied when switching between stackable scenes.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 2 - Theory: 1 - Utilities: 1 - Software: 2 - Algorithms: 4 - Security: 1 - Conventions: 1 - Common Trust Principle'

Common Trust Principle

	Philosophy

		-
			The common trust principle holds that the majority of end users are neither
			sufficiently malicious nor sufficiently technical to constitute a business threat
			should the most basic of precautions be taken to prevent abuse.
		-

	Principles

		Concern Threshold

			-
				The concern threshold is the extent to which the common trust principle can
				mitigate concern regarding the abuse of an end user product or service given the
				precautions taken against it.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 2 - Theory: 1 - Utilities: 1 - Software: 2 - Algorithms: 4 - Security: 1 - Conventions: 2 - Deflection Convention'

Deflection Convention

	Philosophy

		-
			A deflection convention is a codified method of presenting or using what is ostensibly
			a bug as a feature.

			A deflection convention that is only for presenting a bug as a feature is referred to
			as nominal, and as actual otherwise.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 2 - Theory: 1 - Utilities: 1 - Software: 2 - Algorithms: 4 - Security: 1 - Conventions: 2 - Deflection Convention: 1 - Honeytrap'

Honeytrap

	Philosophy

		-
			A honeytrap is an actual deflection convention where a known vulnerability is left in
			an application on purpose, with the intention that at least some malicious actors who
			take advantage of it may be caught, and prosecuted for profit.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 2 - Theory: 1 - Utilities: 1 - Software: 2 - Algorithms: 4 - Security: 1 - Conventions: 3 - Open Credentials'

Open Credentials

	Philosophy

		-
			Open credentials are access tokens for a given user which said user opts to make
			public, either directly, or indirectly via embedding them in the client side of their
			applications.
		-

	Principles

		Use Cases

			-
				Open credentials may be used on purely frontend applications where the consequences
				of exposing the relevant access tokens are sufficiently low, in that, generally
				speaking, they do not expose the user's personal information, open them to unknown
				or extreme levels of financial liability, or violate the policies of the policies
				of the services they access.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 2 - Theory: 1 - Utilities: 1 - Software: 2 - Algorithms: 4 - Security: 1 - Conventions: 4 - Split Encryption'

Split Encryption

	Philosophy

		-
			Split encryption refers to splitting an encrypted message into segments sent to
			different locations, and encoding the locations of other portions into the encrypted
			data, possibly with multiple routes, some being false leads.

			Split encryption may be useful in detecting unauthorized access attempts through
			unusual network activity.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 2 - Theory: 1 - Utilities: 1 - Software: 2 - Algorithms: 4 - Security: 2 - Verification Methods'

Verification Methods

	Philosophy

		-
			This document specifies methods for verifying user authenticity and details.
		-

	Principles

		Methods

			Automatic

				Authenticity

					Digital Checks

						Basic Information

							-
								A service with any non-zero concern threshold should require any
								prospective user to submit, at minimum, their first name, last
								name, and date of birth, plus an email address and a phone number.
							-

						Activity

							IP

								-
									User activity may be tracked by IP address, which may be used
									to verify suspicious patterns of behavior.
								-

							Anti-Spam Measures

								-
									User activity may be monitored via third party services, with
									suspicious users being blocked automatically, or with them
									being forced to demonstrate that they are not bots.
								-

						Accounts

							Account Confirmation

								-
									When signing up, a user may be asked to submit an email address
									and a phone number, which may each be verified by asking the
									user to respond in some way to a prompt sent by the service
									they are subscribing to.
								-

							Account Exclusivity

								-
									To prevent more than one account per user, no phone number or
									email address should be allowed to be used more than once
									across the platform.
								-

							Personal Phone Confirmation

								-
									Phone numbers may be looked up and classed into certain types,
									and users should only be permitted to use numbers that can
									reasonably be assumed to be for personal use.
								-

					ID Submissions

						Retention and Verification

							-
								Users may submit 3rd party records which affirm their identity.

								A platform may merely retain said records and verify them if a
								conflict emerges or if suspicion is raised, or may verify them by
								default before granting a user access. Verification, however, tends
								to be a difficult and expensive process.

								Regardless, the psychological aspects of submitting an ID may deter
								users from attempting to defraud the service whether or not all IDs
								are verified.
							-

						Formats

							Public

								SSN

									-
										One's Social Security Number (SSN) is one method by which
										a user may affirm their identity.
									-

								Photo ID

									-
										Submission of a scan of a government issued photo ID, such
										as a driver's license or passport, is one method by which a
										user may affirm their identity.
									-

							Third Party
								
								Background Checks

									-
										Submission of the documentation of a 3rd party background
										check, such as a credit check, is one method by which a
										user may affirm their identity.
									-

								Personhood Registries

									Rationale

										-
											Many existing services perform extensive background
											checks on users before allowing them onto their
											platform, thus, a new service may confirm a user's
											authenticity by confirming that they are registered
											with such an existing service.

											A service that performs such checks and limits users to
											one account each is called a personhood registry. A
											personhood registry that is free to sign up for is
											called an open personhood registry, and one that is not
											free to sign up for is called a closed personhood
											registry.
										-

									Methods

										Email

											-
												One method to confirm registration with an external
												service is to have the user forward an email from
												them.

												Said email may need to contain some reference to
												the user's identity, and should be verified via
												checking the headers of the forwarded message.
											-

										Link

											-
												One method to confirm registration with an external
												service is to have the user link an account they
												have with said existing service to the new service.
											-

										Personhood Reference

											Personhood Library

												-
													One method to confirm registration with an
													external service is, if said service openly
													publishes subscriber information, to have the
													user reference their information, and
													preferably to confirm it via a private key.
												-

											Personhood Authenticator

												-
													One method to confirm registration with an
													external service is to use said service as a
													single sign on method.
												-

				Details

					Location

						-
							A user's location may be identified via geolocation.

							While this may be spoofed, the average user is unlikely to be capable
							of doing so, whereas it would be fairly easy if all they had to do was
							enter it manually.
							
							To discourage attempts at spoofing the platform may limit how many
							times one's location may be changed within a certain time frame.
						-

			Manual

				Contact

					Collisons

						-
							If suspicious patterns are detected due to overlaps in user
							information, called user collisions, the service may reach out to the
							users whose information conflicts and verify their identities and
							intentions manually.
						-

					Confusion

						-
							A hotline may be established for legitimate users who have difficulty
							signing up due to the platform raising false alarms.
						-

		Tools

			Utilities

				Anti-Spam Measures: Captcha, Cloudflare

				Phone Number Lookup: 'https://github.com/google/libphonenumber'

			Third Party Services

				Email: Robinhood, Coinbase, Banks
				Link: Plaid

				Personhood References
				
					Coinbase - Verified Users Only: Type: Authenticator
					Kleros - Proof of Humanity: Type: Library
					World ID: Type: Authenticator

		Conventions

			Notes

				Flexibility

					-
						A service may choose to allow prospective users to verify their identity in
						multiple ways.

						Furthermore, a service should have a protocol in place if they update their
						verification policy and thus require users to reverify themselves.
					-

				Third Party Requests

					-
						If a 3rd party service does not offer any method through which a new
						service may verify one of said 3rd party service's existing users, the new
						service may reach out to the existing service and request that they
						implement such functionality.

						One way of convincing them to do this may be to agree only to use said
						existing service for this purpose, thus requiring prospective users of the
						new platform to also subscribe to the existing platform.
					-

				Warnings

					-
						To deter attempts at fraud, a service may place warnings when signing up
						that attempts to defraud the platform may result in prosecution.

						This should only be used for platforms with very high concern thresholds,
						such as financial services.
					-

			Standard Method

				Base

					Internal

						-
							The internal base standard method of user verification is to require
							the user, in addition to submitting their basic information, to
							validate their email address and their phone number, to validate that
							said phone number is most likely a personal phone number, and to
							enforce a policy of account exclusivity for email addresses and phone
							numbers, as well as SSNs, if applicable.
						-

					External

						-
							The external base standard method of user verification is to require
							users to log in through one specific open personhood authenticator.
						-

				Levels

					Level 2

						-
							The level 2 standard method expands upon the base standard method, and
							under it, anti-spam measures shall be in place, and if the service uses
							geolocation to verify user location, redefining one's location shall,
							by default, be limited to once per year.
						-

					Level 3

						-
							The level 3 standard method expands upon the level 2 internal standard
							method, and under it, the SSN of the user shall be collected and
							retained, but not verified unless necessary.
						-

					Level 4

						-
							The level 4 standard method expands upon the level 3 standard method,
							and under it, a prosecution warning shall be displayed on the sign-up
							form, and a contact service shall be established for dealing with
							errors in user submissions and with suspicious activity.
						-

				Default

					-
						The level 2 external standard method of user verification is the default
						form of the standard method of user verification.

						As such, said method may be abbreviated as DSMUV.
					-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 2 - Theory: 1 - Utilities: 1 - Software: 2 - Algorithms: 5 - Fields: 1 - Bioinformatics: 1 - Bioequivalent Simulation'

Bioequivalent Simulation

	Philosophy

		-
			A bioequivalent simulation (BES) is a virtual simulation of an organic system.

			A bioequivalent simulation may be assigned a numerical degree indicating the extent to
			which it simulates its subject, from a high level abstraction to a full biochemical
			simulation.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 2 - Theory: 1 - Utilities: 1 - Software: 2 - Algorithms: 5 - Fields: 2 - AI: 1 - Conventions: 1 - AI Agency'

AI Agency

	Philosophy

		-
			AI agency is the ability of an artificially intelligent entity to initiate interactions
			with external entities.
		-

	Principles

		Turing Test

			-
				During the Turing test, one should watch for the presence of AI agency, treating it
				as a success criterion.
			-

		Techniques

			Bot Feedback Loops

				-
					A crude way to achieve a degree of AI agency is to engage multiple bots in a
					feedback loop with each other, and assign an additional monitor process to
					derive actionable commands from the resulting conversation.
				-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 2 - Theory: 1 - Utilities: 1 - Software: 2 - Algorithms: 5 - Fields: 2 - AI: 1 - Conventions: 1 - AI Agency: 1 - Imagination'

Artificial Imagination

	Philosophy

		-
			An artificial imagination is a simulation that exists within an artificially
			intelligent application that allows it to simulate performing certain actions and to
			observe its own predictions about the effects of said actions.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 2 - Theory: 1 - Utilities: 1 - Software: 2 - Algorithms: 5 - Fields: 2 - AI: 1 - Conventions: 1 - AI Agency: 2 - Intelligence Trap'

Intelligence Trap

	Philosophy

		-
			An intelligence trap is an exploit of a flaw in the anatomy or environment of an
			intelligent system that allows it to obtain high amounts of positive feedback without
			doing what it is intended to do.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 2 - Theory: 1 - Utilities: 1 - Software: 2 - Algorithms: 5 - Fields: 2 - AI: 1 - Conventions: 2 - Functional AGI'

Functional AGI

	Philosophy

		-
			A functional AGI is an AI system that, whether or not it measures up to the standards
			of a proper AGI, works well enough to act in place of one in some circumstances, the
			extent to which it can do this being called its functionality degree.
		-

	Principles

		True AGI Prerequisites

			-
				A true AGI must be capable of indefinite cycles of reflective thought, which would
				tend to manifest with reflective pauses and backpedaling.
				
				Furthermore, a true AGI should be able to process many contexts simultaneously,
				where said contexts constantly and asynchronously feedback upon themselves, should
				be able to dynamically adapt to novel contexts, and should exhibit agency.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 2 - Theory: 1 - Utilities: 1 - Software: 2 - Algorithms: 5 - Fields: 2 - AI: 1 - Conventions: 2 - Functional AGI: 1 - Turing Test'

Turing Test Subversion

	Philosophy

		-
			When performing the Turing test on an artificial intelligence, one should routinely try
			to derail the interaction with nonsensical tangents and outbursts to see whether the AI
			seems aware of the absurdity of the diversions.
		-

	Principles

		Void Answer Fallacy

			-
				One flaw in many current generation AI systems is that by nature they must provide
				a response to a prompt, and thus will sooner give a wrong answer than no answer.
				
				This flaw can be exploited by forcing a conversation to continue past the point
				where it should otherwise stop, revealing the system's lack of true understanding
				and allowing the user to subvert protocols in the system's training.

				Furthermore, many AI systems can be vulnerable to what can be termed "discourse
				hypnosis", where the user makes comments in the course of a conversation which
				presuppose some previously unstated information, leading to the AI to uncritically
				integrate said assumptions into its responses as the conversation progresses.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 2 - Theory: 1 - Utilities: 1 - Software: 2 - Algorithms: 5 - Fields: 2 - AI: 1 - Conventions: 3 - Soft Programming'

Soft Programming

	Philosophy

		-
			Soft programming is the use of AI in place of hardcoded functions within programs.

			Reflective soft programming is where soft programming is used to generate code that the
			program then executes.

			A soft programming algorithm is an algorithm specifically designed for soft
			programming.
		-

	Principles

		Prompt Protocols

			-
				Prompt protocols are codified conventions for how to phrase questions posed to
				intelligent systems in order to receive a specific sort of response.

				Reflective soft programming may be used to derive prompts for steps to further the
				goals posed by a previous prompt. Said prompts are referred to as reflective
				prompts.

				Soft programming algorithms consist of hierarchical prompt protocols consisting of
				initial prompts and reflective prompts. Initial prompts that are hardcoded are
				referred to as seed prompts, and initial prompts that are provided by a user are
				referred to as request prompts. In a soft programming algorithm with a single
				initial prompt, said prompt is referred to as the master prompt.

				Prompt protocols for deriving structured data from unstructured text, and for
				converting structured data to unstructured text, are referred to as a structure
				protocol, which themselves may be considered a type of prompt protocol.

				Codified collections of prompt protocols are referred to as prompt libraries.

				A prompt protocol for initiating the automation of tasks of indefinite scope is
				referred to as an omni-protocol.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 2 - Theory: 1 - Utilities: 1 - Software: 2 - Algorithms: 5 - Fields: 2 - AI: 1 - Conventions: 3 - Soft Programming: 1 - Soft Rules'

Soft Rules

	Philosophy

		-
			Soft rules are codified conventions for the behavior of an autonomous system that
			cannot be hardwired into its behavior and so must be implemented via conditioning.
		-

	Principles

		Soft Creed

			-
				A soft creed is a codified set of soft rules.
			-

		Soft Enforcer

			-
				A soft enforcer is a system that acts to enforce soft rules upon another.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 2 - Theory: 1 - Utilities: 1 - Software: 2 - Algorithms: 5 - Fields: 2 - AI: 1 - Conventions: 4 - Bioequivalent AI'

Bioequivalent AI

	Philosophy

		-
			A bioequivalent AI (BEAI) is a BES-based AI system modelled after biological
			intelligent systems.

			A software model that fully simulates a connectome as a cognitive agent is referred to
			as a neural model simulation (NMS). An NMS that can be generated from a digital
			representation of genetic code is called a genetic NMS (GNMS).

			A hardware system that recreates the parallel and dynamic nature of neurons at the
			hardware level without itself being wetware is referred to as a neuroequivalent
			electrical substrate (NEES).

			Both an NMS and a NEES may be assigned a degree indicating the extent to which they
			recreate the processes of the biological systems they are modelled after.
		-

	Principles

		HNMS

			-
				An NMS that fully models a human brain is called a Human NMS (HNMS).

				An HNMS that is also a GNMS is called an HGNMS.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 2 - Theory: 1 - Utilities: 1 - Software: 2 - Algorithms: 5 - Fields: 2 - AI: 1 - Conventions: 5 - Corrective AI'

Corrective AI

	Philosophy

		-
			Corrective AI is the use of AI models to correct the output of other AI models or human
			work.
			
			This may enable multiple highly specialized models to be trained independently of each
			other and of more general purpose models, such that they may supplement each other
			without requiring any of them to be retrained.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 2 - Theory: 1 - Utilities: 1 - Software: 2 - Algorithms: 5 - Fields: 2 - AI: 1 - Conventions: 6 - Source Cognizant AI'

Source Cognizant AI

	Philosophy

		-
			Source cognizant AI refers to AI systems capable of identifying which elements of their
			training data they drew on to produce a given output, how so, and to what extent.
		-

	Principles

		Uses

			-
				Source cognizant AI may be used in generative systems to assist in crediting and
				compensating the human creators they derived from.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 2 - Theory: 1 - Utilities: 1 - Software: 2 - Algorithms: 5 - Fields: 2 - AI: 2 - Applications: 1 - AI Rendering'

AI Rendering

	Philosophy

		-
			AI Rendering is the act of rendering scene geometry through a machine learning model
			either instead of through a graphics processor or before or after running it through a
			graphics processor.
		-

	Principles

		Prudent Rendering

			-
				Prudent rendering is a process where a renderer for a pre-rendered scene determines
				which sets of frames repeat exactly or can be derived from a single frame and thus
				avoids rendering certain frames unnecessarily.
			-

		Prudent Playback

			-
				Prudent playback is when frames that repeat exactly in a sequence are stored only
				once, and the playback sequence itself is stored as a sequence of references to
				said frames.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 2 - Theory: 1 - Utilities: 1 - Software: 2 - Algorithms: 5 - Fields: 2 - AI: 2 - Applications: 1 - AI Rendering: 1 - Generative DOM'

Generative DOM

	Philosophy

		-
			Generative DOM, or G-DOM, is a convention for applying AI to the processing and
			rendering of a DOM driven simulation.
		-

	Principles

		Generative Components

			-
				A generative component is a component within a DOM that contains a text description
				of some aspect of the simulation, and which may also contain references to
				pre-rendered renderings of said aspect.

				They may be placed in the DOM manually by developers, or automatically placed by
				automatic generative processes.

				A non-generative component may be referred to as a basic component.
			-

		Processing

			-
				When processing the simulation to its next state, or rendering the simulation, the
				non-generative elements of the DOM shall be processed first, and the generative
				elements shall be processed afterwards.
			-

		Resolution

			-
				Resolution of a G-DOM may refer to basic resolution, where all generative
				components are converted to basic components, to generative resolution, where basic
				components are converted to generative components, or to composite resolution,
				where multiple generative components are converted to a single generative
				component.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 2 - Theory: 1 - Utilities: 2 - Hardware: 1 - Virtual Hardware'

Virtual Hardware

	Philosophy

		-
			Virtual hardware is a simulation of a given physical machine that software may interact
			with in the same manner that it would the real equivalent.
			
			Among other things, this would allow one to conserve the resources needed to build said
			machine at least until said resources are available and the concept has been
			sufficiently proven.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 2 - Theory: 1 - Utilities: 2 - Hardware: 2 - Time Based Random Numbers'

Time Based Random Numbers

	Philosophy

		-
			If a machine lacks specialized circuitry for generating hardware random numbers, then
			random numbers generated by using the time as specified by the machine's clock as a
			seed can be used as a substitute.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 2 - Theory: 2 - Schools: 1 - Dynamic: 1 - Dynamic Bits'

Dynamic Bit

	Philosophy

		-
			A dynamic bit is a value that can be used as a bit in a virtual circuit.

			Dynamic bits may be of any type, and can be interpreted, either alone or in groups, to
			either produce a new value of any type or to produce a boolean value. Any operation
			used to do this must do so deterministically.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 2 - Theory: 2 - Schools: 1 - Dynamic: 1 - Dynamic Bits: 1 - Standard Dynamic Bit'

Standard Dynamic Bit

	Philosophy

		-
			A standard dynamic bit is a list of numbers between zero and one, inclusive, where zero
			represents a false value and one represents a true value. Said list must have at least
			one element.

			By default, the length of said list is one.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 2 - Theory: 2 - Schools: 1 - Dynamic: 1 - Dynamic Bits: 2 - Gateway Philosopher~'s Medium'

Gateway Philosopher~'s Medium
	
	Philosophy
	
		-
			A module that abides by the gateway Philosopher's Medium shall contain a function
			referred to as the gateway function that shall take a dynamic bit and deterministically
			return a new value based on the passed in value, as well as a function referred to as
			the reduce function that shall take a dynamic bit and deterministically return a
			boolean value based on the passed in value.

			A module that abides by the gateway Philosopher's Medium shall be known as a gateway
			Philosopher's Stone module.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 2 - Theory: 2 - Schools: 1 - Dynamic: 2 - Dynamic Lists'

Dynamic List

	Philosophy

		-
			A dynamic list is a list in which each index may have string aliases.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 2 - Theory: 2 - Schools: 1 - Dynamic: 2 - Dynamic Lists: 1 - Conventions'

Dynamic List Conventions

	Philosophy

		-
			This document specifies conventions regarding dynamic lists.
		-

	Principles

		Conventions

			Trace

				-
					List elements may function as tag trace modules, with their field aliases, if
					applicable, their stringified forms, and their indices functioning as trace
					tags, and, if they are themselves lists, with their sub-elements functioning as
					their connections.
				-

			ONE

				-
					Any ONE element may represent a dynamic list, where its children represent the
					elements of the list, elements with no children representing literals, their
					content being the values thereof, and elements with children representing
					fields, their content being the values thereof and their children being the
					content thereof.
				-

			DLF

				-
					The dynamic list format is a standard for encoding a dynamic list as a non
					dynamic list, where every odd numbered item is an element alias, and every even
					numbered item is a list element assigned to the alias immediately preceding it.
				-

		DLN

			Format

				-
					Dynamic list notation (DLN) is a method for encoding the contents of dynamic
					lists.

					A list in DLN begins with an open bracket and ends with a closed bracket. By
					default, said brackets are square brackets.

					The elements in the list shall be written in order between said brackets as
					literals, separated by commas. If an element has an alias, said alias shall
					immediately precede said element, separated from it by a colon.
				-

			Conventions

				JSON

					-
						DLN may use JSON conventions to escape literal content and denote specific
						primitive types.
					-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 2 - Theory: 2 - Schools: 1 - Dynamic: 3 - Dynamic Web'

Dynamic Web

	Philosophy

		-
			The dynamic web is the set of websites that can be dynamically constructed from
			statically accessible assets on the internet.
		-

	Principles

		Resource Encoding

			-
				Resource encoding is the process of encoding the source for a given resource in a
				different type of file that would normally be used in order to bypass obstacles
				that would otherwise hinder its use.

				One type of resource encoding, called CORS bypass encoding, is to encode text in an
				audio or visual resource and to then extract said text from said resource in order
				to bypass CORS restrictions without using a CORS proxy. One of the simplest ways to
				do this, which can be called bitmap bypassing, would be to use the RGB values in a
				bitmap to encode the source text.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 2 - Theory: 2 - Schools: 2 - Common: 1 - Common Convention'

Common Convention

	Philosophy

		-
			A common convention is a convention for multiple technologies which, if followed, allow
			each of said technologies to operate seamlessly together.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 2 - Theory: 2 - Schools: 2 - Common: 2 - Common Structures: 1 - Common Object'

Common Object

	Philosophy

		-
			A common object is a specification for the data structure needed to represent a given
			type of object, such that it may be implemented in different languages and
			environments.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 2 - Theory: 2 - Schools: 2 - Common: 2 - Common Structures: 1 - Common Object: 1 - Common Document'

Common Document

	Philosophy

		-
			A common document is a specification for the data structure needed to represent a given
			type of document, such that it may be implemented in different languages and
			environments.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 2 - Theory: 2 - Schools: 2 - Common: 2 - Common Structures: 2 - Common Framework'

Common Framework

	Philosophy

		-
			A common framework is a framework that provides an interface for constructing an
			application such that the application may be recreated in other frameworks.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 2 - Theory: 2 - Schools: 2 - Common: 2 - Common Structures: 3 - Common ID'

Common ID

	Philosophy

		-
			The common ID conventions specify rules for applying tags to virtual objects such that
			they may be identified within it.

			Under the common ID conventions, any object may have an indefinite number of string
			tags, which shall be insensitive to letter case and to whitespace.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 2 - Theory: 2 - Schools: 2 - Common: 3 - Common Module'

Common Module

	Philosophy

		-
			A common module is a specification for the interface to a utility or application such
			that said interface shall remain consistent across various implementations and
			deployments of said module.
		-

	Principles

		Common Module Hub

			-
				A common module hub is a unified means of accessing implementations of a common
				module such that the appropriate implementation shall be utilized or installed for
				the application or platform accessing said hub.
			-

		Common Module API

			-
				A common module API, or CM API for short, is a web API that implements the
				functionality of a common module such that a function within it and the arguments
				for the parameters thereof may be specified in the URL and body of a request made
				to it, with the value returned by said function given said arguments returned as a
				string in the body of the resulting response.

				A universal common module API, or UCM API for short, is a common module API that
				simultaneously hosts multiple common modules, and shall thus take the name of a
				given module hosted by it in addition to the name of a function within said module
				and the arguments for said function's parameters within the URL of a call made to
				it.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 2 - Theory: 2 - Schools: 3 - Modules: 1 - Types: 1 - Shadow Module'

Shadow Module

	Philosophy

		-
			A shadow module is a module that is attached to a pre-existing module referred to as
			the host module.

			A shadow module will dynamically modify its host module at runtime. A unit of code that
			is inserted into a host module to act as an interface to a shadow module is called a
			shadow point.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 2 - Theory: 2 - Schools: 3 - Modules: 1 - Types: 2 - Ghost Module'

Ghost Module

	Philosophy

		-
			A ghost module is a module with functioning endpoints but incomplete implementation.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 2 - Theory: 2 - Schools: 3 - Modules: 1 - Types: 3 - Portal Module'

Portal Module

	Philosophy

		-
			A portal module is a module in which the state shall be modified to represent the state
			of another module, and may alter the state of the module it represents if its own state
			is modified.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 2 - Theory: 2 - Schools: 3 - Modules: 1 - Types: 3 - Portal Module: 1 - ACE Portal'

ACE Portal

	Philosophy

		-
			An ACE Portal is a module that serves as a portal module to all or part of an ACE
			document.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 2 - Theory: 2 - Schools: 3 - Modules: 2 - Module Solution'

Module Solution

	Philosophy

		-
			A module solution, or MS for short, is a given configuration of pre-fabricated hardware
			components, software components, or both, designed to fulfill a given need.
		-

	Principles

		Concepts

			Module Solution Set

				-
					A module solution set, or MSS for short, is a defined set of module solutions.
				-

			Module Solution Application

				-
					A module solution application, or MSA for short, is a defined method of
					utilizing module solutions to accomplish a given task.
				-

			Module Solution Class

				-
					A module solution class, or MSC for short, is a defined category of module
					solutions and concepts predicated upon module solutions.

					Module solution classes may be nested within one another, and may be granted
					numerical orders from a given class down.
				-

		Labelling

			-
				Any given MS, MSS, MSA, or MSC shall have a unique name, and iterations upon their
				design shall be labelled numerically, where said number is referred to as the mark.

				Any individual implementation of an MS or any related item shall be labelled using
				a serial number.

				Any MS or any related item, or any individual implementation thereof may optionally
				have codenames.

				The full title of an MS or any related item shall consist of any MSC it belongs to,
				arranged in order, followed by its name, followed by its mark, and if applicable,
				followed by its serial number. which itself shall be followed by its nickname if it
				has one.

				The standard rendering of the mark number shall have it as a Roman numeral preceded
				by the word "Mark".

				The standard rendering of the serial number shall have it separated from the mark
				by a hyphen.

				A codename for any such title may follow said title, from which it shall be
				separated by a hyphen, and any such title may be wholly or partially abbreviated by
				codenames where applicable.

				Each separate word, number, or punctuation mark should be separated from the
				preceding and following elements by a single space.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 1 - Data: 1 - Theory: 1 - Principles: 1 - Encoding: 1 - Binary: 1 - Dynamic Binary Headers'

Dynamic Binary Headers

	Philosophy

		-
			Dynamic binary headers allow metadata in binary files to be specified using a standard
			that can scale to varying lengths.
		-

	Principles

		Structure

			-
				Dynamic binary headers shall occur at the beginning of a binary file, and their
				content, which itself shall be in trinary, shall be specified using "11" to
				represent "2", "10" to represent "1", and "01" to represent "0", and shall end with
				"00".

				Following a header may be another header, the main content of the file, or the end
				of the file. No more headers may be placed into the file following the beginning of
				the main content.
			-

		Count Header

			-
				A count header, which if present must be the first header in the file, shall
				specify, as a trinary number, the number of headers present in the file, not
				counting itself.
			-

		Sequence Headers

			-
				If a count header is present, the headers that follow it may be sequence headers,
				each of which specify, as a trinary number, the length of a sequence of bits in the
				main content.

				The sequences defined by the sequence headers shall start at the beginning of the
				main content and shall be adjacent to one another, ordered according to the order
				of their corresponding headers.
				
				Any bits that follow the last sequence in the main content may be used for another
				purpose, if it is not junk data, and in the case of it being junk data said bits
				should be zero.
			-

		Sequence Objects

			-
				A binary file separated into sequences using sequence headers may itself be
				separated into sequences called sub-sequences using sequence headers.

				Sub-sequences may be used as references to the sibling sequences of their parent.

				If being used this way, each subsequence should have a header defining itself as
				either a reference or as raw data. The header for a reference should be "0100", and
				the header for raw data should be "1000".

				The content following a reference header should be a binary number specifying the
				index of the sibling sequence being referenced, starting at zero, and the content
				following a raw data header should be raw data in binary.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 1 - Data: 1 - Theory: 1 - Principles: 1 - Encoding: 1 - Binary: 2 - Multistate Sequence'

Multistate Binary Sequence

	Philosophy
	
		-
			A multistate binary sequence is a sequence of bit sequences, referred to as state
			sequences, each of which is just long enough to encode a given maximum number, defined
			as the order of the multistate binary sequence.

			Each state sequence shall specify in binary a number between zero and the order number,
			inclusive.
		-

	Principles

		Order Header

			-
				A multistate binary sequence may be preceded by a dynamic binary header specifying
				the order of said sequence in trinary.

				Such a sequence with such a header shall be referred to as an ordered multistate
				binary sequence.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 1 - Data: 1 - Theory: 1 - Principles: 1 - Encoding: 1 - Binary: 3 - List Binary'

List Binary

	Philosophy

		-
			List binary is a binary format for representing multidimensional lists of numbers.
		-

	Principles

		Structure

			-
				An element in list binary shall use sequence headers to separate its content into
				chunks, using the element binary format.

				The first chunk shall be a header specifying the type of element as a single
				binary digit, two being a list which contains other lists, one being a list
				containing only numbers, and zero a single number.

				For a type two, every subsequent chunk shall represent an element of the list in
				element binary.

				For a type one or zero, there shall only be one subsequent chunk. For a type one,
				the content of the chunk shall be an ordered multistate binary sequence. For a type
				zero, it shall contain binary representing the number it contains.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 1 - Data: 1 - Theory: 1 - Principles: 1 - Encoding: 2 - Syntax: 1 - Monovalid Language'

Monovalid Language

	Philosophy

		-
			A monovalid language is a language in which, for any given content, there is only one
			way to serialize it.

			A language that is not monovalid is called a multivalid language.
		-

	Principles

		Input-Output Alignment Validity Test

			-
				In a monovalid language, when input is deserialized and then immediately
				reserialized, the output should be exactly the same as the input.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 1 - Data: 1 - Theory: 1 - Principles: 1 - Encoding: 2 - Syntax: 10 - Notation Conventions'

Notation Conventions

	Philosophy

		-
			Ideally, any system of notation should, in either its standard form or a variant
			thereof, be renderable in plain text using the character set common to keyboards in the
			region of its target audience, and in such a way that it is easily parsed by both human
			readers and digital parsers.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 1 - Data: 1 - Theory: 1 - Principles: 1 - Encoding: 2 - Syntax: 2 - Esoteric Document Map'

Esoteric Document Map

	Philosophy

		-
			An esoteric document map is a convention that allows a document serialized in a
			specific format to be derived from a source which is not in said format.

			A document intentionally serialized in a manner consistent with an esoteric document
			map can be called an esoteric document.
		-

	Principles

		Visual to Plain Text

			-
				A visual which contains legible text may be transcripted to a plain text file where
				distinct contiguous sequences of characters in said visual are transcribed to lines
				in said file and arranged in order of their location in the visual, which by
				default shall be from left to right and from top to bottom.
			-

		Unstructured ONE to Kaeon Document

			-
				An unstructured ONE document may be converted to a Kaeon document by taking the
				content of the first child of the root and making it the content of the title
				element, and by taking the content of the second child of the root and making it
				the content of the Philosophy section.

				Once this has been done, any children of the first and second children of the root
				shall be added in order to the Kaeon document as children of the Principles
				section, and any remaining children of the root in the original document shall be
				added in order to the Principles section afterward.

				In an alternate approach however, all children of the root of the original document
				may be added in order to the Principles section of the Kaeon document.

				If there is only one child of the root in the original document, the title element
				and the Philosophy section of the Kaeon document shall both have the content of the
				sole child, and if the original document is empty, the title element and the
				Philosophy section shall have empty strings as content.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 1 - Data: 1 - Theory: 1 - Principles: 1 - Encoding: 2 - Syntax: 3 - Significant Comments'

Significant Comments

	Philosophy

		-
			Significant comments refers to any case where the content of comments in a given
			language is held to be directly or indirectly significant to a preprocessor,
			interpreter, or compiler.
		-

	Principles

		Pseudocomments

			-
				Pseudocomments are sections of code which have no effect on the execution of a
				program or the interpretation of data, but which are not cropped out by the parser.
			-

		Comment Documents

			-
				The collective set of commented text in a given document may be referred to as the
				comment document of said document.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 1 - Data: 1 - Theory: 1 - Principles: 1 - Encoding: 2 - Syntax: 4 - Polyglot Sequence'

Polyglot Sequence

	Philosophy

		-
			A polyglot sequence is a string that constitutes valid code in more than one language.

			For a given set of languages, a polyglot sequence that operates the same way in each of
			said languages is referred to as convergent, and one that does not is referred to as
			divergent.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 1 - Data: 1 - Theory: 1 - Principles: 1 - Encoding: 2 - Syntax: 5 - Column-Based Wrapping'

Column-Based Wrapping

	Philosophy

		-
			Column-Based wrapping is the practice of wrapping lines of text according to how many
			columns said lines occupy rather than how many characters are in said lines.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 1 - Data: 1 - Theory: 1 - Principles: 1 - Encoding: 2 - Syntax: 6 - String Inclination'

String Inclination

	Philosophy

		-
			The inclination of a given string refers to the properties that can be implicitly
			inferred from its content to apply to it.

			These include the natural and constructed languages to which it may belong, called the
			language inclination.
		-

	Principles

		Alignment Inclination

			-
				The alignment inclination of a given string refers to whether the first character
				of a string which is not punctuation or whitespace hails from a script that reads
				left to right, rendering the inclination of said string as left, or from a script
				that reads right to left, rendering said the inclination of said string as right.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 1 - Data: 1 - Theory: 1 - Principles: 1 - Encoding: 2 - Syntax: 7 - Readability Levels'

Readability Levels

	Philosophy

		-
			The readability level of a file format is level 1 ("render-only") if the raw content of
			the file cannot be as plain text, level 2 ("render-favored") if the raw content of
			the file is readable as plain text but lacking in some fundamental way relative to a
			rendering of said file, and level 3 ("render-optional") is the file is readable as
			plain text and is not lacking in any way relative to a rendering of said file.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 1 - Data: 1 - Theory: 1 - Principles: 1 - Encoding: 2 - Syntax: 8 - Usage Tier Scaling'

Usage Tier Scaling

	Philosophy

		-
			Usage tiers are codified subsets of features provided within a suite of tools.

			Usage tier scaling is when a system which hosts said suite optimizes its performance
			according to which usage tiers are in use.
		-

	Principles

		Compiler Scaling

			-
				Compiler scaling is when code is compiled under different compilers according to
				the syntactic features in use by the source being compiled.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 1 - Data: 1 - Theory: 1 - Principles: 1 - Encoding: 2 - Syntax: 9 - Soft Language'

Soft Language

	Philosophy

		-
			A soft language is a programming or data interchange language with imprecise rules,
			requiring any parser to take liberty with its interpretation through AI.
			
			Any language which is not soft may be called hard.
		-

	Principles

		Abridged Language

			-
				An abridged language is a soft language based on an existing hard language.

				A codified abridged language is called an abridged standard.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 1 - Data: 1 - Theory: 1 - Principles: 1 - Encoding: 2 - Syntax: 9 - Soft Language: 1 - SAO+'

SAO+

	Philosophy

		-
			Standard abridged ONE+ (SAO+) is an abridged standard for ONE+, which waives the
			distinction between types of brackets and quotes, and the necessity of the presence of
			tokens if the structure of the content is sufficiently obvious.

			SAO+, in the form of SAO++, may be used with abridged versions of the universal
			preprocessor, and with abridged versions of Kaeon FUSION which waives the need to
			import interfaces and which waives the need to use certain commands if the behavior of
			the content is sufficiently obvious.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 1 - Data: 1 - Theory: 1 - Principles: 1 - Encoding: 3 - Structured: 1 - Category Structures'

Category Structures

	Philosophy

		-
			Category structures are data structures consisting of elements which may only fall into
			a finite number of types, where all elements of a given type are identical.

			The possible categories for a given category structure are referred to as its category
			set.
		-

	Principles

		Labels

			-
				Categories in category structures may each be assigned unique titles and indices,
				and may be identified by their indices or by any substring of their titles which
				uniquely identify them among their category set, letter case being irrelevant.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 1 - Data: 1 - Theory: 1 - Principles: 1 - Encoding: 3 - Structured: 2 - Lists: 1 - Normalization'

List Normalization

	Philosophy

		-
			List normalization is the conversion of any data structure or model to a list of
			primitives with an indefinite number of dimensions.

			A single primitive may be converted into a list by encasing it in a list where it is
			the only element.
		-

	Principles

		Formats

			JSON

				-
					A JSON object may be normalized into a list by adding all of its values in
					order to a list and removing its keys.

					A non-primitive JSON construct may be fully normalized into a list by
					normalizing all objects nested within it.
				-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 1 - Data: 1 - Theory: 1 - Principles: 2 - Databases: 1 - ONE Database'

ONE Database

	Philosophy

		-
			A ONE database is a database that stores data in a ONE document structure.
		-

	Principles

		Relational Database Implementation

			-
				A ONE database can be emulated using a single relational database table wherein
				every record represents an element, and where each record has five columns.

				The ID column, of type integer serial, specifies a unique ID for each element,
				where said ID is greater than one, and serves as the identifying column.

				The content column, of type string or text, specifies the string content of each
				element.

				The parent column, of type integer, specifies the ID of each element's parent
				element, and if the element has no parent, it shall contain zero.

				The index column, of type integer, specifies the index of each element parent among
				its parent's children starting at one, and if the element has no parent, it shall
				contain zero.

				The metadata column, of type string or text, specifies additional metadata
				regarding each element.

				Additionally, the database may be set up such that the data is spread across
				multiple tables, in which case information about the relationships between said
				tables shall be encoded within the content of the metadata column, and a single
				table within the database shall serve as the root or master table.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 1 - Data: 1 - Theory: 1 - Principles: 2 - Databases: 2 - Common Database API'

Common Database API

	Philosophy

		-
			The common database API is a standard for the parameters of a function that can take
			and process any request for any type of database.
		-

	Principles

		Default Name

			-
				The default name of the common database API function is "query".
			-

		Parameters

			Sources

				-
					The sources parameter is either a single value or a list of values that
					specify databases that the requests are directed at.

					Each of said values may either be a string specifying the database, or a list
					where the first element is said string and the second element, if present, is
					a list of lists where in each of said nested lists, the first element is a
					string specifying the name of a credential and the second is a string
					containing the value of a credential.
				-

			Requests

				-
					The requests parameter is either a single value or a list of values that
					constitute requests directed at the intended databases.
				-

			Type

				-
					The type parameter, which is optional, is a string that specifies the type of
					database the requests are intended for.

					If the type parameter is not present, the API may attempt to dynamically
					accommodate the request.
				-
		
		Standard Types

			Relational
			Key
			Document
			Column
			Graph

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 1 - Data: 1 - Theory: 1 - Principles: 2 - Databases: 3 - Common Cache'

Common Cache

	Philosophy

		-
			A common cache is an object to which properties may be dynamically assigned, and from
			which properties may be read, by various external applications.
		-

	Principles

		Applications

			Common Cache Server

				-
					A common cache server is a server that hosts a common cache.
				-

		Conventions

			Conventional Common Cache Server

				-
					A conventional common cache server is a publicly accessible server that takes
					GET and POST requests, which may optionally take URL arguments with the aliases
					"key" and "persistent".

					POST requests may have a header with the alias "password", and any text value
					may be encoded in the body.

					If a request is sent without the key argument, a key shall be assigned to it
					that is not currently in use by the server's common cache.
					
					If it receives a POST request, it will assign to its common cache a field with
					the specified key and the value defined by the body of the request
					
					In all cases, it will write to the response a stringified JSON object with a
					field that has the alias "value", containing the string value assigned to the
					specified key, a field that has the alias "time", containing a number
					specifying the time in milliseconds that said value was assigned, and a field
					with the alias "key", containing the specified key.
					
					It shall store its common cache in volatile memory, and may deallocate memory
					if necessary, starting with the oldest values assigned to it, unless it
					receives a request where the persistent argument has a value of "true", in
					which case it shall store any value assigned by said request indefinitely in a
					persistent database.

					If a value is assigned by a POST request with a password header, it may only be
					reassigned by a POST request with a password header containing the same
					password, and if a persistent value was assigned without a password header, it
					may never be reassigned.

					When retrieving the value of a key without reassigning its value, a
					conventional common cache server shall first look for a key in its common cache
					matching the letter case of the specified key, and if said key is not found, it
					shall then look for said key without taking letter case into account.

					A conventional common cache server that does not allow for persistent values to
					be created is called a non-persistent conventional common cache server.
				-

			Common Cache Channel

				-
					A common cache channel is a key for a common cache pointing to a value used to
					exchange information between applications.

					An online application which uses common cache channels, called cache directed
					applications, may have both the common caches and the common cache channels to
					be used by them set in their URL arguments.
				-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 1 - Data: 1 - Theory: 1 - Principles: 3 - Processes: 1 - Render Product'

Render Product

	Philosophy

		-
			The render product of an operation consists of the information or material produce
			created as a result of it.

			In the context of computer programming, it refers to the information output by a
			program, generally to standard out, during its runtime, and to its final value, that
			being its return value or exit code, if applicable.
		-

	Principles

		Form

			-
				If a final value is not generated for a program, its render product should be said
				to consist of its output, and to consist of said output nested underneath its final
				value if a final value is returned.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 1 - Data: 1 - Theory: 1 - Principles: 3 - Processes: 2 - Collection States'

Collection States

	Philosophy

		-
			A collection state refers to the internal state of a system, which may be referred to
			as a collection process, in which a series of distinct entities, which may be called
			collection entities, are maintained.

			The serialization of a collection state may be referred to as a collection document,
			and collection documents may be used to either initiate or update a collection process.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 1 - Data: 1 - Theory: 2 - Documents: 1 - The Responsive DOM Principle'

The Responsive DOM Principle

	Philosophy

		-
			The Responsive DOM principle is the principle that all aspects of a document based
			rendering, including any changes made to it at runtime, must be reflected in the
			document that defines it.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 1 - Data: 1 - Theory: 2 - Documents: 2 - Self-Ciphering Document'

Self-Ciphering Document

	Philosophy

		-
			A self-ciphering document is an executable document that contains a human readable
			portion that may either be encrypted or unencrypted.

			If executed with a given key and a flag specifying whether said content should be
			encrypted or decrypted, said operation shall be performed on said content with said
			key.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 1 - Data: 1 - Theory: 2 - Documents: 3 - Dynamic Source Projection'

Dynamic Source Projection

	Philosophy

		-
			Dynamic source projection is the process of constructing code capable of recreating an
			observed process, called dynamic code projection, or of constructing data capable of
			modelling an observed state, called dynamic state projection.
		-

	Principles

		Verbal Source Projection

			-
				Verbal source projection is the process of constructing code capable of creating a
				process described verbally, called verbal code projection, or of constructing data
				capable of modelling a state described verbally, called verbal state projection.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 1 - Data: 1 - Theory: 2 - Documents: 3 - Dynamic Source Projection: 1 - Source Vectorization'

Source Vectorization

	Philosophy

		-
			Source vectorization is a process in which text in a given format is converted to a
			vector of numbers.
		-

	Principles

		Process

			-
				Source vectorization shall, by default, tokenize the source text into an array of
				strings, and convert said strings to numbers to produce the vector.

				The tokens used to divide said text are referred to as a vectorization set.
			-

		Number Assignment

			-
				As strings are converted to numbers as the process is repeated with numerous
				inputs, a log, called a token registry, shall be kept of each string converted.

				When a new string that has not yet been encountered is converted, it shall be
				assigned a number within the log according to the order it is added to the log,
				after which said string shall always be converted to said number.
			-

		Vector Serialization

			-
				Vector serialization is the process of serializing a vector to source text by
				reversing the process of source vectorization.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 1 - Data: 2 - Formats: 1 - General: 1 - Management: 1 - Environment: 1 - Local Network Cache'

Local Network Cache

	Philosophy

		-
			A local network cache is a file or database that stores files retrieved from the
			internet during the operation of a given process so that the same resources may be used
			even when the internet is not available.
		-

	Principles

		Conventions

			Auto-Cache Protocol

				-
					An auto-cache protocol, when applied to a given process, causes said process to
					automatically load resources into a local network cache when retrieving
					resources from the internet, and to automatically retrieve said resources from
					the local cache when the internet is unavailable.
				-

			Optimization

				Pre-Cache and Instant Cache

					-
						To pre-cache resources for a given process is to load any resources said
						process may require into a local network cache before said process is ever
						executed.

						Instant caching is a similar process in which said resources are loaded at
						the beginning of runtime as opposed to before it.
					-

				Mass-Cache

					-
						A mass cache is a pre-filled local network cache which may have its
						contents loaded into another, reducing the number of requests that need to
						be made in order to perform pre-caching or instant caching.
					-

				Re-Cache Properties

					-
						Re-cache properties are properties assigned to given resources which
						dictate the circumstances under which resources should be reloaded from the
						internet if the internet is available and said resources are already
						encoded within the local cache.

						If no re-cache properties are specified for a given resource, said resource
						shall always be reloaded if the internet is available.

						A convention specifying the details of a type of re-cache property, along
						with any method for encoding it, is referred to as a re-cache convention.
					-

		Standards

			Standard Network Cache

				-
					A standard network cache is a JSON object with two fields, the first being a
					field with the alias "cache", containing a list of cache objects, and the
					second being a field with the alias "reference", containing an ID JSON object.
					
					A cache object is a JSON object containing a field with the alias "content",
					which contains a string containing the content of a given resource, and
					optionally containing a field with the alias "properties", which contains a
					properties object, in which each field represents a re-cache property of said
					resource, the alias of said field being the name of said property, and the
					value of each field being the content of said property.

					The reference object contains fields where the key specifies a path to a given
					resource, and the content specifies the index of a cache object in the cache
					array which contains said resource.
					
					A standard network cache shall, unless specified otherwise, be stored as a file
					with the name "localCache.json"

					An auto-cache protocol that uses a standard network cache is called a standard
					auto-cache protocol.
				-

			Re-Cache Conventions

				Reload

					-
						The reload re-cache property is a boolean flag which determines if the
						resource to which it applies should ever be reloaded, being true if so and
						false otherwise.

						In a standard network cache, a field specifying the reload property shall
						have the alias "reload", and shall contain a boolean as specified in the
						definition of the property.
					-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 1 - Data: 2 - Formats: 1 - General: 1 - Management: 2 - Communication: 1 - JSH'

JSH

	Philosophy

		-
			JSH, which stands for JavaScript Shell, is a JSON format used for relaying command line
			instructions to devices.
		-

	Principles

		Conventions

			Communication

				Protocol

					-
						Calls made to devices using JSH should use POST requests sent over HTTPS.
					-

				Password

					-
						A JSH password is a credential required in a JSH call by a JSH server in
						order for said call to be processed.

						A JSH password may or may not be set at any given time.
					-

			Operations

				Modules

					-
						JSH modules are JSON schemas governing messages sent to and from certain
						applications on targeted systems alongside explicit commands via JSH.

						Each JSH module shall have a name, a request schema, and a response schema.

						A JSH application may run in restricted mode, in which command line
						instructions are prohibited, and only JSH modules are permitted.
					-

				Processes

					-
						A JSH process is a process which was either initiated via a JSH call, or
						which has otherwise granted permission to a JSH server to access it.
						
						Each active JSH process shall have a unique numerical ID.
					-

		Format

			Request

				-
					The JSH request format is the JSON object format governing calls made to JSH
					servers. An object following the JSH request format is referred to as a JSH
					request object.

					A JSH request object may have any of the following fields: a field with the
					alias "commands", a field with the alias "processes", a field with the alias
					"modules", a field with the alias "password", and a field with the alias
					"newPassword".

					The commands field, if present, shall contain a list of objects, where each
					object shall have a field with the alias "command", containing a string
					specifying a command to be executed on the targeted device, and may optionally
					have a field with the alias "location", containing a string specifying the path
					to execute said command from.

					The processes field, if present, shall contain a list of objects, where each
					object shall have a field with the alias "id", containing a string specifying
					the numerical ID of an active JSH process, and may optionally have a field with
					the alias "input", containing a string to be sent to said process via command
					line input, as well as a field with the alias "terminate", which shall contain
					a boolean that, if true, shall cause said process to terminate.

					The modules field, if present, shall contain a list of objects, each of which
					shall have a field with the alias "module", containing a string specifying the
					name of a JSH module, and a field with the alias "request", containing an
					object in the request schema of said module.

					The password field, if present, shall contain a string specifying the current
					password of the JSH server. If said password is not provided as required when a
					password is set, the call shall not be processed.

					The newPassword field, if present, shall contain either a string, which shall
					change the password to said string, or shall contain a null value, which shall
					disable the password requirement.
				-

			Response

				-
					The JSH response format is the JSON object format governing calls made to JSH
					servers. An object following the JSH response format is referred to as a JSH
					response object.

					A JSH response object may have any of the following fields: a field with the
					alias "commands", and a field with the alias "modules".

					The commands field, if present, shall contain a list of objects for each active
					JSH process, where each object shall have a field with the alias "command",
					containing a string specifying the command which spawned said process, a field
					with the alias "location", containing a string specifying the path from which
					said process is running, a field with the alias "id", containing a string
					specifying the numerical ID of said process, and a field with the alias "log",
					containing a string specifying the output logged to the terminal by said
					process since the last JSH call.

					The modules field, if present, shall contain a list of objects for each JSH
					module operated by the JSH server, where each object shall have a field with
					the alias "module", containing a string specifying the name of a JSH module,
					and a field with the alias "response", containing an object in the response
					schema of said module, specifying the current state of said module.
				-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 1 - Data: 2 - Formats: 1 - General: 1 - Management: 2 - Communication: 1 - JSH: 1 - Atlas JSH'

Atlas JSH

	Philosophy

		-
			Atlas JSH is a convention that enables the use of JSH to facilitate communication with
			a persistent atlas through a JSH module, where the name of said module is "atlas",
			where said module's request schema is a string, and where said module's JSH module
			response schema is the list of the values returned as a result of the request.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 1 - Data: 2 - Formats: 1 - General: 1 - Management: 2 - Communication: 2 - Segmented Message'

Segmented Message

	Philosophy

		-
			A segmented message is a message sent in pieces so as to avoid exceeding the size
			limits of messages sent across certain mediums.
		-

	Principles

		Properties

			-
				Each segmented message shall have a numerical ID, and each chunk shall have an
				index, starting at one, representing its order relative to the other chunks.

				The final message shall be derived by concatenating the content of the chunks
				together in order as specified by their indexes.
			-

		Standard Segmented Message Format

			-
				The standard format for a segmented message chunk is the ID of the message,
				followed by a non-numerical character, followed by the index of the chunk, followed
				by a non-numerical character, followed by the total number of chunks in the
				message, followed by a non-numerical character, followed by the content of the
				chunk itself.
			-

		Standard Format Separators

			-
				The standard separators used by the standard segmented message format are a hyphen
				for the first separator, a forward slash for the second separator, and a new line
				for the third separator.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 1 - Data: 2 - Formats: 1 - General: 1 - Management: 2 - Communication: 2 - Segmented Message: 1 - SMS Relay'

SMS Relay

	Philosophy

		-
			An SMS relay is an HTTP server for which can send the content of a request using
			segmented messages sent over SMS to a phone number belonging to a targeted device.

			Once the content has been relayed, the server may wait for a response from the targeted
			device, sent to said server using either segmented messages or HTTP, before returning a
			response to the caller containing the response from said device.
		-

	Principles

		Formats

			Initial Request

				-
					A request sent to an SMS relay shall use the POST method, and the body shall
					be a JSON object containing two fields, called "number", "content", and
					"return" respectively.

					The number field shall contain a string specifying the international phone
					number of the targeted device, the content field shall contain a string
					specifying the message to be sent to said device, and the return field, which
					is optional, shall contain a boolean specifying whether or not the server must
					return a response from the device, with true indicating that it must and false
					indicating that it does not have to. If the return field is absent, it shall be
					set to true by default.
				-

			Relayed Request

				-
					The content of a segmented message sent from an SMS relay to a device shall
					specify the protocol for returning a response to the relay along with the
					content of the message.

					The message shall consist of the protocol, followed by two new line characters,
					followed by the content of the message.

					If the protocol is to return a segmented message to a phone number, the
					protocol shall consist of one line specifying the international phone number to
					send the message to.

					If the protocol is to return an HTTP request, the protocol shall consist of the
					lines of an HTTP request containing the method, the URI, and the headers.

					If a response is not required, there shall be no protocol section.
				-

			UHAPI

				-
					An SMS relay may be used as an endpoint for UHAPI applications.
				-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 1 - Data: 2 - Formats: 1 - General: 1 - Management: 3 - Monitoring: 1 - Terminal Log'

Terminal Log

	Philosophy

		-
			A terminal log is a document generated by an application which records all items
			printed to the console.

			Each instance of terminal output captured in a terminal log is called a log item.
		-

	Principles

		Applications

			-
				An internal logger is a module within an application that generates a terminal log
				for said application.

				An external logger is a bootstrap process that captures the output of its bootstrap
				subjects and generates a terminal log for them on their behalf.

				An external logger may alter the form of the log items it captures. The criteria it
				uses to do this is referred to as a log map.
			-

		Items

			ID

				-
					The ID of a log item is the order in which it was captured relative to all
					other log items.

					Said IDs start at one.
				-

			Standard Log Item

				-
					A standard log item is a log item in the form of an object that specifies the
					content of a message, the time that said message was logged, and a series of
					string tags, classifying the message.
				-

		Formats

			Log

				-
					The standard format for a terminal log is a JSON array, where each log item is
					recorded as a string, positioned in the order that they were captured.

					A JSON document containing such an array is called a standard terminal log
					document.
				-

			Standard Log Item

				-
					The standard format for a standard log item is the stringified form of a JSON
					object containing the following fields:

					A field with the alias "content", containing a string specifying the message of
					the item.

					A field with the content "time", containing a number specifying the system
					time, in seconds, that the item was logged.

					A field with the content "tags", containing an array of strings specifying the
					tags assigned to the item.

					A stringified object in said format is called a standard log item object.

					A standard terminal log document containing only standard log item objects is
					called a standard terminal item document.
				-

		Terminal Multilog

			-
				A terminal multilog is a terminal log containing the output of multiple
				applications.

				A standard terminal log document containing a multilog is called a standard
				terminal multilog document, and a standard terminal item document containing a
				multilog is called a standard terminal multi-item document.

				Tags used by standard log items in terminal multilogs may be used to indicate which
				application they were generated by.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 1 - Data: 2 - Formats: 1 - General: 1 - Management: 3 - Monitoring: 1 - Terminal Log: 1 - Server Log'

Server Log

	Philosophy

		-
			A server log is a standard terminal item document for a server in which is recorded all
			requests received by it, all responses served by it, all errors that occurred in the
			course of its operations.
		-

	Principles

		Tags

			-
				A request log item shall have the tag "request". A response log item shall have the
				tag "response". An error log item shall have the tag "error". Any other type of log
				item shall have the tag "note".

				A response log item shall also have a tag consisting of the string "id-" followed
				by the log item ID of the corresponding request's log item.
			-

		Content

			-
				The content of logged requests and responses shall consist of stringified HTTP JSON
				objects corresponding to said items.

				The content of logged errors shall consist of the printed form of said error's
				stack.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 1 - Data: 2 - Formats: 1 - General: 2 - Content: 1 - Data: 1 - Data LISP'

Data LISP

	Philosophy

		-
			Data LISP is the use of LISP syntax to encode data such that LISP's syntax may function
			as a data interchange language.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 1 - Data: 2 - Formats: 1 - General: 2 - Content: 1 - Data: 2 - GMF'

GMF

	Philosophy

		-
			GMF, or General Metadata Format, is a text format for encoding a plain text document
			alongside an indefinite number of metadata fields.
		-

	Principles

		Format

			-
				GMF follows the same structure as an HTTP POST call, where the method is specified
				as "GMF", where the URI is absent or irrelevant, where the metadata items are
				encoded as headers, the alias of the headers being the names of the metadata items
				and the values of the headers being the content of the metadata items, and where
				the body is the plain text document to which said metadata applies.

				A GMF document may either be serialized as a raw HTTP style request, or in any
				other format that can be mapped to an HTTP style request, however, the former
				method is considered standard.
			-

		GMF Metadata Conventions

			-
				A standardized convention for a GMF metadata item is called a GMF metadata
				convention.

				The GMF escape convention allows the aliases and values of any GMF header to which
				it applies, and it applies to all GMF headers by default, to use the same string
				escape conventions as JSON strings, to avoid conflicts over colons and new lines.

				The GMF validation convention allows the aliases any GMF header to which it
				applies, and it applies to all GMF headers by default, to ignore letter case and
				whitespace.

				The GMF type convention allows the type of data encoded in a GMF document to be
				specified by the value of a header with the alias "Type".
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 1 - Data: 2 - Formats: 1 - General: 2 - Content: 1 - Data: 2 - GMF: 1 - GMFB'

GMFB

	Philosophy

		-
			GMFB, or GMF-Block, is a GMF metadata convention for specifying the content and
			connections of a node in a regressive linked tree, where the body of the document
			specifies the content of the node.
		-

	Principles

		Type

			-
				The type of a GMFB document shall be specified as "Block".
			-

		Previous

			-
				A GMFB block shall have a header with the alias "Previous", containing a JSON array
				of arrays, where each nested array represents a possible previous node and contains
				an indefinite number of strings specifying general identifiers indicating where to
				locate said node, and where the order of the nested arrays determines their
				priority, if applicable.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 1 - Data: 2 - Formats: 1 - General: 2 - Content: 2 - DOM: 1 - DOM to Text'

DOM to Text

	Philosophy

		-
			An HTML document may be converted to a plain text document by getting the inner text
			property of the root element of the rendered document.
		-

	Principles

		Excess Whitespace

			-
				When doing DOM to text conversion, excess whitespace, including leading and
				trailing whitespace on each line, and new lines leading and trailing the
				non-whitespace content of the document, should be eliminated, and then sequences of
				three or more new lines in a row should each be replaced with sequences of two new
				lines.
			-

		Rich Text Conversion

			-
				Any rich text document, paginated or otherwise, may be converted to a plain text
				document by first converting said document to HTML and then by performing DOM to
				text conversion on it.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 1 - Data: 2 - Formats: 1 - General: 2 - Content: 2 - DOM: 2 - Printable DOM'

Printable DOM

	Philosophy

		-
			A printable DOM document, or PDOM document, uses the existing HTML specification to
			form a simple and open standard for encoding the content of a multi-page printable
			document.
		-

	Principles

		Structure

			-
				A printable DOM document is represented as a list of objects, each of which
				represents a page in said document, ordered according to their order in the
				document.
				
				Each page object contains the virtual pixel dimensions of the page so as to
				calibrate the size of content scaled by pixels and to specify the shape of the
				page.

				Each page object shall also contain the DOM of an HTML document, which shall
				specify its content.
			-

		Standards

			Overflow

				-
					If the content of a given page overflows its bounds, new pages shall appear in
					the rendered document containing the overflowing content, with horizontal
					overflow given priority over vertical overflow.
				-
		
			Encoding

				-
					The standard method of encoding a PDOM document is as a JSON document, where a
					JSON list serves as the container of the document, and where each page object
					within it is represented as a JSON object.

					Each page object shall thus have three fields, a number field for each the of
					the virtual pixel dimensions with the keys "width" and "height" respectively,
					and a string field with the key "content" containing the DOM content of the
					page as either a DOM JSON string or as an HTML string.
				-

			File Extension

				-
					The standard file extension for a PDOM document is ".pdom".

					Said acronym may be pronounced "pea-dom".
				-

			Zipped PDOM

				-
					A printable DOM file may be distributed with the resources it is dependent on
					in a zipped file.

					The PDOM file itself shall be located at the root of the zipped folder and
					shall be named "index.pdom". Said file shall reference the resources in the
					zipped file using relative paths.

					The zipped file itself shall have the extension ".zpdom", which may be
					pronounced "zip-dom".
				-

			Slideshow

				-
					A PDOM document may be used to encode the content of a slideshow, where each
					page object is interpreted as a slide rather than a page.

					For this case, page objects may contain additional fields specifying metadata
					regarding slide and content transitions.
				-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 1 - Data: 2 - Formats: 1 - General: 2 - Content: 3 - ACE Meta'

ACE Meta
	
	Philosophy
	
		-
			ACE Meta is a convention that establishes a type of ACE element that can store the
			saved state for an application running on a user's system, where such an element has
			the content "ACE Meta", and two children, one with the content "Source", which has a
			child containing the name of a given application, and one with the content "Data",
			which may have an indefinite number of children, each containing the name of a saved
			state for said application as its content and each having a child with the content of
			said saved state as its content.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 1 - Data: 2 - Formats: 1 - General: 3 - Storage: 1 - Standard Repository'

Standard Repository

	Philosophy

		-
			The standard repository is a convention for project repositories.
			
			Under the convention, project repositories should contain one folder sharing the name
			of the repository, in which all of the project contents are kept. Alongside said
			folder, there may also be a license file and a readme file.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 1 - Data: 2 - Formats: 1 - General: 3 - Storage: 2 - Alias Metadata Format'

Alias Metadata Format

	Philosophy

		-
			The alias metadata format is a convention for file names, and other aliases that follow
			the same conventions as file names, to specify additional metadata about the files or
			items they reference.

			Under the alias metadata format, an alias shall have at least two periods, and shall
			consist of an ID sequence, spanning from the beginning of the alias to before the first
			period, a content sequence, spanning from after the first period to before the last
			period, and an extension sequence, spanning from after the last period to the end of
			the alias.

			The content sequence shall be divided into segments by periods, referred to as metadata
			segments, representing metadata about the referenced item.
			
			To represent a key-value pair, a metadata segment may be divided by a hyphen, with the
			section prior to the hyphen denoting the key, and with the section after the hyphen
			denoting the value.

			A codified convention specifying the content and effect of a metadata segment shall be
			referred to as an alias metadata convention.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 1 - Data: 2 - Formats: 1 - General: 4 - Organization: 1 - General Construct Format'

General Construct Format

	Philosophy

		-
			General Construct Format (GCF), is a ONE format used to specify assemblies, or
			constructs, of discrete parts, or construct components, linked together by construct
			links.
		-

	Principles

		Conventions

			Elements

				Aliases

					-
						Constructs, and any sub-item thereof, may be assigned aliases.

						Certain constructs may be presumed to exist in certain contexts without
						being explicitly specified, and may be referenced by alias. Such constructs
						are referred to as default constructs.
					-

				Axioms

					-
						The axioms of assembly for a given type of construct are rules which
						specify how certain components or relationships between components may be
						inferred implicitly and deterministically from those specified explicitly.
					-

				Nomenclature

					-
						The name of a construct, if it has no alias, may be derived by
						concatenating the names of each type of construct component within them,
						said names being their aliases if they have aliases, or their derived name
						if not, each preceded by their quantity if said quantity is greater than
						one, ordered first alphabetically and then numerically.
					-

			GCF Standards

				-
					A GCF standard is a codified convention for variants of GCF.
				-

		Formats

			Elements

				Unit Format

					-
						The unit format is a ONE format used to specify the types of construct
						components, which may themselves be constructs, and the numbers and aliases
						thereof, in constructs, said information composing a construct unit. A
						construct unit may alone comprise a construct if the axioms of assembly for
						the context of said construct are sufficient to denote the other crucial
						details.

						The element containing a construct unit shall have children for the types
						of construct components within it, the content of which shall be a
						component specifier, which shall specify a quantity, and may specify an
						alias, for a group of construct components of said quantity within said
						construct, and the children of which shall specify the type of the
						construct components in said group.

						A component specifier may either be a number, specifying the quantity of
						its group, or anything else, specifying the alias of its group and
						indicating that the quantity of its group is one.
						
						As such, the contents of a construct unit may be interpreted as a cluster
						list from which a list may be derived, to which the construct elements
						thereof may be assigned unit indices.

						The standard content for an element specifying a construct unit is "Unit".
					-

				Net Format

					-
						The net format is a ONE format used to specify sets of construct links
						called construct nets.

						The element containing a construct net shall have children, each of which
						shall contain a ONE+ string specifying an index cluster for the construct
						unit it is associated with. Said children shall have children which shall
						each contain a ONE+ string specifying an index cluster for the construct
						unit it is associated with that the construct components specified by its
						parent are connected to, and may each optionally have a child specifying
						the direction of the connection, with a child having the content "Mono"
						specifies a one directional connection, and a child having the content
						"Dual" specifies a bidirectional connection. The mono or dual child, if
						present, may have additional children specifying miscellaneous information
						about the connections they are associated with, said information being
						referred to as construct link properties.

						The standard content for an element specifying a construct net is "Net".
					-

			Form Format

				-
					The form format is a ONE format used to specify constructs.

					It shall have a child in the unit format specifying a construct unit, and may
					also have a child in the net format specifying a construct net which contains
					construct links between the construct components of said construct unit.

					The standard content for an element specifying a construct is "Form", but may
					vary depending on the type of construct being specified.
				-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 1 - Data: 2 - Formats: 2 - Fields: 1 - Plain Math Notation'

Plain Math Notation

	Philosophy

		-
			Plain math notation (PMN) is the use of linear sequences of text characters, and
			generally digital plain text, to encode mathematical notation.

			Plain math notation may be accompanied by visuals but should not be dependent on them.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 1 - Data: 2 - Formats: 2 - Fields: 1 - Plain Math Notation: 1 - Computational'

Computational Math Notation

	Philosophy

		-
			Computational math notation (CMN) is the application of programming conventions to math
			notation.
		-

	Principles

		The Computational Process

			-
				In CMN, operations are encoded in expressions, in which operators operate on
				operands in a recursive and hierarchical manner, and performed in sequence, through
				which a state is maintained.

				A rule is a declaration which identifies a set of expressions as equivalent. Rules
				may be declared valid or invalid relative to an external set of rules and a set of
				mathematical axioms.

				A transformation is an operation which changes the form of an expression without
				altering its value, in accordance with an external set of rules and a set of
				mathematical axioms. A resolution is a transformation which reduces an expression
				to as few terms as possible.

				Axioms shall be embedded in the state of the computation by default, but may be
				altered. Rules may be stored in variables as objects, or embedded as axioms in the
				state so as to apply by default.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 1 - Data: 2 - Formats: 2 - Fields: 1 - Plain Math Notation: 1 - Computational: 1 - General Unary'

General Unary

	Philosophy

		-
			General Unary is a method for encoding a number in base one using a string where said
			number is equivalent to the length of said string.
		-

	Principles

		Standard Unary

			-
				Standard unary is a variant of general unary where every character in a string
				written in it should be the number one.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 1 - Data: 2 - Formats: 2 - Fields: 2 - AI: 1 - Kaeon Neural Network Format'

Kaeon Neural Network Format

	Philosophy
	
		-
			The Kaeon Neural Network Format is a ONE document format for storing the state of a
			neural network.
		-
	
	Principles
		
		Structure
			
			-
				The document will contain an indefinite number of elements, each containing the
				content "Layer" or "Use".
				
				Elements with the content "Layer" correspond to a layer in a neural network. The
				order in which they are listed dictates the order of the layers in the neural
				network.
				
				Elements with the content "Use" may have an indefinite number of children, each
				with content specifying the name of a module containing various activation
				functions. Each of said activation functions will have a string alias.
				
				Nested within the layer elements will be an indefinite number of elements
				containing the content "Neuron", corresponding to neurons within their respective
				layer, listed in the order corresponding to their indexes. Each neuron element will
				have a combination of the following children: an element with the content
				"Connections", and element with the content "Bias", and an element with the content
				"Activation".
				
				The element with the content "Connections" must be present if the layer its
				respective neuron occurs in is not the last layer and must be absent otherwise,
				will have a child with containing a number between between zero and one for every
				neuron in the following layer, corresponding with the weights of the neural
				connections.
				
				The element with the content "Bias", if present, will have a child containing a
				number between zero and one, corresponding to the bias of the neuron. If the bias
				element is not present, the neuron will have a bias of zero. This element may not
				be present in a neuron belonging the first layer of the neural network.
				
				If an element with the content "Activation" is present among the children of a
				neuron element, it must have a child containing the alias of an activation function
				provided by one of the modules referenced by a use element. The referenced
				activation will be the activation function of the neuron defined by said neuron
				element.
				
				If an element with the content "Activation" is not present among the children of a
				neuron element, the neuron defined by said neuron element will have the following
				activation function:
				
					f(x) = 1 / (1 + e^-x)
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 1 - Data: 2 - Formats: 2 - Fields: 3 - Biochemistry: 1 - Standard Atomic Notation'

Standard Atomic Notation

	Philosophy

		-
			Standard atomic notation (SAN) is a plain text format used to denote the type and state
			of atoms. The text specifying an element in SAN is referred to as a SAN definition.

			A SAN definition consists of one to three parts, the first of which, which must be
			present, is the element identifier and specifies the element type of the atom, the next
			of which, which is optional, is the isotope identifier and specifies the isotope of the
			atom, and the last of which, which is optional, is the charge identifier and specifies
			the charge of the atom.

			The element identifier may be written as either the atomic number or the atomic symbol
			of the atom. The isotope identifier shall be written as the atomic mass number of the
			atom. The charge identifier shall be written as the charge number of the atom preceded
			by a plus plus for a positive charge or a minus sign for a negative charge.
		-

	Principles

		Conventions

			Numeric Element Naming

				-
					In addition to their common names, elements may be referred to as "element ",
					followed by their atomic number.
				-

			Molecular GCF

				-
					Molecular GCF, or MGCF, is a GCF standard used to represent molecules.

					Under MGCF, the standard content for an element specifying a construct is
					"Chem".

					Under MGCF, all known and named molecular compounds are default constructs.

					Under MGCF, both MGCF constructs and SAN definitions may be used as construct
					components.

					Under MGCF, molecular bond types may be used as construct link properties.
				-

		Formats

			Conventional

				-
					The conventional rendering of a SAN definition concatenates the identifiers for
					an atom together in order, with the isotope number preceded by a period if it
					is present.
				-

			ONE

				-
					The ONE rendering of a SAN definition uses an element with the element
					identifier as its content, and elements with the isotope and charge identifiers
					as their content, as its children.
				-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 1 - Data: 2 - Formats: 2 - Fields: 3 - Biochemistry: 2 - Standard Genetic Format'

Standard Genetic Format

	Philosophy

		-
			The standard genetic format is a list format for encoding the genome of an organism.
		-

	Principles

		Structure

			-
				The standard genetic format shall use a category set of nucleotides arranged into a
				three dimensional list, the root list containing lists representing each major
				section of the genome, and each section list containing lists representing known
				portions of that section, each portion list specifying a sequence of nucleotides
				using the labels of the category set, and the spaces between the portion lists
				representing unknown or variable portions of the genome.
			-

		Conventions

			Category Set Indices

				Adenine: 0
				Cytosine: 1
				Guanine: 2
				Thymine: 3
				Uracil: 4

			Eukaryotic Conventions

				-
					The convention for representing the genome of a eukaryotic organism is to
					specify the nucleotide sequences for each of its chromosomes in order, followed
					by the nucleotide sequence of its mitochondria.
				-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 1 - Data: 2 - Formats: 3 - Documentation: 1 - General Flow Protocol'

General Flow Protocol

	Philosophy

		-
			The General Flow Protocol (GFP) is a convention for constructing diagrams of entities
			and their relationships.
		-

	Principles

		Protocol

			-
				Documents constructed in GFP consist of entities and connections.

				Entities each have the following properties: a type, and a name.

				Connections each have the following properties: a primary entity, a secondary
				entity, a format, a type, and a name.
				
				The format of a connection may be "bidirectional", meaning that the connection
				denotes a bidirectional link between its primary and secondary entities,
				"monodirectional", meaning that the connection denotes a one-way link from the
				primary entity to the secondary entity, or "parent", meaning that the connection
				denotes that the secondary entity is a child of the primary entity.
			-

		Conventions

			General Flow JSON

				-
					A General Flow JSON object is a JSON object with two fields, one with the alias
					"entities" and an object value, and one with the alias "connections" and an
					array value containing objects.

					The entities object shall have a field for each entity, with each alias serving
					as an ID for the entity represented by the object in its value.

					Said object shall have a field with the alias "name", and a field with the
					alias "type", each of which shall contain strings.

					Each object in the connections array shall represent a connection between two
					entities specified by the entities object.

					Said objects shall each have a field with the alias "primary", a field with the
					alias "secondary", a field with the alias "format", a field with the alias
					"type", and a field with the alias "name", all of which must contain string
					values, except for type and name, which may be null as well.

					The primary and secondary fields shall specify the IDs of the entities to which
					they correspond as specified by the keys of the entities object, and the values
					of the format field shall be limited to "bidirectional", "monodirectional", and
					"parent".
				-

			Rendering Schemes

				-
					A GFP rendering scheme is a codified convention for how to visualize a GFP
					document given the properties of its elements.
				-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 2 - Algorithms: 1 - Conventions: 1 - Methods: 1 - General: 1 - Processes: 1 - Dynamic'

Dynamic Dependency Retrieval

	Philosophy

		-
			Dynamic dependency retrieval is a convention wherein a programming environment shall
			dynamically install any external dependencies required by programs running within it if
			they are not installed already.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 2 - Algorithms: 1 - Conventions: 1 - Methods: 1 - General: 1 - Processes: 2 - Polyglot Call'

Polyglot Call

	Philosophy

		-
			A polyglot call is an operation which, from one language or environment, dynamically
			executes an operation in another, and returns the result to whatever it was called
			from.
		-

	Principles

		Types

			Command

				-
					A command polyglot call takes a string specifying a terminal command, executes
					it, and returns the contents of stdout upon its completion.
				-

			Compile

				-
					A compile polyglot call takes a string specifying the code for a program
					written in a different language, and may optionally take a list of string
					arguments for said program.

					It dynamically interprets or compiles said code, runs the resulting program
					with the provided arguments if there are any, and then returns the contents of
					stdout upon its completion.
				-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 2 - Algorithms: 1 - Conventions: 1 - Methods: 1 - General: 1 - Processes: 3 - Loose Conditionals'

Loose Conditionals

	Philosophy

		-
			A loose conditional is a conditional operation that first uses an algorithm to assign a
			similarity score between two values, usually strings, based on their size and content,
			said score being between zero and one, inclusive, and then executes based on whether
			said score falls within a certain threshold.

			A conditional that is not loose can be called rigid.
		-

	Principles

		Expert Systems

			-
				Loose conditionals can be used to construct expert systems that are more robust
				than those constructed with rigid conditionals.
			-

		Machine Learning

			-
				By default, algorithms used to assign similarity scores shall not use machine
				learning models to do so.

				If however, machine learning is used in a loose conditional, it can be called a
				smart loose conditional, or a basic loose conditional if not.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 2 - Algorithms: 1 - Conventions: 1 - Methods: 1 - General: 1 - Processes: 4 - Extrapolation'

Resource Extrapolation

	Philosophy

		-
			Resource extrapolation is a process wherein reusable assets are generated or identified
			via analysis of the state of a given process or application.
		-

	Principles

		Extrapolation Improvisation

			-
				Extrapolation improvisation is where an extracted asset is assigned certain
				liberties in its behavior to account for uncertainties regarding the source from
				which it was derived.
			-

		Record Extrapolation

			-
				Record extrapolation is a process wherein code and media dependencies of a given
				process are identified and sorted into groups by type.

				A file recording said information may be used in building other instances of said
				process, or variants thereof.

				Said record may take the form of an asset JSON object, which has a field for each
				type of asset, where the alias of said field identifies the type of asset, and the
				value of the field contains a list of strings identifying the location of each
				asset of said type.
			-

		Types

			Script Extrapolation

				-
					Script extrapolation is the process of deriving scripts for entities in
					simulations based on their observed behavior.
				-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 2 - Algorithms: 1 - Conventions: 1 - Methods: 1 - General: 1 - Processes: 5 - Alias Recycling'

Alias Recycling

	Philosophy

		-
			Alias recycling is an optimization technique where memory and aliases assigned to one
			variable are used for another when the aforementioned variable is no longer needed, so
			as to spare minor amounts of time, memory, and code length.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 2 - Algorithms: 1 - Conventions: 1 - Methods: 1 - General: 1 - Processes: 6 - Convention Stack'

Convention Stack

	Philosophy

		-
			A convention stack is an ordered series of conventions for managing a process, where
			each item in said series, save for the first, abides by the previous convention.
		-

	Principles

		Conventions

			Deviation Degree

				-
					The degree to which a process expands upon the terms of a convention that it
					abides by without violating it is referred to as its deviation degree relative
					to said convention.
				-

		Applications

			Format Stack

				-
					A convention stack applied to the formatting of a document is called a format
					stack.
				-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 2 - Algorithms: 1 - Conventions: 1 - Methods: 1 - General: 1 - Processes: 7 - Typical Processing'

Typical Processing

	Philosophy

		-
			Typical processing (TP) refers to processing or processes for which the process
			initiates upon an external trigger, follows through a singular and linear sequence of
			steps, and returns a result to the external environment at the end.

			Any deviation from typical processing is referred to as atypical processing (ATP).
		-
	
	Principles

		ATP Types

			Simultaneous Processing

				-
					Simultaneous processing (SP) refers to processing or processes for which
					several internal sequences of steps are executed Simultaneously.
				-

			Dormant Processing

				-
					Dormant processing (DP) refers to processing or processes which may begin and
					continue independent of any external stimulus, may receive such stimuli at any
					time, and may return responses at any time.
				-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 2 - Algorithms: 1 - Conventions: 1 - Methods: 1 - General: 2 - Data: 1 - Dual Map'

Dual Map

	Philosophy

		-
			A dual map is a key-value map where each value may act as the key to access its key as
			a value, returning a list of keys if multiple keys have the same value.

			Using a value as the key for a key or set of keys is called reverse access, and should
			be implemented to allow for O(1) execution time.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 2 - Algorithms: 1 - Conventions: 1 - Methods: 1 - General: 2 - Data: 2 - Value Monitor'

Value Monitor

	Philosophy

		-
			A value monitor is an event listener that is assigned the alias or address of a
			specific value, called the target, and triggers an event any time said value is
			changed.

			The metadata for said event should include both the previous value and the current
			value of said target.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 2 - Algorithms: 1 - Conventions: 1 - Methods: 2 - Fields: 1 - AI: 1 - Data: 1 - Multifaceted Data'

Multifaceted Data

	Philosophy

		-
			Multifaceted data refers to groups of data points in machine learning datasets which
			share common outputs, called multi-output data, or common inputs, called multi-input
			data.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 2 - Algorithms: 1 - Conventions: 1 - Methods: 2 - Fields: 1 - AI: 1 - Data: 2 - Format: 1 - Binary'

Binary Cropping

	Philosophy

		-
			Binary cropping is a method for culling the output of operations where outputs are
			vectors of variable length containing numbers between zero and one, inclusive.
		-
	
	Principles

		Vector Set

			-
				When an input is received, it is passed to two separate operations, each of which
				returns a vector of numbers between zero and one.

				The first vector is called the value vector, the second vector is called the
				culling vector, and collectively they are referred to as a vector set.
			-

		Scaling

			-
				The length of the value vector should be equal to the length of the longest
				expected output value.

				The length of the culling vector should be equivalent to the number of binary
				digits in the shortest possible binary number where each digit is one, with a value
				equal to or greater than the length of the value vector.
			-

		Cropping

			-
				Once a vector set has been generated, the culling vector is interpreted to generate
				a binary number where the first number in the vector is the lowest binary digit,
				the last number in the vector is the highest binary digit, a number less than .5
				corresponds to a zero, and a number greater than or equal to .5 corresponds to a
				one.

				If the length of the value vector is greater than the value of the generated binary
				number, then the trailing end of the value vector shall be cropped such that the
				length of the value vector is equal to the value of the generated binary number.

				The value vector is then returned as the final result.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 2 - Algorithms: 1 - Conventions: 1 - Methods: 2 - Fields: 1 - AI: 1 - Data: 2 - Format: 2 - Gradient'

Gradient Vector
	
	Philosophy

		-
			A gradient vector is a vector created by mapping the contents of a vector containing
			numbers between zero and one, inclusive, to a vector which may have a different length
			such that every number in the original vector has an influence on every value in the
			new vector, relative to their respective indices.
		-
	
	Principles

		Coefficient

			-
				The following formula is used for calculating the coefficient used for multiplying
				the values of the original vector to produce the values of the new vector:
				
					1 - |(([Original Index] / [Original Size]) - ([New Index] / [New Size]))|
				
				The index values start at one, unless their corresponding length value is zero, in
				which case their value will be zero.
				
				If either of the length values are zero, then formula will be skipped and the
				coefficient will be set to zero to avoid a divide by zero error.

				After all the values have been calculated for a number in the output vector, the
				number used shall be the average of them.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 2 - Algorithms: 1 - Conventions: 1 - Methods: 2 - Fields: 1 - AI: 1 - Data: 2 - Format: 3 - Projection'

Dimensional Projection Training

	Philosophy

		-
			Dimensional projection training is the process of simplifying datasets used to train AI
			models by taking multi-dimensional data points within them and projecting them to lower
			dimensional vectors.

			If said data points are projected to scalars, then the process may be referred to as
			scalar projection training.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 2 - Algorithms: 1 - Conventions: 1 - Methods: 2 - Fields: 1 - AI: 1 - Data: 2 - Format: 4 - Input'

Input Assignment

	Philosophy

		-
			Input assignment is the process of taking an output value, and possibly a correlation
			value, intended for a machine learning dataset, and generating possible input values
			which could reasonably correspond to said output and correlation values.
		-

	Principles

		Reverse Dataset

			-
				A reverse dataset is a machine learning dataset generated from another machine
				learning dataset by reversing the input and output values.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 2 - Algorithms: 1 - Conventions: 1 - Methods: 2 - Fields: 1 - AI: 1 - Data: 2 - Format: 5 - Retro'

Retroscaled Transforms

	Philosophy

		-
			Retroscaled transforms are transforms of sequential data where data more relevant to
			earlier points in said sequence is transformed to a greater degree than data more
			relevant to later points in said sequence.

			Retroscaled transforms can be used in generative AI to help it retain awareness of the
			earliest states in a given context despite having limited input capacity.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 2 - Algorithms: 1 - Conventions: 1 - Methods: 2 - Fields: 1 - AI: 2 - Process: 1 - Train: 1 - Refactor'

Neural Network Refactoring

	Philosophy

		-
			Neural network refactoring is the act of altering the structure of a neural network to
			either increase or decrease its complexity while preventing it from producing a
			different output for any given input.

			Alternatively, to alter the structure of a neural network while allowing for a minimal
			amount of alteration in its output for any given input is referred to as neural network
			pseudorefactoring.
		-

	Principles

		Conventions

			Zero Augmentation

				-
					Zero augmentation is the process of performing neural network refactoring by
					adding new nodes to it where all of the newly created parameters resulting from
					the addition of said nodes are set to zero.

					In most neural network architectures, this should result in no change to the
					existing behavior of the model.
				-

			Layer Cloning

				-
					Layer cloning is a process for performing neural network refactoring in layered
					neural networks in a way that allows new layers to be added.

					First, a layer in the network, called the indexed layer, must be selected. The
					new layer will follow the indexed layer, and shall have the same number of
					neurons.

					The weights between the indexed layer and the layer which originally followed
					it, called the target layer, shall be transferred to the connections between
					the new layer and the target layer.

					The weights between the indexed layer and the new layer shall then be set such
					that for a given neuron in the indexed layer, the weight of the connection
					between itself and the neuron in the new layer of the same index shall be one,
					and the weight of the connections between itself and all other neurons in the
					new layer shall be zero.

					Other parameters, such as biases, should, unless otherwise specified, be
					assigned to either the indexed layer or the new layer and set to zero in the
					other.
				-

		Default Growth Process

			-
				Regarding zero augmentation, unless there is a specific reason otherwise, nodes
				should generally be added to the hidden layers which have the fewest nodes if the
				goal is simply to increase the complexity of the network, which should scale to the
				size of the training data, and to the input and output layers when necessary to
				accommodate larger data sizes.

				Regarding layer cloning, unless there is a specific reason otherwise, new layers
				should generally be added to the middle of existing networks.

				Unless there is a specific reason otherwise, when growing the network in general,
				layer cloning should be used if the number of nodes in each hidden layer is equal,
				and if the number of hidden layers is less then the number of nodes in each hidden
				layer, with zero augmentation being used in any other case, such that the shape of
				the hidden layers as a whole trends towards a square.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 2 - Algorithms: 1 - Conventions: 1 - Methods: 2 - Fields: 1 - AI: 2 - Process: 1 - Train: 2 - Filter'

Filter Router

	Philosophy

		-
			A filter router uses an AI model, called a soft map, to match inputs to types, for a
			type map, or numerical scores, for a score map, after which a secondary AI model,
			assigned according to the predicted type, can be assigned to generate a matching
			output.
		-

	Principles

		Type Catalogue

			-
				The set of types that may be assigned to an input by a filter router is called the
				type catalogue of said filter router.

				Each type shall have a model mapped to it.
			-

		Nesting

			-
				Filter routers may be nested within one another by assigning filter routers to
				types within another's type catalogue.
			-

		Auto-Generation

			-
				A process capable of generating a filter router and its corresponding type
				catalogue given a set of pre-existing models is called a filter generator.
			-

		Sequential Filter Router

			-
				A sequential filter router is a filter router that takes into account previous
				inputs it received and the types it assigned to them within a given usage context.

				A sequential filter router that can use auto-generation to modify itself
				mid-sequence is called an auto-generating sequential filter router.
			-

		Soft Filter

			-
				A soft filter is the use of a soft map on the output of generative AI.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 2 - Algorithms: 1 - Conventions: 1 - Methods: 2 - Fields: 1 - AI: 2 - Process: 1 - Train: 3 - ES'

Autogenerated Expert System

	Philosophy

		-
			Expert systems can be automatically generated for uses in filter routers from
			commonalities between items within a dataset sharing the same label.
		-

	Principles

		Generation

			Counting

				-
					The first step in autogenerating an expert system is to count how many items of
					each category possess certain properties.
				-

			Certainty Properties

				-
					If every item within a certain category possesses a certain property, then it
					is assumed that an item of said category must always possess said property,
					making said property a certainty property.
				-

			Secondary Certainty Properties

				-
					If every item within a certain category that possesses a certain property
					possesses another property, then it is assumed that an item of said category
					that possesses the former property must always possess the latter property,
					making the latter property a secondary certainty property.
				-

		Processing

			-
				A new input should be narrowed down to a certain subset of categories based on the
				certainty and secondary certainty properties that it possesses.
			-

		Ambiguity Testing

			-
				If autogenerating an expert system meant to feed into a system which uses
				pre-trained models, said models should be trained on groups of categories detected
				by running all training items through the certainty and secondary certainty
				categories to find all combinations of categories that occur when the ruleset is
				unable to narrow it down to one.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 2 - Algorithms: 1 - Conventions: 1 - Methods: 2 - Fields: 1 - AI: 2 - Process: 1 - Train: 4 - Split'

Split Training

	Philosophy

		-
			Split training is where when a dataset is passed into a process which trains a machine
			learning model, said dataset is split into two sets, the training set, which the model
			is trained on, and the testing set, which the model is tested on following the
			training.

			The original dataset is called the source set, and the resulting training and testing
			set are collectively called a split set.

			The ratio of the length of the training set relative to the length of the testing set
			is called the split ratio, and the way items are sorted into a split set from a
			source set according to the split ratio is called the split scheme.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 2 - Algorithms: 1 - Conventions: 1 - Methods: 2 - Fields: 1 - AI: 2 - Process: 1 - Train: 5 - Correlate'

Correlation Training

	Philosophy

		-
			Correlation training is where an AI model is trained using a process that assigns
			quality scores to output without specifying the intended output.
		-

	Principles

		Frenzied and Flat Scattering

			-
				Frenzied scattering is an approach to correlation training which randomly alters
				model parameters to a degree that increases as the quality evaluation of the output
				decreases.

				Randomly altering the parameters of a model to a degree determined without respect
				to its performance is called flat scattering.

				Both frenzied and flat scattering may correlate with neuron and connection metadata
				generated according to how the data was processed prior to the training.
			-

		Sugar-Spice Probing

			-
				Sugar-Spice Probing (SSP), is an approach to correlation training where, following
				a period of performance by a given model, the quality of said performance is
				assigned a score, with the model regressing to its base state, that either being
				its previous state in local SSP, or its best performing state in global SSP, if
				said performance is worse than that of said base state, and with flat scattering in
				flat SSP, or frenzied scattering in frenzied SSP, being applied to the model if
				said performance is worse than that of said base state.

				The degree of said flat scattering may increase as the number of failed attempts to
				improve the model increase.

				More advanced methods of SSP may utilize partial or complete state graphs.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 2 - Algorithms: 1 - Conventions: 1 - Methods: 2 - Fields: 1 - AI: 2 - Process: 1 - Train: 6 - Reverse'

Reverse Training

	Philosophy

		-
			Reverse training is the process of training an AI model using a dataset, called a
			reverse dataset, composed of responses generated by other AI models along with their
			corresponding inputs and any relevant metadata, so as to reproduce, and possibly
			combine, the behavior of existing AI models into new ones.
		-

	Principles

		Reverse Testing

			-
				Reverse testing is the use of a reverse dataset for testing a model instead of
				training it.
			-

		Inference

			Inference Extraction

				-
					Inference extraction refers to any process used to derive or approximate the
					data used to train a trained machine learning model from said model.
				-

			Inference Analysis

				-
					Inference analysis refers to any process used to derive meaningful information
					from the current state of a neural network currently processing information.
				-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 2 - Algorithms: 1 - Conventions: 1 - Methods: 2 - Fields: 1 - AI: 2 - Process: 1 - Train: 7 - MPM'

Multi-Purpose Model

	Philosophy

		-
			A multi-purpose model (MPM) is a single machine learning model trained for multiple
			separate use cases.
		-

	Principles

		Multi-Purpose Nodes

			-
				Multi-purpose nodes (MPN) are nodes in a neural network which may serve as input
				nodes, output nodes, both, or neither regardless of where they are located in the
				network.
			-

		Submodels

			-
				Submodels are subsections of larger machine learning models which may be used or
				trained in isolation, and which may be removed from or added to larger machine
				learning models.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 2 - Algorithms: 1 - Conventions: 1 - Methods: 2 - Fields: 1 - AI: 2 - Process: 1 - Train: 8 - Noise'

Noise Feedback

	Philosophy

		-
			Noise feedback is an approach to training AI models.
			
			Guided noise feedback takes output generated by a model for a given input, produces
			several variations of said output by applying noise to it, judges the resulting
			variations relative to said input, and then trains the model using said variations.
			
			Unguided noise feedback generates random noise as hypothetical input and output of a
			model, judges it, and then trains the model using said output.

			The inputs used in noise feedback may or may not be arbitrarily generated.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 2 - Algorithms: 1 - Conventions: 1 - Methods: 2 - Fields: 1 - AI: 2 - Process: 2 - Test: 1 - Analyzer'

Model Analyzer

	Philosophy

		-
			A model analyzer tests the accuracy of multiple AI models on a given dataset and ranks
			them according to their performance on said dataset.
		-

	Principles

		Auto-Selection

			-
				An AI system may train and test multiple models with a split dataset, and may
				automatically identify and utilize the model with the best results.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 2 - Algorithms: 1 - Conventions: 1 - Methods: 2 - Fields: 1 - AI: 2 - Process: 2 - Test: 2 - Assessment'

Margin Assessment

	Philosophy

		-
			Margin assessment is an assessment method in which the output of a process is judged on
			similarity to expected output rather than on precisely matching the expected output.

			A method of calculating the similarity of an actual output and an expected output is
			referred to as a margin convention.

			Assessment that relies only on exact matches is referred to as precision testing.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 2 - Algorithms: 1 - Conventions: 1 - Methods: 2 - Fields: 1 - AI: 2 - Process: 2 - Test: 3 - Correlate'

Correlation Testing

	Philosophy

		-
			Correlation testing is the testing of an AI model where each input output pair is
			assigned a correlation value between zero and one, inclusive, where the generated
			output is assigned a similar correlation value based on the its similarity to the
			specified output, and then judged based on how close said correlation value is to the
			specified correlation value.

			Correlation testing where all specified correlation values are set to zero is called
			anti-testing.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 2 - Algorithms: 1 - Conventions: 1 - Methods: 2 - Fields: 1 - AI: 2 - Process: 3 - Process: 1 - Input'

Self-Sustaining Input

	Philosophy

		-
			Self Sustaining input (SSI) is where an AI model receives input throughout an operation
			independent of the external context of the operation either through a elements of
			itself or through recurrency.
		-

	Principles

		Constant Input

			-
				Constant input is where input is constantly fed to a model regardless of whether
				input is received from an external source, either according to a constant pattern
				or with some degree of noise.

				When input is received from an external source, the constant input may either be
				paused, in the case of substitute constant input, or reduced with the external
				input superimposed atop it, in the case of permanent constant input.
			-

		Training as Self-Sustaining Input

			-
				A model with SSI which is trained throughout an operation may not require any
				additional input, as it constantly recalibrates its behavior according to the
				training.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 2 - Algorithms: 1 - Conventions: 1 - Methods: 2 - Fields: 1 - AI: 3 - Models: 1 - Map'

Data Map

	Philosophy

		-
			A data map is a set of input-output pairs where the input is a vector of indefinite
			length where each element is a number between zero and one, inclusive, and the output
			is a single number between zero and one, inclusive.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 2 - Algorithms: 1 - Conventions: 1 - Methods: 2 - Fields: 1 - AI: 3 - Models: 1 - Map: 1 - Cleansing'

Data Map Cleansing

	Philosophy

		-
			Data map cleansing is a process in which for a given data map, for all sets of points
			with matching input vectors, all are removed from the data map save for the most
			recently added point in each of said sets.

			A data map that has had data map cleansing applied to it is referred to as a cleansed
			data map.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 2 - Algorithms: 1 - Conventions: 1 - Methods: 2 - Fields: 1 - AI: 3 - Models: 1 - Map: 2 - Generate'

Data Map Generation

	Philosophy

		-
			Data map generation is any process in which a given data map and a vector of any length
			containing numbers between zero and one, inclusive, may be used to generate an output
			number between zero and one, inclusive, assuming said vector is a hypothetical input in
			a hypothetical input-output pair within said data map and said output number was the
			corresponding output in the input-output pair.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 2 - Algorithms: 1 - Conventions: 1 - Methods: 2 - Fields: 1 - AI: 3 - Models: 1 - Map: 2 - Generate: 1 - Curve'

Data Map Curve

	Philosophy

		-
			A data map curve is a multidimensional curve of best fit generated for a data map to be
			used in data map generation via curve regression.
		-

	Principles

		Curve Method

			Summary

				-
					The curve method is a data map generation algorithm that may be applied to a
					data map curve model.
				-

			Prerequisites

				-
					The curve method assumes a cleansed data map.
				-

			Steps

				Step One - Normalization

					-
						All points in the data map shall be normalized to have the same number of
						dimensions as the input value, either being cropped to the correct size or
						being padded with a padding value to match the correct size.
						
						Said padding value is by default zero.
					-

				Step Two - Selection

					-
						The N closest points to the input value shall be used to calculate the
						final value, where N is the number of dimensions of the input value.
						
						If the total number of available points is less than N, then all of them
						shall be used.
					-

				Step Three - Calculation

					-
						The distance between the closest point selected during step two to the
						input value and the input value itself shall be defined as the minimum.

						The final value shall be calculated as the sum of the values generated by
						passing each point selected during step two to the following function:

							f(point) =

								if(point = input[location]):
								
									1

								else if(minimum = 0):
								
									0

								else:
								
									(1 - (point[distance] / total[distance])) *
									(minimum / point[distance]) *
									point[value]
					-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 2 - Algorithms: 1 - Conventions: 1 - Methods: 2 - Fields: 1 - AI: 3 - Models: 1 - Map: 2 - Generate: 2 - Net'

Data Map Net

	Philosophy

		-
			A data map net is a neural network generated for a data map to be used in data map
			generation.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 2 - Algorithms: 1 - Conventions: 1 - Methods: 2 - Fields: 1 - AI: 3 - Models: 1 - Map: 3 - Vector'

Data Map Vector

	Philosophy

		-
			A data map vector is a list of data maps.

			If the same input vector is used to approximate an output for all of them, then the
			outputs may be combined into an output vector.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 2 - Algorithms: 1 - Conventions: 1 - Methods: 2 - Fields: 1 - AI: 3 - Models: 1 - Map: 3 - Vector: 1 - Map'

Synchronous Map

	Philosophy

		-
			A synchronous map is a data map vector in which each data map has the same number of
			input-output pairs, with the same input vectors across each corresponding input-output
			pair, while not necessarily sharing the same output values across each corresponding
			input-output pair.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 2 - Algorithms: 1 - Conventions: 1 - Methods: 2 - Fields: 1 - AI: 3 - Models: 1 - Map: 3 - Vector: 2 - Stack'

Data Map Stack

	Philosophy

		-
			A data map stack is a sequence of data map vectors where the output of one data map
			vector becomes the input for the next, where each of said vectors is referred to as a
			layer.
		-

	Principles

		Blackbox

			-
				A data map stack functions as a single data map vector from the perspective of any
				external systems where the first layer is the input and the last layer is the
				output.
			-

		Deep

			-
				Any data map stack consisting of four layers or more is considered deep.
			-

		Training

			-
				In training a data map stack, the process looks for the lowest amount of change it
				can make to the stack to achieve the desired results.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 2 - Algorithms: 1 - Conventions: 1 - Methods: 2 - Fields: 1 - AI: 3 - Models: 1 - Map: 4 - Reduction'

Data Map Reduction

	Philosophy

		-
			Data map reduction is the process of creating a model that may serve as a heuristic for
			a data map while being simpler to store, to process, or both.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 2 - Algorithms: 1 - Conventions: 1 - Methods: 2 - Fields: 1 - AI: 3 - Models: 1 - Map: 5 - Binary'

Binary Data Map

	Philosophy

		-
			A binary data map is a data map where every number in the input vector as well as the
			output number can only be a zero or a one.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 2 - Algorithms: 1 - Conventions: 1 - Methods: 2 - Fields: 1 - AI: 3 - Models: 2 - NN: 1 - Methods: 1 - ASNP'

Asynchronous Neural Processing

	Philosophy

		-
			Asynchronous neural processing (ASNP) is the application of atypical processing to
			neural networks.
			
			As such, ASNP employs the usage of a neural network in which data may be fed to its
			input nodes at each step of its processing, a step being any time data is transferred
			from one set of nodes to another, such that the feeding of input and the reading of
			output may be a continuous process spanning many simultaneous contexts.

			The value stored within a given node at any point is called its state.

			Training processes for neural networks designed for ASNP may seek to minimize steps as
			well as error.
		-

	Principles

		Step Mean

			-
				A step mean is the average state of a node used in ASNP across a sequence of steps.

				The use of a step mean to select an element from a set is referred to as mean
				selection.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 2 - Algorithms: 1 - Conventions: 1 - Methods: 2 - Fields: 1 - AI: 3 - Models: 2 - NN: 1 - Methods: 2 - ATNP'

Atypical Neural Parameters

	Philosophy

		-
			Atypical neural parameters (ATNP), are connection parameters relevant to ASNP, which
			may be used and trained in addition to weights and biases.
		-

	Principles

		Data

			Parameters

				Charge

					Charge Potential

						-
							The charge potential is how much to add or subtract from the state of a
							given neuron during a step in ASNP.
						-

					Charge Factor

						-
							The charge factor is how the charge potential should correlate to the
							current state of the neuron.
						-

				Transfer-Relay Ratio
				
					-
						The transfer-relay ratio is how much of the state should be retained within
						a neuron after said state has been relayed across said neuron's connections
						in a given step.
					-

				Threshold

					Minimum

						-
							The minimum threshold is the lowest a neuron's state can be while still
							being active in ASNP.
						-

					Maximum

						-
							The maximum threshold is the highest a neuron's state can be while
							still being active in ASNP.
						-

			States

				Heat

					-
						The heat of a connection is a value which increases or decreases as data is
						passed through said connection, to a degree derived from the size of the
						numbers passed to it.

						It may be used in correlation testing.
					-

		Conventions

			Activations

				-
					Ideally, ATNP should be implemented in the form of activation functions applied
					to the nodes and edges of the network.

					Ideally, said activation functions should themselves be trainable. Such
					functions may be referred to as dynamic activation (DA) functions.
				-

			Reflective Agents

				-
					Reflective agents are entities that monitor the state of a model, generating
					and recording metadata in the process, and train it according to said state and
					metadata.
				-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 2 - Algorithms: 1 - Conventions: 1 - Methods: 2 - Fields: 1 - AI: 3 - Models: 2 - NN: 2 - FFNN'

Freeform Neural Network

	Philosophy

		-
			A freeform neural network, or FFNN, is a neural network where any node may connect to
			any other node, and where all nodes are MPNs.
		-

	Principles

		Processing

			ASNP

				-
					By design, FFNNs should use ASNP, though the usage of them may span fixed
					cycles with defined endpoint criteria.
				-

			Training

				Linearization

					-
						An FFNN cycle may be linearized by converting the beginning and end of each
						step within it into a layer in a feed forward neural network, the end of
						one step being the start of the next.
						
						In a linearized FFNN cycle, nodes and connections may repeat as entangled
						elements throughout the network.
						
						Once in this format, the linearized FFNN cycle may be trained using some
						variation of backpropagation, after which a newly trained FFNN model may be
						reconstructed from the trained linearized FFNN cycle. This process is
						called linearized training.
					-

				Backfeeding

					-
						Backfeeding is a process for training an FFNN.

						The process shall begin by assigning the model's performance a feedback
						score, ranging from negative one to positive one, inclusive, selecting a
						set of neurons to begin the process at, ideally those serving as the output
						locations of the behavior being trained, and selecting a number of steps
						for the process to last over as a function of the number of neurons in the
						model, with the default method being to take the natural log of said number
						and square it.

						The process shall begin with the feedback score being passed to the
						selected neurons, after which said scores shall propagate backwards through
						the model in the manner of ASNP steps, altered by the weights, properties,
						and activation functions they pass through in the same manner as any other
						data, for the selected number of steps.

						Depending on the exact variant of backfeeding used, the weights and
						properties of the connections passed through may be altered as a function
						of the score values following each step. The standard method is to take the
						score value in a neuron after each step and multiply the weight of any
						outward connections of said neuron by said score value.

						As opposed to executing backfeeding over a finite number of steps, constant
						backfeeding may also be used, where feedback scores are constantly being
						passed to output nodes, and propagating backwards through the model,
						training it parallel to its usage.
					-

			Zero Augmentation

				-
					An FFNN may be grown using a modified form of zero augmentation, where a new
					node is added to the network and connected to other nodes arbitrarily, with all
					of the new parameters created from the addition of said node and its
					connections are set to zero.
				-

		Applications

			XNN

				-
					A cross neural network, or XNN, is an FFNN where the network is a dual absolute
					graph.
				-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 2 - Algorithms: 1 - Conventions: 1 - Methods: 2 - Fields: 1 - AI: 3 - Models: 3 - AGI'

AGI

	Philosophy

		-
			An XNN with ATNP properties and noisy permanent constant input, and trained using
			correlation training fed by noise feedback, which may be called an X-CAT, may be the
			ideal architecture for an AGI.

			Alternatively, an HNMS (ideally an HGNMS) would also be a prime AGI candidate.
		-

	Principles

		Sentience

			-
				It may be possible for an AGI to be made sentient if implemented in an analog form
				and made subject to non-deterministic factors, which may involve the integration of
				quantum computing elements.
				
				If implemented in a classical computing environment however, it should be assumed
				that the model is not sentient.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 2 - Algorithms: 1 - Conventions: 2 - Algorithms: 1 - Cryptography: 1 - Krypto X'

Krypto X

	Philosophy

		-
			The Krypto X algorithm is a text encryption algorithm.
		-

	Principles

		Conventions

			Cycling

				-
					Cycling refers to the process of repeating the encryption process on the text
					for a fixed number of iterations called the cycle count.

					Constant cycling refers to a cycling process where the same algorithm is used
					for every iteration, and alternating cycling refers to a cycling process where
					different algorithms may be used for each iteration. The algorithm or
					algorithms used for each cycle are referred to as cycle algorithms.

					Static cycling refers to a cycling process where the whole key is used for
					every cycle, and dynamic cycling refers to a cycling process where different
					parts of the key may be used for different cycles.
				-

			Key Cycling

				-
					A key cycling algorithm is a type of dynamic alternating cycling algorithm.

					The cycle count of a key cycling algorithm is determined by taking the average
					of all of the numerical values of the characters in the key, minus the smallest
					character value in the key times its length, and adding the result to a fixed
					number called the default count.

					The possible cycle algorithms that a key cycling algorithm may use for its
					cycles shall be arranged in a specific order.

					Ideally, the cycle algorithms should include at least one substitution cipher
					and one transposition cipher.

					For each cycle, a counter called the key counter shall iterate through the
					characters of the key, and a counter called the cycle counter shall loop
					through the list of cycle algorithms, with each counter looping back to the
					beginning of its respective item after reaching its end.

					The index of the cycle counter shall determine the cycle algorithm used for
					that cycle, which shall be executed with the key.
					
					Following each cycle, the key shall be replaced with a new key, generated by
					taking the character of the prior key at the index of the key counter and
					running said prior key through a Caesar cipher with said character as the key
					to said Caesar cipher.
				-

		Krypto X

			-
				Krypto X is a key cycling algorithm where the default count is one hundred, the
				first cycle algorithm is the Vigenère cipher and the second cycle algorithm may be
				any transposition cipher.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 2 - Algorithms: 1 - Conventions: 3 - Standards: 1 - Tasks: 1 - Context Module'

Context Module

	Philosophy

		-
			A context module is a value within a given process which acts as a reference point to a
			set of data relevant to a given context within said process.
		-

	Principles

		Context Module Map

			-
				A context module map is a map of context modules, where each context module in said
				map is assigned a unique string ID.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 2 - Algorithms: 1 - Conventions: 3 - Standards: 1 - Tasks: 1 - Context Module: 1 - Context Session'

Context Session

	Philosophy

		-
			A context session is a record kept by a process of the state of a given external
			entity's activities with regards to said process.
		-

	Principles

		Conventions

			-
				A context session shall be identified by a unique string ID.

				A new context session may be requested by an external entity, in which case the
				process hosting said session shall return the unique string ID of the session,
				after which said entity may use said ID to identify said session.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 2 - Algorithms: 1 - Conventions: 3 - Standards: 1 - Tasks: 2 - Bottleneck Parallax'

Bottleneck Parallax

	Philosophy

		-
			When multiple processes are iterating on shared threads, processes that take less time
			to execute may iterate multiple times to make up for time lost to more intensive
			processes which act as bottlenecks on said threads, according to an ideal tick rate for
			each process running on said threads.

			This process can be called bottleneck parallax.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 2 - Algorithms: 1 - Conventions: 3 - Standards: 1 - Tasks: 3 - Recycling Iteration'

Recycling Iteration

	Philosophy

		-
			Recycling iteration is when a function that is executed repeatedly returns a value,
			called a recycled value, which is passed to it as an argument in the next iteration.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 2 - Algorithms: 1 - Conventions: 3 - Standards: 1 - Tasks: 4 - Argument Reference Channel'

Argument Reference Channel

	Philosophy

		-
			An argument reference channel is an alias passed to its application through its
			arguments which specifies a channel through which to communicate with external
			entities.
		-

	Principles

		WARC

			-
				A WARC (Web Argument Reference Channel), is an argument reference channel for web
				applications.

				A WARC uses a URL argument with the alias "WARC" (case insensitive) to specify a
				JSON array of string aliases for values in local storage which it may use to
				communicate with applications that share the same domain, whether it is operating,
				in a different window or in an iframe.

				The standard form of said values is the stringified form of a JSON object which
				contains two string fields: "incoming", to be modified by external entities, and
				"outgoing", to be modified by the application to which the WARC applies.

				WARCs may be used as a method for multitasking by enabling communication across
				multiple windows, in addition to web workers.
			-

		Static Reference Channel

			-
				A static reference channel is a mechanism through which an application can access
				updates to itself.

				A static reference channel consists of a server hosted at a static address which
				assigns an ID to each application it hosts updates for, and which allows developers
				of said applications to change the update assigned to a given ID.

				Said updates shall consist of plain text files, which may be interpreted as needed.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 2 - Algorithms: 1 - Conventions: 3 - Standards: 1 - Tasks: 5 - Default Value Conventions'

Default Value Convention

	Philosophy

		-
			The default value convention holds that the default value for a primitive is whatever
			value a binary value of zero corresponds to, and that the default contents of a
			construct or collection are empty.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 2 - Algorithms: 1 - Conventions: 3 - Standards: 2 - UI: 1 - Omnievent'

Omnievent

	Philosophy

		-
			An omnievent is a function that triggers whenever any external input is detected by a
			given application.

			Omnievents can be used to bypass certain restrictions in certain operating
			environments.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 2 - Algorithms: 1 - Conventions: 3 - Standards: 2 - UI: 2 - Standard UI Conventions'

Standard UI Conventions

	Philosophy

		-
			The standard UI conventions are a set of conventions for handling GUIs and user
			input in applications.
		-

	Principles

		GUI

			2D Central Dimensions

				-
					Under the standard UI conventions, the dimensions of 2D GUI items are to be
					specified according to a coordinate system where the center of the reference
					area is the origin and the edges of the reference area are positive or negative
					one.

					If an aspect ratio is to be maintained, the smaller of the reference area
					dimensions, those being the width and the height, shall define a measurement of
					two units which shall apply to both dimensions.

					3D properties may be applied to 2D objects for pseudo-3D effects.
				-

			Transforms

				-
					Under the standard UI conventions, the position, orientation, and size of GUI
					items are to be specified using a stacked series of transforms, which shall
					include translations, rotations, and scales.
					
					Translations and scales are to be defined using 3D vectors, 2D rotations are to
					be defined using either scalars that represent rotation on the Z axis for
					normal 2D rotation, or quaternions for pseudo-3D effects, and 3D rotations are
					to be defined using quaternions.
				-

			Standard Asset Size

				-
					The default size of any object should be defined such that, in keeping with its
					default proportions, the vector defined by its lengths in all relevant
					dimensions should have a magnitude of one.
				-

		Input

			-
				Under the standard UI conventions, there is to be a global index specifying the
				current positions and held buttons of all input devices.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 2 - Algorithms: 1 - Conventions: 3 - Standards: 2 - UI: 3 - Pre-Render Protocol'

Pre-Render Protocol

	Philosophy

		-
			A pre-render protocol is a protocol for real-time audiovisual applications where, for
			each frame rendered, the image and sound are recorded, and then compiled into a video
			or audio track according to a pre-specified framerate.
		-

	Principles

		Kaeon ACE

			-
				Pre-render protocols may be used in conjunction with Kaeon ACE to produce
				pre-rendered audiovisual media.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 2 - Algorithms: 1 - Conventions: 3 - Standards: 2 - UI: 4 - XR Overlay Entity'

XR Overlay Entity

	Philosophy

		-
			An XR overlay entity is a virtual entity that directly corresponds to a physical
			entity, which may be used to take the place of said physical entity in a cross reality
			simulation if said physical entity is absent, and to act as a digital twin of said
			entity for other purposes as needed.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 2 - Algorithms: 2 - Architecture: 1 - Kaeon Architecture'

Kaeon Architecture

	Philosophy

		-
			Kaeon Architecture is a system for constructing modules in a manner that maximizes
			modularity and fault tolerance.

			A module designed using the Kaeon architecture is referred to as a Kaeon module.
		-
	
	Principles

		Utilities

			-
				Utilities are functions and modules that are publicly available and statically
				accessible.
			-

		Processes

			-
				Processes are persistently running modules that serve solely to govern the calling
				of functions within utilities.
			-

		Network

			-
				A module designed using the Kaeon architecture is formed of a group of modules
				connected together in a Philosopher's Atlas.
			-

		Data

			-
				All data stored by a module designed using the Kaeon architecture should be stored
				in internal or external databases that are globally accessible to the utilities.
			-

		Layers

			-
				The network of a module designed using the Kaeon architecture shall be separated
				into two sections: the application layer for processing the internal logic of the
				module, and the interface layer for communicating with external modules.
			-

		Core

			-
				The network of a module designed using the Kaeon architecture may have a single
				module placed between the application layer and the interface layer of the network
				known as the core module, which if present shall serve as a reference point for the
				whole module.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 2 - Algorithms: 2 - Architecture: 2 - FUSION Interpreter Architecture'

FUSION Interpreter Architecture

	Philosophy
	
		-
			The FUSION interpreter architecture dictates the ideal way to implement FUSION using a
			Philosopher's Atlas.
		-
	
	Principles
	
		FUSION Core

			Philosophy
			
				-
					A FUSION core is a standard module that manages the FUSION process. It will
					have the tag "FUSION", and will contain a boolean flag called "running" that
					indicates whether the process or internal process functions are currently
					running.
				-

			Principles
				
				On Call
				
					Update
					
						-
							If a FUSION core receives a packet with the string "Update" as its
							first element, it will scan the Philosopher's Atlas to see if any
							FUSION units have been added or removed.
						-
				
					Stop
					
						-
							If a FUSION core receives a packet with the string "Stop" as its first
							element, it will stop the process and internal process functions if
							either of them are running.
						-
				
				Functions
				
					Process
					
						-
							The process function takes a ONE element as an argument, sets the
							running flag to true, calls the internal process function using the
							passed in element and the boolean true, then flushes the state and sets
							the running flag to false.
						-
				
					Internal Process
					
						-
							The internal process function takes a ONE element and a boolean value
							that signifies whether it was called from the process function or not
							as arguments, sets the running flag to true, and performs the FUSION
							process on the passed in element. The internal process function should
							prevent itself from crashing in the event that any of the FUSION unit
							functions crash.
						-
				
					Tick

						-
							The tick function takes an object containing the current state of a
							FUSION process, performs a single iteration of said process, updating
							said state accordingly, and then returns said state.
						-

					Get Threads

						-
							The get threads function returns the root elements of all threads
							currently being processed, which shall have fields containing the
							metadata for said threads.
						-

					Get Thread

						-
							The get thread function takes an element and returns its nearest
							ancestor currently being processed as a thread.
						-

					Add Thread

						-
							The add thread function takes an element to begin processing in a new
							thread using the fusion process.
						-

					Set Thread

						-
							The set thread function takes an element and a boolean, pausing the
							thread that said element is being processed on if said boolean is true,
							and unpausing it if false.
						-

					Remove Thread

						-
							The remove thread function takes an element and terminates the thread
							processing said element.
						-

					Push Thread

						-
							The push thread takes two elements, and pushes the second element as a
							subroutine onto the stack of the thread currently processing the first
							element.
						-

					Pop Thread

						-
							The pop thread takes two elements, and pushes the second element as a
							subroutine onto the stack of the thread currently processing the first
							element.
						-
		
		FUSION Unit

			Philosophy
				
				-
					All FUSION commands, along with certain other functionality should be
					implemented as FUSION Units, which are standard Philosopher's Stones and
					attached to the Philosopher's Atlas containing the relevant FUSION cores.
					
					They shall have the tag "FUSION Unit".
				-

			Principles
			
				Functions
				
					Deny
					
						-
							The deny function is the first function to be called when acting upon
							an element.
							
							It takes a ONE element signifying the element that FUSION is currently
							acting upon as an argument and returns a boolean that if true will
							prevent all other FUSION units from acting on this element until FUSION
							has moved to a different element.
							
							It returns false by default.
						-
				
					Verify
					
						-
							The verify function is the second function to be called when acting
							upon an element.
							
							It takes a ONE element signifying the element that FUSION is currently
							acting upon as an argument and returns a boolean that if false will
							prevent the FUSION unit it belongs to from acting on the passed in
							element until FUSION has moved to a different element.
							
							It returns false by default.
						-
					
					Trickle Down
					
						-
							The trickle down function is the third function to be called when
							acting upon an element.
							
							It takes a ONE element signifying the element that FUSION is currently
							acting upon as an argument and returns a boolean that if false will
							prevent FUSION from trickling down to the element's children.
							
							It returns true by default.
						-
					
					Process
					
						-
							The process function is the fourth function to be called when acting
							upon an element.
							
							It takes a ONE element signifying the element that FUSION is currently
							acting upon and a list of objects generated by performing the same
							function on the element's children as arguments, and returns an object.
							
							It returns null by default.
						-
					
					Terminate
					
						-
							The terminate function is the fifth function to be called when acting
							upon an element.
							
							It takes a ONE element signifying the element that FUSION is currently
							acting upon and a list of objects generated by performing the same
							function on the element's children as arguments, and returns a boolean
							that if true will stop the FUSION process.
							
							It returns false by default.
						-
					
					Is Added
					
						-
							The is added function is the sixth function to be called when acting
							upon an element.
							
							It takes a ONE element signifying the element that FUSION is currently
							acting upon and a list of objects generated by performing the same
							function on the element's children as arguments, and returns a boolean
							that if false will prevent the object generated by the process function
							from being placed into the list of objects that will be used as an
							argument for the process function when FUSION bubbles up to the
							element's parent.
							
							It returns true by default.
						-
					
					Jump
					
						-
							The jump function is the seventh function to be called when acting upon
							an element.
							
							It takes a ONE element signifying the element that FUSION is currently
							acting upon and a list of objects generated by performing the same
							function on the element's children as arguments, and may either return
							a ONE element, in which case the FUSION process will jump to said
							element, or a null value.
							
							It returns null by default.
						-
					
					Handle Error
					
						-
							The handle error function will only be called if any of the other
							functions encounter an error.
							
							It takes a ONE element signifying the element that FUSION is currently
							acting upon and a list of objects generated by performing the same
							function on the element's children, and an error message as arguments.
							
							It does not return a value.
						-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 2 - Algorithms: 2 - Architecture: 3 - Kaeon ACE Interface Architecture'

Kaeon ACE Interface Architecture

	Philosophy
	
		-
			A Kaeon ACE Interface is a middleware application that interprets a Kaeon ACE document
			and renders its content to a specific platform.
		-
	
	Principles

		Platforms

			-
				Given the nature of Kaeon ACE documents, the platforms that Kaeon ACE is rendered
				to will usually be game engines.
			-

		Philosopher~'s Atlas

			-
				A Kaeon ACE Interface will be embedded into a Philosopher's Atlas running within
				the platform that the content is being rendered to.
			-

		Core

			-
				A Kaeon ACE interface shall store a "core" object which shall serve as a bus to
				various parts of the interface.

				It shall contain, among other things, an object representation of the component
				entity tree described by the source document, as well as references to key
				components of the host platform and to the Philosopher's Atlas in which the
				interface is embedded.

				It shall itself be a node within the Philosopher's Atlas that the interface is
				embedded within.
			-

		Modules

			-
				The functionality of a Kaeon ACE interface shall be embedded within nodes, called
				Kaeon ACE modules, connected to the Philosopher's Atlas in which said interface is
				embedded.

				Each module shall have the tag "Kaeon ACE".

				Each module may have any combination of the Kaeon ACE module functions.
			-

		Entity Object

			-
				An entity object shall contain two lists, one being a list of its child entity
				objects, and the other being a list of its component objects, which may be of any
				type, and shall contain a reference to its parent entity.

				The core node shall contain a reference to an entity object which shall serve as
				the root of the engine's entity tree.
			-

		Module Functions

			On Call

				-
					The on call function takes the core node and a string as arguments.

					It may perform any action based on its arguments and may either return a string
					or a null value.

					By default, the string should be a ONE+ document.

					It may be called manually at any time.
				-

			On Default

				-
					The on default function takes the core node as an argument.

					It is called when the engine first detects the module's presence and may
					perform any operation.
				-

			On Deserialize

				-
					The on deserialize function takes the core node, a ONE element that corresponds
					to a Kaeon ACE component, and an entity object as arguments.

					It is called when the engine deserializes the source Kaeon ACE document for
					each component element, where said component element is the passed in ONE
					element, and may perform any operation and modify the content of the entity
					object, which corresponds to the entity that the component belongs to.
				-

			On Entity

				-
					The on entity takes the core node, an entity object, and a time delta value as
					arguments.

					It is called once per engine tick for every entity in the entity tree, where
					said entity is the passed in entity object, and where the passed in time delta
					value is the time that has passed since the last engine tick.
				-

			On Serialize

				-
					The on serialize function takes the core node and a component object as
					arguments.

					It may be called manually at any time, and shall either return a Kaeon ACE ONE
					representation of said object in ONE list form, or shall return a value of
					null.
				-

			On Update

				-
					The on entity takes the core node and a time delta value as arguments.

					It is called once per engine tick, where the passed in time delta value is the
					time that has passed since the last engine tick.
				-

		Actions

			Calling

				-
					To call a Kaeon ACE interface is to take a string and to pass it to the on call
					function in every Kaeon ACE module in said interface, and to return all of the
					strings returned by said calls as a list.
				-

			Serializing

				-
					To serialize a Kaeon ACE application is to take every entity in its entity tree
					the their components and to render their properties to a Kaeon ACE document
					such that if said document were used as the source for another Kaeon ACE
					application, it would produce the same application with the properties of the
					serialized application at the time it was serialized.
				-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 2 - Algorithms: 3 - Applications: 1 - Utilities: 1 - Online: 1 - APIs: 1 - Minimal API'

Minimal API

	Philosophy

		-
			A minimal API is a service that receives HTTP and HTTPS requests, and performs tasks
			and returns data based solely on the content of the request's URL.
		-

	Principles

		Default Header

			-
				By default, requests to minimal APIs should use GET headers, though effects of said
				requests may be anything.
			-

		Minimal API Wrapper

			-
				A minimal API wrapper is a utility that automatically handles tasks that require
				multiple minimal API calls.

				This may be necessary in cases involving encryption or where large amounts of data
				need to be exchanged.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 2 - Algorithms: 3 - Applications: 1 - Utilities: 1 - Online: 1 - APIs: 2 - Shadow Proxy'

Shadow Proxy

	Philosophy

		-
			A shadow proxy is a CORS proxy that allows users to specify all aspects of an HTTP
			call to send as well as any modification to make to its response solely through its
			URL.

			It shall accept said URLs as GET requests and shall not require any specific headers.
		-

	Principles

		Standard Format

			-
				The standard format for a shadow proxy URL requires no subdomains and contains the
				URL argument "request", and may optionally contain the URL argument "response".

				The request argument shall specify the request to be sent in raw HTTP format.

				The response argument, if present, shall specify a JSON array containing a list of
				JSON objects specifying modifications to be made to the response.
				
				Each of said objects shall have a "type" field containing a string specifying the
				type of modification to be performed, and may optionally have a "data" field, which
				may have any content.

				The URL argument aliases and the content of the "type" field in the response
				modification objects are case insensitive.
			-

		Standard Response Modifications

			Set Header

				-
					The set header modification shall have the type "Set Header", and its data
					field shall contain a string specifying a raw HTTP header.
					
					It shall either add said header to the response or overwrite it.
				-

			Encode

				-
					The encode modification shall have the type "Encode", and shall have no data
					field.
					
					It shall modify the string of the body to be JavaScript code that writes the
					original body string as a string to a global reference.
				-

		Restrictions

			-
				The proxy should not permit recursive requests to itself.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 2 - Algorithms: 3 - Applications: 1 - Utilities: 1 - Online: 1 - APIs: 3 - Devops API'

Devops API

	Philosophy

		-
			A devops API is an API to which a developer may pass the source files of a project,
			which said API shall compile the build for, after which it may return said build to the
			user, deploy said build to production, or both.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 2 - Algorithms: 3 - Applications: 1 - Utilities: 1 - Online: 1 - APIs: 4 - Open Host'

Open Host

	Philosophy

		-
			An open host is a server that accepts external submissions for processes to host within
			itself.
		-

	Principles

		Operations

			Features

				Contexts

					-
						An open host may store context modules using a context module map.
					-

				Processes

					-
						An open host may run subroutines specified in user submissions at regular
						intervals.

						Said subroutines should have certain restrictions placed on them so as to
						avoid security issues.
					-

				Routes

					-
						An open host may execute functions which take HTTP requests and return HTTP
						responses when said open host is queried by an end user with certain types
						of HTTP requests as specified by user submissions.
					-

			Format

				Management

					Submissions

						-
							A submission to an open host shall consist of a GET request with the
							URL arguments "type" and "source".

							The type argument shall contain either the string "process" or the
							string "route", for a process or route submission respectively.

							The source argument shall contain a file path linking to a text file
							containing JavaScript code.
							
							For a process submission, said code shall contain the body of a
							function which takes a context utility object and a recycled value, and
							returns a recycled value, to execute as often as possible given the
							server's resources.

							For a route submission, said code shall contain the body of a function
							which takes an HTTP JSON object representing an HTTP request, and a
							context utility object, and returns an HTTP JSON object representing an
							HTTP response.

							A context utility object shall have a create context function, which
							creates a new context module in the form of an empty JavaScript object,
							and returns a unique string ID to identify said object, and a get
							context function, which takes a the string ID of a context object
							created by the create context function, and returns the corresponding
							context module.

							Context modules may be deleted by an open host if too much time has
							passed without them being used.

							A route submission may optionally have an additional URL argument
							called "route", which may contain a string with which to uniquely
							identify said route.

							A JSON object shall be returned in string form in the response body.

							Said object shall contain a field with the alias "id", containing a
							unique string id with which to identify the submission, called the
							submission ID.

							For a route submission, said object shall contain a field with the
							alias "route", containing a string with which to access said route as
							an end user, called the route ID.

							If a route is submitted with a route argument that is not currently in
							use for another route, its route ID shall be as specified in said
							argument, and shall otherwise be randomly generated.
						-

					Deletions

						-
							A submission may be deleted from an open host with a GET request
							containing a URL argument with the alias "delete", containing the
							submission ID of the submission to be deleted.
						-

				Route Access

					-
						A route may be accessed by an end user with a GET request containing a URL
						argument with the alias "access", containing the route ID of the route to
						be accessed.
					-

		Conventions

			Standards

				-
					A conventional open host shall be publically available and shall accept
					anonymous submissions for free.

					An open host may be initiated with certain processes and routes already active
					by default.
				-

			Common Open Host

				-
					A common open host is an open host server that also operates as a conventional
					common cache server.
				-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 2 - Algorithms: 3 - Applications: 1 - Utilities: 1 - Online: 1 - APIs: 5 - Aether Host'

Aether Host

	Philosophy

		-
			An aether host is a server which hosts containerized applications, and which may
			connect to other aether hosts to coordinate the container orchestration of a collection
			process in a decentralized manner according to the contents of a collection document. A
			network of aether hosts may be referred to as a host atlas.

			As such, aether hosts may spawn other aether hosts and terminate themselves as needed,
			and any aether host may serve as an interface to its host atlas, through which the
			collection document may be updated and retrieved, along with other metadata regarding
			said host atlas.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 2 - Algorithms: 3 - Applications: 1 - Utilities: 1 - Online: 2 - Bots: 1 - Conventions: 1 - Bot Flare'

Bot Flare

	Philosophy

		-
			A bot flare is a method of formatting publicly accessible content such that bots may
			act on it in a certain way when they encounter it.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 2 - Algorithms: 3 - Applications: 1 - Utilities: 1 - Online: 2 - Bots: 2 - Services: 1 - Search: 1 - Scout'

Scout Bot

	Philosophy

		-
			A scout bot is a web scraper bot designed to use existing search engines in order to
			gather information on a given topic and produce analytics on it.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 2 - Algorithms: 3 - Applications: 1 - Utilities: 1 - Online: 2 - Bots: 2 - Services: 1 - Search: 2 - Report'

Report Bot

	Philosophy

		-
			A report bot is a bot that manages scout bots and uses information gathered and
			produced by them to generate qualitative reports on a given topic.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 2 - Algorithms: 3 - Applications: 1 - Utilities: 1 - Online: 2 - Bots: 2 - Services: 1 - Search: 3 - Ops'

Ops Bot

	Philosophy

		-
			An ops bot is a bot that manages report bots and uses reports generated by them in
			order to automate other tasks.
		-

	Principles

		Ops Bot Net

			-
				An ops bot net is a network of ops bots designed to automate a suite of tasks while
				taking directives from external operators.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 2 - Algorithms: 3 - Applications: 1 - Utilities: 1 - Online: 2 - Bots: 2 - Services: 2 - Alarm Service'

Alarm Service

	Philosophy

		-
			An alarm service is an application that pings another application on regular intervals
			solely to keep said application from going into sleep mode.
		-

	Principles

		Alarm Service Loop

			-
				An alarm service loop is where two or more alarm services ping each other on
				regular intervals to keep each other awake.
			-

		Auto Alarm Loop

			-
				An auto alarm loop is where a service pings itself on regular intervals to keep
				itself awake.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 2 - Algorithms: 3 - Applications: 1 - Utilities: 1 - Online: 2 - Bots: 3 - SOUL Bot'

SOUL Bot

	Philosophy

		-
			A SOUL bot is a process which contains an AI model that can autonomously govern tasks
			executed by the process, taking user input into account but neither requiring it nor
			being bound to it.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 2 - Algorithms: 3 - Applications: 1 - Utilities: 2 - Management: 1 - Bootstrap'

Bootstrap Process

	Philosophy

		-
			A bootstrap process is an application which may execute other applications as specified
			by the user, which it may externally control and monitor during their execution.
		-

	Principles

		Bootstrap Subjects

			-
				The applications specified by a user for a bootstrap process to control and monitor
				are referred to as the bootstrap subjects of said bootstrap process.
			-

		Modular Bootstrap Process

			-
				A modular bootstrap process is a bootstrap process for which its functionality is
				extensible via plugins.
			-

		Persistent and Static Bootstrap Processes

			-
				A persistent bootstrap process is a bootstrap process which runs persistently and
				may take directives from the user at any time to manage plugins or bootstrap
				subjects.

				A static bootstrap process is a bootstrap process which takes all relevant user
				specifications at startup, and runs only until its bootstrap subjects terminate.
			-

		General Bootstrap Process

			-
				A general bootstrap process is a bootstrap process that is both modular and static.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 2 - Algorithms: 3 - Applications: 1 - Utilities: 2 - Management: 1 - Bootstrap: 1 - Auto-Versioner'

Auto-Versioner

	Philosophy

		-
			An auto-versioner is a bootstrap process that can be manually set to, or to not, check
			for updates to its bootstrap subjects, and to install said updates if they are
			available.

			After this, it shall start its bootstrap subjects.

			An auto-versioner may also be used to manually set said application to a different
			version.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 2 - Algorithms: 3 - Applications: 1 - Utilities: 2 - Management: 2 - JSH Package'

Conventional JSH Package

	Philosophy

		-
			A conventional JSH package is a conventional server package for which the API processes
			JSH requests when submitted in the bodies of POST requests.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 2 - Algorithms: 3 - Applications: 1 - Utilities: 2 - Management: 2 - JSH Package: 1 - JSH Plugin'

JSH Plugin

	Philosophy

		-
			A JSH plugin is a browser plugin that shall ensure that a conventional JSH package
			instance is running on the client machine for each port defined in its settings, unless
			other applications already occupy said ports.
		-

	Principles

		Security

			-
				Every time a user navigates to a page, the instance shall require the page to ask
				permission before said page shall be allowed to send any HTTP request to the ports
				defined in its settings.
			-

		Defaults

			-
				The default ports for the instance to initialize a server consist solely of the
				port 80.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 2 - Algorithms: 3 - Applications: 1 - Utilities: 2 - Management: 3 - Standard Command'

Standard Command

	Philosophy

		-
			The standard command convention is a convention for commands.

			The first argument following the name of the executable is the name of the operation,
			and every following argument is referred to as a standard argument.

			To dynamically specify source text to the operation, the first standard argument must
			be "read", and the second standard argument must be said text itself.

			To load the source text to the operation from a file, the first standard argument must
			be "open", and the second standard argument must be the file path.

			To save the output of the operation to a file, there must be a third standard argument
			specifying the path of said file.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 2 - Algorithms: 3 - Applications: 1 - Utilities: 3 - Monitoring: 1 - Game Recorder'

Game Recorder

	Philosophy

		-
			A game recorder is a module for a game engine that, while a game engine is running a
			game, records each rendered frame as an image.

			As such, the scene's physics and scripts should be updated at a fixed rate per rendered
			frame.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 2 - Algorithms: 3 - Applications: 2 - Simulations: 1 - GOUS'

The General Open Universe Standard

	Philosophy

		-
			The general open universe standard, or GOUS for short, specifies a general standard for
			populating an open universe with both procedurally generated and manually constructed
			content.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 2 - Algorithms: 3 - Applications: 2 - Simulations: 1 - GOUS: 1 - Core'

Open Universe Core

	Philosophy

		-
			This document specifies the core principles of the general open universe standard.
		-

	Principles

		Global Values

			Core Seed

				-
					The core seed is the number used to seed the algorithm responsible for
					generating the procedurally generated content of the simulation.

					In line with the default value conventions, if no core seed is specified, it
					shall be set to zero.
				-

			Universal Time

				-
					The universal time is the amount of time that has lapsed since the big bang
					relative to a hypothetical point in space where the rate at which time passes
					has remained constant.
				-

		Entities

			Types

				Independent Entities

					-
						An independent entity is generally defined as any entity that a human could
						escape the gravitational pull of by jumping.
					-

				Celestial Entities

					-
						A celestial entity is generally defined as any entity that a human could
						not escape the gravitational pull of by jumping.
					-

				Cluster Entities

					-
						Groups of entities that act as singular units shall be referred to as
						cluster entities.
					-

				Cosmic Entities

					-
						Cluster entities and celestial entities can collectively be referred to as
						cosmic entities.
					-

			Relations

				Parent-Child Relations

					-
						A cosmic entity that sits within a cluster entity or orbits a celestial
						entity shall be a child of the entity to which it is bound.
					-

				ID

					-
						All cosmic entities, save for the universe, shall have a unique numerical
						ID relative to their immediate siblings, and the universe shall have an ID
						of zero.
					-

				Dependent Cosmic Entities

					-
						A dependent cosmic entity is any cosmic entity that descends from a
						celestial entity via parent-child connections.

						All other cosmic entities shall be referred to as independent.
					-

			Properties

				All

					Position

						-
							The position of the center of a cosmic entity, save for the universe,
							shall be defined relative to its parent.
						-

					Tilt

						-
							Each cosmic entity, save for the universe, shall have an axis along
							which it is tilted relative to its parent.
						-

				Cluster Entities

					Dimensions

						-
							The dimensions of a cluster entity may either be defined as a point or
							a path.

							If it is defined as a point, it shall be spherical and must have its
							diameter defined.

							If it is defined as a path, it must have its width defined at each
							point on said path.
						-

				Celestial Entities

					All

						Mass

							-
								Each celestial entity shall have a mass property.
							-

						Diameter

							-
								Each celestial entity shall have a diameter property.
							-

					Dependent

						Orbit

							Path

								-
									Each dependent celestial entity shall have a tilted ellipse
									that defines the path of its orbit around its parent.
								-

							Speed

								-
									Each dependent celestial entity shall also have its average
									orbital speed defined.
								-

							Start

								-
									Each dependent celestial entity shall have the point along its
									orbital path, where it is located where no time has passed
									according to the universal time, defined.
								-

						Rotation

							-
								Each dependent celestial entity shall have the speed at which it
								rotates defined.
							-

		General Coordinate System

			-
				The general coordinate system shall be used to define the exact location of content
				within the simulation.

				It shall define the position of objects on a three dimensional cartesian coordinate
				system, with its origin set at the center of the resulting grid.
			-

		Relative Coordinate Systems

			-
				A relative coordinate system is a system that may be used to define the position of
				objects relative to a given entity.
			-

		Generation

			-
				After certain entities have been placed into the simulation manually, procedural
				content shall be generated according to the core seed.
				
				The positions of celestial entities within the simulation should be determined by
				the universal time value.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 2 - Algorithms: 3 - Applications: 2 - Simulations: 1 - GOUS: 2 - Standards: 1 - Dimensions'

Open Universe Dimensions

	Philosophy

		-
			This document specifies how the coordinate systems and entity properties defined in the
			open universe core shall be defined.
		-

	Principles

		Coordinates

			Universal Time

				-
					The universal time shall be defined in seconds.
				-

			General Coordinate System

				-
					Points on the axes of the general coordinate system shall be defined in light
					years.
				-

			Relative Coordinate Systems

				Standard Relative Coordinate System

					-
						The standard relative coordinate system is a relative coordinate system
						that defines points relative to a given cosmic entity by projecting a ray
						out from its center defined by a vector aligned with its tilt, and scaling
						it to a given number of meters.

						If the entity in question is a celestial entity, said point may be
						projected onto its surface, and then optionally modified from the resulting
						point.
					-

		Cosmic Entity Properties

			All

				Position

					-
						Dependent cosmic entities shall have their positions defined in meters, and
						independent cosmic entities shall have their positions defined in light
						years.
					-

				Tilt

					-
						Cosmic entity tilt shall be defined in radians on the x and z axes.
					-

			Cluster Entities

				Dimensions

					-
						Dependent cluster entities shall have their dimensions defined in meters,
						and independent cluster entities shall have their dimensions defined in
						light years.
					-

				Paths

					Types

						Points

							-
								A path used to define the form of a cluster entity may be defined
								using a sequence of points, with the path flowing from one point to
								the next in order.
								
								Each point shall have the width for the cluster entity at itself
								defined, with the width at all other points derived by
								interpolating between them.
							-

						Ring

							-
								A path used to define the form of a cluster entity may be defined
								using a ring, which shall be perfectly circular, with the radius of
								its center and its width, which shall be the same everywhere.
							-

						Spiral

							-
								A path used to define the form of a cluster entity may be defined
								using a spiral, which shall, from its position, spiral outwards,
								with its radius increasing at a specified rate per radian, and
								terminating after a specified number of radians.

								It shall have its width defined at its starting point and at its
								terminating point, and shall interpolate between them for all other
								points.
							-

					Coordinates

						-
							A path used to define a path entity shall have a starting point.

							The starting point for a points path is the first point.

							The starting point for a ring path is at zero radians relative to the z
							axis of its parent.

							The starting point for a spiral path is at the center of the spiral.

							The position of an entity within the defined cluster entity is defined
							by specifying a distance from the starting point along the path and
							by specifying the x and y coordinates of the child entity on a plane
							that intersects the path at that point.
						-

				Cloud

					-
						A cloud cluster entity may use the dimensions used to define a ring path to
						define said entity as a hollow sphere.

						The position of an entity within a cloud entity may be defined as a 3D
						cartesian point relative to its center.
					-

			Celestial Entities

				All

					Mass

						-
							Celestial entity mass shall be defined in kilograms.
						-

					Diameter

						-
							Celestial entity diameter shall be defined in meters.
						-

				Dependent

					Orbit

						Path

							-
								The orbital path of a dependent celestial entity shall have its
								tilt defined in radians on the x and z axes, and its dimensions
								specified in meters, with its length and the position of its
								length-wise center relative to the center of the parent entity on
								the z axis, as well as the position of its widest point relative to
								its length-wise center on the z axis and its width at said point.
							-

						Speed

							-
								The average orbital speed of a dependent celestial entity shall be
								defined in meters per second
							-

						Start

							-
								The starting position of a dependent celestial entity along its
								orbital path where the universal time is zero shall be defined in
								radians, projected from a unit circle to a point on the ellipse.
							-

					Rotation

						-
							The rotational speed of a celestial entity shall be defined in radians
							per second.
						-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 2 - Algorithms: 3 - Applications: 2 - Simulations: 1 - GOUS: 2 - Standards: 2 - Data: 1 - Range'

Open Universe Range

	Philosophy

		-
			The ranges of entities defined within the context of the general open universe standard
			may be used to assist in culling for optimization purposes.
		-

	Principles

		Internal Range

			-
				The internal range of a cosmic entity is the maximum distance an observer may be
				from it in order to see its children.
			-

		External Range

			-
				The external range of a cosmic entity is the maximum distance an observer may be
				from it in order to it.
			-

		Focus

			-
				The nearest cosmic entity to an observer that said observer is within internal
				range of shall be referred to as the focused entity.
			-

		Relations

			-
				The children, grandchildren, parent, and grandparent of the focused entity and
				the other immediate children of the parent and grandparent of the focused
				entity should generally be visible, but all other cosmic entities should not
				be.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 2 - Algorithms: 3 - Applications: 2 - Simulations: 1 - GOUS: 2 - Standards: 2 - Data: 2 - Modifications'

Open Universe Modifications

	Philosophy

		-
			An application that implements some but not all of the terms of the general open
			universe standard can be said to be operating on a modified open universe standard.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 2 - Algorithms: 3 - Applications: 2 - Simulations: 1 - GOUS: 3 - Entities'

Open Universe Entities

	Philosophy

		-
			This document lists the various entities generally present in a simulation operating on
			the general open universe standard.
		-

	Principles

		Independent Entities

			-
				Independent entities shall at minimum include asteroids and comets.
			-

		Celestial Entities

			-
				Celestial entities shall at minimum include stars, including red, yellow, and blue
				stars, stellar remnants such as brown dwarfs, neutron stars and black holes, gas
				giants, and terrestrial bodies, both lifeless and inhabited.
			-

		Cluster Entities

			-
				Cluster entities shall at minimum include space dust, planetary rings, planetary
				debris clouds, asteroid belts, asteroid clouds, multi-star systems, nebulae,
				interstellar clouds, interstellar bubbles, galactic arms, galactic bulges,
				galaxies, galactic clusters, galactic superclusters, and galactic filaments.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 2 - Algorithms: 3 - Applications: 2 - Simulations: 1 - GOUS: 3 - Entities: 1 - Planets'

Open Universe Terrestrial Planets

	Philosophy

		-
			This document specifies standards for defining the properties of terrestrial planets
			within an open universe as defined by the general open universe standard.
		-

	Principles

		Height Maps

			Global Map

				-
					The global height map is a spherical height map that defines the general height
					of a planet at any given location.

					The height at each point on the height map shall correspond to the radius of
					the base planet plus the point on the global map, a value between zero and one,
					multiplied by a given number of meters.
				-

			Local Maps

				-
					Local height maps define more precise height parameters than the global height
					map at specific locations on the planet, and as such shall be mapped according
					to a given width and length, specified in meters, and according to a given
					latitude and longitude, specifying its center.

					It may be normalized with the global height map to some extent.
				-

		Ocean

			Composition

				-
					If a planet has an ocean, its chemical composition may be specified in terms of
					percentages of certain elements, molecules, and microorganisms.
				-

			Level

				-
					If a planet has an ocean, its level may be specified as a given number of
					meters above the radius of the base planet.
				-

		Atmosphere

			Composition

				-
					If a planet has an atmosphere, its chemical composition may be specified in
					terms of percentages of certain elements and molecules.
				-

			Height

				-
					If a planet has an atmosphere, the length it extends off the planet may be
					specified as a given number of meters above the radius of the base planet.
				-

		Property Maps

			Static

				Terrain

					-
						A terrain map specifies the terrain properties of certain regions on the
						global map.
					-

				Volcanos

					-
						A volcano map specifies points on the global height map with active
						volcanic activity, and may also specify the extent of said activity.
					-

				Caves

					-
						A cave map specifies points on the global height map where caves are
						present, and may also specify the properties of said caves.
					-

			Dynamic

				Weather

					-
						A weather map specifies the atmospheric temperatures and cloud formations
						at certain points on the planet.
					-

				Vegetation

					-
						A vegetation map specifies the vegetation present in certain regions of the
						planet.
					-

		Landmarks

			-
				Landmarks refer to any miscellaneous structures on the planet.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 1 - Software: 2 - Algorithms: 3 - Applications: 2 - Simulations: 2 - True Flight'

True Flight
	
	Philosophy
		
		-
			True Flight is a mechanic that governs controlling a moving object in free flight.
		-
	
	Principles
		
		Basic Movement
			
			-
				An object controlled using the true flight mechanic shall be oriented according to
				a quaternion called the target, the first three elements of which shall define the
				target vector, and the last element of which shall define the target rotation.
				
				The object may move back and forth along the target vector and may pan along the
				plane for which the target vector is the normal, relative to the target rotation.

				The movement of the object will be scaled to a fixed magnitude in the case that
				multiple vectors are used to calculate its movement.
				
				The object may change which way it faces, which will redefine the target.
			-

		Avatar Control

			-
				An avatar controlled using the true flight mechanic shall be able to enable and
				disable flight.
				
				If in flight, the avatar will be able to rotate upside down.

				In the case that flight is not enabled, the avatar will not move vertically and
				will rotate so as to be perpendicular to the ground and oriented right side up.
				
				If flight is disabled, the avatar will fall to the ground. Flight may only be
				re-enabled while in the air. While on the ground, the avatar may jump. After
				jumping, flight may be re-enabled before the avatar lands.
				
				Whenever the avatar changes velocity, it should gradually accelerate or decelerate
				to the desired velocity.
				
				The same rules regarding movement that apply during flight apply while swimming in
				bodies of fluid, but unless flight is enabled, the avatar will not be able to
				re-enter the air from the fluid.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 2 - Hardware: 1 - Conventions: 1 - Formats: 1 - HAF'

Hardware Assembly Format

	Philosophy

		-
			The hardware assembly format (HAF) is a GCF standard used to describe assemblies of
			hardware, specifically electronic hardware, and the software installed on them.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 2 - Hardware: 1 - Conventions: 1 - Formats: 1 - HAF: 1 - HDF'

Hardware Description Format

	Philosophy

		-
			The hardware description format is a format for ONE documents used to describe certain
			assemblies of hardware, specifically electronic hardware, and the software installed on
			them.

			A document that abides by the hardware description format shall be called a hardware
			description document.
		-
	
	Principles

		Sections

			-
				The Principles section of a hardware description document may have any combination
				of the following elements: an element with the content "Hardware", and an element
				with the content "Software", and an element with the content "Notes".
			-

		Hardware

			-
				The hardware element shall have a child with the content "Components", and may also
				have a child with the content "Connections".
			-

		Hardware Components

			-
				The components element in the hardware section shall have a child for each physical
				component of the assembly specified by the document.
				
				The content of each child of the components element shall be its numerical index
				within its parent, starting at one. Each of said children shall have a child
				specifying the type of the component it corresponds to, referred to as a name
				element.

				If deemed necessary, a name element may have any of the following children: a child
				with the content "Provider", and an element with the content "Label", both of
				which, if present, shall have a child with content specifying the details of said
				child's parent's namesake.
			-

		Connections

			-
				The connections element may have a child for any of the connections between the
				various devices within the assembly specified by the document.

				Each of said children, called a connection element, shall specify a connection
				between two of the components listed under the components element of the hardware
				section by their indexes as specified by their content, written starting with the
				index of the first component, followed by the string " to ", followed by the index
				of the second component.

				Each connection element may have a child with content specifying additional
				information about the connection.
			-

		Software

			-
				The software element may have a child with the content "Components", and may also
				have a child with the content "Files".
			-

		Software Components

			-
				The components element in the software section may have any children specifying
				information regarding the software installed on the assembly specified by the
				document.
			-

		Files

			-
				The files element may have a child for any file installed on the assembly specified
				by the document. Each of said children shall be called a file element.

				A file element's content shall specify the purpose of the file.
				
				A file element may have any of the following children: a child with the content
				"File", which shall have a child with content that specifies the name of the file,
				a child with the content "Format", which shall have a child with content that
				specifies a the format of the file, and a child with the content "Link", which
				shall have a child with content that specifies a link to the file.
			-

		Notes

			-
				The notes element may have a child with the content "Cost", which shall have a
				child with content specifying the cost to purchase the components of the assembly
				specified by the document, and may also have an element with the content
				"Miscellaneous" which may have any children specifying additional information about
				the assembly specified by the document.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 2 - Hardware: 1 - Conventions: 1 - Formats: 2 - GPIO Pin Map'

GPIO Pin Map

	Philosophy

		-
			A GPIO pin map is a convention used to organize the pins of a GPIO device so as to
			simplify the programming of them.
		-

	Principles

		Map Types

			Output

				-
					All programmable output pins of a GPIO device shall be grouped together and
					labelled in order relative to each other based on their ordering when taking
					all pins into account, starting at zero. Said order shall be referred to as the
					output pin map.
				-

			Input

				-	
					All input pins shall themselves be grouped together in the same manner. Said
					order shall be referred to as the input pin map.
				-

			Dual

				-
					Optionally, all pins may, using the aforementioned ordering convention, be
					placed together in a single pin map referred to as a dual pin map, which may
					act as both the output pin map and the input pin map.
				-

		Pin Settings
	
			-
				The status of a pin may be set to false, indicating that it is generating no
				output, to true, indicating that it is on and set to high, or to a number between
				zero, exclusive, and one, inclusive, specifying an exact level of output.

				If a binary pin is assigned a number, its value will default to true.
			-

		Standard Microcontroller Serial Communication

			-
				The standard microcontroller serial communication is a convention used to specify
				how to control a microcontroller's functioning according to its pin map over USB
				communication.

				A microcontroller abiding by the standard shall be configured to receive signals
				in the form of binary sequences where each bit corresponds to the value to set a
				pin to on said device, where the index of the bit corresponds to the pin it maps to
				according to said device's input pin map.

				Whenever such a device receives such a signal, it shall be sent back a binary
				sequence where each bit corresponds to the current value of a pin on said device,
				where the index of the bit corresponds to the pin it maps to according to said
				device's output pin map.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 2 - Hardware: 1 - Conventions: 1 - Formats: 3 - Format Relay'

Format Relay

	Philosophy

		-
			A format relay is the use of an intermediary system to mediate communication between
			two external systems, where one of said external systems, referred to as the active
			system, sends a signal using one protocol to the intermediary system, followed by the
			intermediary system relaying the content of said signal to the other external system,
			referred to as the reactive system, using a different protocol.
		-

	Principles

		Labelling

			-
				A format relay may be labelled according to the protocols that it uses, where said
				label consists of the name of the protocol used by the active system, followed by
				the string " to ", followed by the name of the protocol used by the reactive
				system.

				A sequence of format relays may be labelled using the protocol of the first active
				system and the protocol of the last reactive system, and may be given a numerical
				order according to how many relays the sequence consists of.
			-

		Relay Moderator

			-
				A relay moderator is a format relay intermediary system which provides multiple
				options for protocols.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 2 - Hardware: 1 - Conventions: 2 - Applications: 1 - Signal Profiler'

Signal Profiler

	Philosophy

		-
			A signal profiler is an application that, through external hardware, listens for
			wireless communication passing through a given area, and then identifies distinct
			patterns in said communication, using said patterns to create possible profiles of
			devices in its assigned area, including their properties, the targets of their
			communication, and the contents of their communication.
		-

	Principles

		Applications

			-
				A signal profiler may be used to create programmable interfaces for third party
				wirelessly controlled devices for which the communication protocol thereof is not
				easily obtained.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 2 - Hardware: 1 - Conventions: 2 - Applications: 2 - Automation Engine'

Automation Engine

	Philosophy
	
		-
			An automation engine is a middleware application which serves to mediate communication
			between its host system and any sensors, actuators, or communication systems connected
			to said host according to directives specified in real time by external users and
			systems.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 2 - Hardware: 2 - Interfaces: 1 - GHI'

General Hardware Interface

	Philosophy

		-
			The General Hardware Interface (GHI) is a convention for mediating communication
			between IoT devices and control software, such that said control software can precisely
			control the exact output of said devices and can read all data collected by said
			devices in an unabridged form.
		-
	
	Principles

		Devices

			-
				A device hosting a means of communication with the control software is referred to
				as a receptor module.

				A device that is connected to a receptor module is referred to as a branch module.

				A receptor module, together with all branch modules connected to it, is referred to
				as the module cluster of said receptor module.

				Every device in a given module cluster shall have a unique ID assigned to it.

				A branch module may constitute either the entirety of a unit of hardware or
				individual modules within a unit of hardware.
			-

		Calls

			-
				A call from control software to a device through the general hardware interface
				shall be directed to a given receptor module and may include output settings for
				devices in the target receptor module's cluster, labelled according to the IDs of
				said devices.

				Each call should return data to the control software specifying the input signals
				that were received by each device at the time of said call, along with their IDs,
				device types, and current output states.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 2 - Hardware: 2 - Interfaces: 1 - GHI: 1 - Standards: 1 - GHI Format'

GHI Format

	Philosophy

		-
			The GHI format is a set of JSON formats used to relay information between devices
			through the general hardware interface.
		-

	Principles

		Branch Data

			-
				Each type of device may have its own JSON format for describing its input and
				output states respectively.

				A format used to set the output of a device is referred to as a branch output
				format, and a format used to describe the input a device receives is called a
				branch input format.
			-

		Receptor Formats

			Receptor Output Format

				-
					The receptor output format is a JSON format used to make calls to receptor
					modules.

					The receptor output format shall consist of a JSON object which may have a
					field for each module in a given receptor module's module cluster, labelled
					according to the IDs of their respective modules.

					Each of said fields shall contain an object as its value in the branch data
					output format used by the module it is targeting, which shall set the output
					state of said module accordingly.
				-

			Receptor Input Format

				-
					The receptor input format is a JSON format used to specify the current state of
					the module cluster's receptor modules.

					The receptor input format shall consist of a JSON object which may have a field
					for each module in a given receptor module's module cluster, labelled according
					to the IDs of their respective modules.

					Each of said fields shall contain an object as its value.
					
					Said object may have a field with the alias "output", which, if present, shall
					contain a value in the branch data output format used by the module it is
					generated by, which shall specify the output state of said module.
					
					Said object may also have a field with the alias "input", which, if present,
					shall contain a value in the branch data input format used by the module it is
					generated by, which shall specify the input state of said module.

					Finally, said object shall have a field with the alias "type", which shall
					contain a string specifying the device type of the corresponding module.
				-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 2 - Hardware: 2 - Interfaces: 1 - GHI: 1 - Standards: 1 - GHI Format: 1 - GHI Call Protocol'

GHI Call Protocol

	Philosophy

		-
			An HTTP request made to a receptor module using the general hardware interface format
			shall use the POST method, and its body shall consist of a stringified receptor input
			format object.
			
			It shall return a stringified receptor output format object in the body of its
			response.

			For security and accessibility purposes, the server which receives the calls should
			have a static IP and should utilize HTTPS.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 2 - Hardware: 2 - Interfaces: 1 - GHI: 1 - Standards: 1 - GHI Format: 2 - GHI JSH'

GHI JSH

	Philosophy

		-
			GHI JSH is a convention that enables the use of JSH to facilitate communication with
			the GHI by implementing the GHI as a JSH module, where the name of said module is
			"ghi", the receptor output format is said module's JSH module request schema, and the
			receptor input format is said module's JSH module response schema.
		-

	Principles

		Call Type Auto-Detection

			-
				A server supporting the GHI should auto-detect whether a call made to it uses JSH
				or the receptor input format on its own.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 2 - Hardware: 2 - Interfaces: 1 - GHI: 1 - Standards: 2 - Modules: 1 - Libraries: 1 - Sub-Modules'

GHI Sub-Modules

	Philosophy

		-
			GHI sub-modules are devices which are not directly accessible by the GHI, but which are
			controlled by devices that are directly accessible via the GHI.

			GHI sub-modules may be listed as their own devices and may have special high-level
			commands dedicated to them which allow for easier control than by manually programming
			their controller devices.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 2 - Hardware: 2 - Interfaces: 1 - GHI: 1 - Standards: 2 - Modules: 1 - Libraries: 2 - Standard Script'

GHI Standard Script

	Philosophy

		-
			A GHI standard script is a script which may be uploaded to a receptor module through
			the GHI, and which may itself enable a higher level interface atop the GHI according to
			some external standard.
		-

	Principles

		Standard Script Elements

			-
				A standard script element is a defined feature that may be incorporated into a
				given GHI standard script.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 2 - Hardware: 2 - Interfaces: 1 - GHI: 1 - Standards: 2 - Modules: 2 - Apps: 1 - Monitor Application'

GHI Monitor Application

	Philosophy

		-
			A GHI monitor application is a piece of software that remotely manages receptor modules
			through the GHI according to an external standard.
		-

	Principles

		GHI Hub

			-
				A GHI hub is a web application served by a public web domain, which may act as a
				GHI monitor application to an indefinite number of receptor modules.
			-

		GHI IoT Hub

			-
				A GHI IoT hub is a GHI hub which may support protocols other than the GHI.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 2 - Hardware: 2 - Interfaces: 1 - GHI: 1 - Standards: 2 - Modules: 2 - Apps: 2 - Auto-Adapter'

GHI Auto-Adapter

	Philosophy

		-
			GHI auto-adapters are units of software designed to configure devices to comply with
			the general hardware interface on startup and as they are connected to one another.
		-

	Principles

		GHI Service

			-
				A GHI service is a conventional JSH service for which an instance of it may act as
				a GHI auto-adapter for receptor modules, thereby acting as an automation engine as
				well.

				A GHI receptor hub is the web application served by a receptor module, and which
				acts as a GHI monitor application to the device that it is served by.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 2 - Hardware: 2 - Interfaces: 1 - GHI: 2 - Modules'

GHI Receptor

	Philosophy

		-
			GHI Receptor is a convention used to relay information regarding receptor modules
			through the GHI.
		-

	Principles

		Type

			-
				The type of receptor modules shall be specified as "receptor" in the receptor
				output format.
			-

		Conventions

			Properties

				Access

					-
						The access object is a JSON object, which may contain the fields "ssid",
						which, if present, shall contain a string, "password", which, if present,
						may either contain a string or a null value, "ip", which, if present, shall
						contain a string, and "port", which if present, shall contain a number.
						
						Each of the aforementioned fields shall respectively specify the SSID and
						password of the receptor module's Wi-Fi access point, as well as the IP
						address and port of an HTTP server to which JSH or GHI POST calls may be
						sent. If the password field contains a null value, the access point shall
						have no password.

						The access object may also be set to null, indicating that the receptor
						module's Wi-Fi access point is disabled.
						
						Some devices may require the Wi-Fi access point to be disabled in order for
						other Wi-Fi based features to function.
					-

				Metadata

					-
						The metadata is a value containing miscellaneous data which may be
						referenced by the script.
					-

				Password

					-
						The password is a string which, if specified, must be included in a call to
						the GHI.

						The password shall not be included in a receptor output format object, and
						shall be retained following a system reset regardless of the status of the
						state preservation flag.
					-

				Script

					-
						The script is a string which specifies the body of a function that takes,
						as arguments, the current state of the receptor module as a string in the
						receptor input format, followed by the time in seconds since the last
						execution of the script, and may return a string in the receptor output
						format which, if returned shall redefine the output state of the module
						accordingly.
					-

				Script Language

					-
						The script language is a string which specifies the language that the
						script is written in. If the script language is undefined, the script's
						language shall be auto-detected.
					-

				Script Interval

					-
						The script interval is the time that passes between the execution of script
						functions.
					-

				State Preservation

					-
						State preservation is a boolean flag that, if true, causes the output state
						and scripts associated with each module in the module cluster to be
						preserved following a reboot of the device.
					-

			Default State

				-
					By default, the script interval is one sixtieth of a second, the state
					preservation flag is set to false, and the Wi-Fi access point is enabled, with
					no password, an SSID set to the string "GHI-", followed by a unique serial
					number, with the server's IP address and port set to certain defaults based on
					the properties of the device it is running on.
				-

		Branch Formats

			Output

				-
					The branch data output format for a receptor module shall be a JSON object,
					which may have the fields "access", "metadata", "newPassword", "password",
					"script", "scriptInterval", "scriptLanguage", and "statePreservation".

					The access field, if present, may contain either a null value, or a JSON
					object. If it contains an object, said object may have any of the
					aforementioned fields. This field shall specify the properties of the Wi-Fi
					access point according to the aforementioned details.

					The metadata field, if present, may contain any value, specifying the contents
					of the metadata value.

					The new password field, if present, shall contain a string or a null value,
					which shall reset the password accordingly.

					The password field, which must be present in external calls if the password has
					been set, specifies the current password of the system. Failure to include the
					correct password shall result in the call not being processed and a null value
					being returned to the source of the call.

					The script field, if present, shall contain a string, specifying the code of
					the script.

					The scriptLanguage field, if present, shall contain a string, specifying the
					language of the script.

					The scriptInterval field, if present, shall contain a number, specifying the
					time of the script interval in seconds.

					The statePreservation field, if present, shall contain a boolean specifying the
					status of the state preservation flag.
				-

			Input

				-
					As the receptor module itself collects no data, the branch data input format
					for receptor modules shall be a null value.
				-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 2 - Hardware: 2 - Interfaces: 1 - GHI: 2 - Modules: 1 - Pinout: 1 - GHI GPIO'

GHI GPIO

	Philosophy

		-
			GHI GPIO is a convention used to relay information regarding gpio pinout devices
			through the GHI.
		-

	Principles

		Type

			-
				The type of GPIO modules shall be specified as "gpio" in the receptor output
				format.
			-

		Conventions

			Default State

				-
					The default state of all output pins is set to off.
				-

		Branch Formats

			Output

				-
					The branch data output format of a GPIO device is a list of booleans and
					numbers between zero, exclusive, and one, inclusive, where each value
					corresponds to the value of a programmable output pin according to its index
					via the output pin map.
				-

			Input

				-
					The branch data input format of a GPIO device is a list of numbers between
					zero, inclusive, and one, inclusive, where each value corresponds to the value
					of an input pin according to its index via the input pin map.
				-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 2 - Hardware: 2 - Interfaces: 1 - GHI: 2 - Modules: 1 - Pinout: 2 - GHI Serial'

GHI Serial

	Philosophy

		-
			GHI serial is a convention used to relay information regarding USB devices through the
			GHI.
		-

	Principles

		Type

			-
				The type of serial modules shall be specified as "serial" in the receptor output
				format.
			-

		Branch Formats

			Output

				-
					The branch data output format of a serial device is a list of objects, each of
					which has two fields, one of which has the alias "data", and the other of which
					has the alias "device".
					
					The data field contains a list of numbers where each value corresponds to the
					value of a bit to be sent over the serial interface, with said bits arranged in
					the order specified by said list.

					The device field contains either a string or an object which may contain a
					field with the alias "serial", may contain a field with the alias "vendor", may
					contain a field with the alias "product", so long as one of said fields is
					present.

					The serial, vendor, and product fields shall each, if present, contain numbers.

					The serial field specifies the serial number of a USB device, the vendor field
					specifies the vendor ID of a USB device, and the product field specifies the
					product ID of a USB device.

					If the device field contains a string, it shall specify either the PNP ID or
					the USB path of the device to which the data is to be sent.

					The device field contains an object, it shall specify the USB device to which
					the data is to be sent as the first device detected which matches all of the
					information specified by said object.
				-

			Input

				-
					The branch data input format of a serial device is a list of objects, where
					each of said objects corresponds to a USB device that is connected to the
					serial device, and where each of said objects has a field with the alias
					"id", and a field with the alias "data".

					The id field contains an object with a field where the alias is "pnp", and a
					field with the alias "path". The pnp field contains a string specifying the PNP
					ID of the corresponding device, and the path field contains a string specifying
					the USB path of the corresponding device.

					The data field contains a list of numbers corresponding to the bit sequence
					that was most recently received from the corresponding device.
				-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 2 - Hardware: 2 - Interfaces: 1 - GHI: 2 - Modules: 2 - Wireless: 1 - GHI Wi-Fi'

GHI Wi-Fi

	Philosophy

		-
			GHI Wi-Fi is a convention used to relay information regarding Wi-Fi communication
			through the GHI.
		-

	Principles

		Type

			-
				The type of Wi-Fi modules shall be specified as "wifi" in the receptor output
				format.
			-

		Branch Formats

			Output

				-
					The branch data output format of a Wi-Fi device shall either be an object
					containing a field with the alias "credentials", and may optionally have a
					field with the alias "data".

					The credentials field shall contain an object. Said object shall have a field
					with the alias "ssid", containing a string specifying the SSID of a Wi-Fi
					network, and may optionally have the fields "password", containing a string
					specifying the password of said Wi-Fi network, "host", containing a string
					specifying a host IP to direct communication to over said Wi-Fi network, and
					"port", containing a number specifying a host port to direct communication to
					over said Wi-Fi network.

					If the data field is not present, the device shall act as a Wi-Fi router using
					the specified SSID and password.

					If the data field is present, it shall contain a string which shall be passed
					to the Wi-Fi endpoint with the specified SSID and password at the specified
					host IP and port. If either the host IP or host port are not specified, they
					shall be set to default values.
				-

			Input

				-
					The branch data input format of a Wi-Fi device is a list of objects
					representing any messages it received from external devices over its Wi-Fi
					connection since the last query for said input.

					Each of said objects shall contain two fields, a field with the alias "time",
					containing a number specifying the time in seconds that the message was
					received, and a field with the alias "data", containing a string specifying the
					message that was received.
				-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 2 - Hardware: 2 - Interfaces: 1 - GHI: 2 - Modules: 2 - Wireless: 2 - GHI Bluetooth'

GHI Bluetooth

	Philosophy

		-
			GHI Bluetooth is a convention used to relay information regarding bluetooth
			communication through the GHI.
		-

	Principles

		Type

			-
				The type of bluetooth modules shall be specified as "bluetooth" in the receptor
				output format.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 2 - Hardware: 2 - Interfaces: 1 - GHI: 2 - Modules: 2 - Wireless: 3 - GHI Cellular'

GHI Cellular

	Philosophy

		-
			GHI Cellular is a convention used to relay information regarding cellular communication
			through the GHI.
		-

	Principles

		Type

			-
				The type of cellular modules shall be specified as "cellular" in the receptor
				output format.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 2 - Hardware: 2 - Interfaces: 1 - GHI: 2 - Modules: 3 - AV: 1 - Display'

GHI Display

	Philosophy

		-
			GHI Display is a convention used to relay information regarding Audio-Visual display
			devices through the GHI.
		-

	Principles

		Type

			-
				The type of display modules shall be specified as "display" in the receptor output
				format.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 2 - Hardware: 2 - Interfaces: 1 - GHI: 2 - Modules: 3 - AV: 2 - Recorder'

GHI Recorder

	Philosophy

		-
			GHI Recorder is a convention used to relay information regarding Audio-Visual recording
			devices through the GHI.
		-

	Principles

		Type

			-
				The type of recorder modules shall be specified as "recorder" in the receptor
				output format.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 2 - Hardware: 2 - Interfaces: 1 - GHI: 3 - Devices: 1 - Raspberry Pi'

GHI Raspberry Pi

	Philosophy

		-
			GHI Raspberry Pi is a convention that specifies how Raspberry Pi computers ought to
			operate under the GHI.

			The convention specifies, among other things, the devices available to Raspberry Pis
			operating as receptor modules, along with the numerical IDs of said devices.
		-

	Principles

		Devices

			Common

				0: Receptor
				1: GPIO
				2: Serial
				3: Display: HDMI Out
				4: Recorder: Audio In

			Circumstantial

				5: Wi-Fi
				6: Bluetooth
				7: Cellular

		Conventions

			GPIO Dual Pin Map
				
				0: 3
				1: 5
				2: 7
				3: 8
				4: 10
				5: 11
				6: 12
				7: 13
				8: 15
				9: 16
				10: 18
				11: 19
				12: 21
				13: 22
				14: 23
				15: 24
				16: 26
				17: 27
				18: 28
				19: 29

			Wi-Fi Access Point Server Defaults

				IP Address: 192.168.4.1
				Port: 80

		Notes

			-
				A Raspberry Pi must have its Wi-Fi access point disabled in order for calls to its
				Wi-Fi module to function, unless it is integrated into a setup with more than one
				Wi-Fi channel.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 2 - Hardware: 2 - Interfaces: 1 - GHI: 3 - Devices: 2 - Arduino Uno'

GHI Arduino Uno

	Philosophy

		-
			GHI Arduino Uno is a convention that specifies how Arduino Uno microcontrollers ought
			to operate under the GHI.

			Under the GHI, the Arduino Uno acts as a single GPIO device.
		-

	Principles

		Conventions
			
			GPIO Dual Pin Map
				
				0: 2
				1: 3
				2: 4
				3: 5
				4: 6
				5: 7
				6: 8
				7: 9
				8: 10
				9: 11
				10: 12
				11: 13
				12: A0
				13: A1
				14: A2
				15: A3
				16: A4
				17: A5

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 2 - Hardware: 3 - Devices: 1 - Units: 1 - General Switch'

General Switch

	Philosophy

		-
			A general switch is a programmable relay with a single power input and a single power
			output that can reverse the direction of its current, and can adjust its power output
			to any value between none and some arbitrary maximum.
		-

	Principles

		Design

			Standard General Switch

				-
					A standard general switch shall have input, output, and ground ports on either
					side, with each side labelled to distinguish them, and shall have a third area
					to which control wires can be attached.

					The ports for the control wires shall have a port to receive a digital signal,
					which if on shall flip the direction of the current and shall have it flow
					normally if off, shall have a port to receive a PWM signal where the value of
					the signal from zero to the maximum possible value shall indicate the
					resistance applied to the current on the same scale, and shall have additional
					ports for any ground wires that may be necessary.

					The default state of a standard general switch shall have its power output set
					to none, and should have its current flow in the default direction.

					A standard general switch should be able to handle high amounts of power, and
					should be fully encased in a non-conductive shell.
				-

			Alternate General Switch

				-
					An alternate general switch has a USB port in place of control wires.
					
					Through said port, signals, referred to as general switch signals, may be sent
					consisting of two bytes.
					
					The first of said bytes corresponds to the state of the digital signal wire,
					where a value of zero indicates the equivalent of said wire being on, and any
					other value indicates the equivalent of said wire being off.
					
					The second of said bytes corresponds to the state of the PWM signal wire, where
					the value, from zero to two hundred and fifty five scales to the value range of
					said wire.
				-

			General Switch Hub

				-
					A general switch hub is a device that integrates multiple general switches into
					a single unit, where each of said general switches is assigned a unique
					numerical index relative to one another.

					A general switch hub uses a USB port for control, and may receive signals
					through it consisting of general switch signals for each switch in the hub,
					concatenated together and arranged in the order of their indices.
				-

		Rating

			-
				The rating of a general switch is the maximum amount of current that it is capable
				of resisting, specified in ohms.
			-

		Port Adapters

			-
				A port adapter is a module that can be plugged into either end of a standard
				general switch to convert it to the male or female form of a given outlet type.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 2 - Hardware: 3 - Devices: 1 - Units: 2 - Universal IoT Module'

Universal IoT Module

	Philosophy

		-
			A universal IoT module, or UIM for short, is a universal module which functions as an
			IoT gateway that utilizes the General Hardware Interface.
		-

	Principles

		Communication

			Cellular

				-
					A UIM shall have a SIM card slot, allowing JSH and GHI calls to be relayed to
					it according to either a phone number or a static IP so long as a SIM card has
					been inserted into said slot.
				-

			Wi-Fi

				-
					When a UIM's Wi-Fi is not in use, said UIM shall function as a hotspot, and
					shall run a server to which JSH and GHI calls may be directed.
				-

		Configurations

			UIM Model

				-
					A UIM Model, or UIMM for short, is a given module solution that can operate as
					a UIM.
				-

			UIM Adapter

				-
					A UIM Adapter, or UIMA for short, is a device that allows an MSC of UIMMs to
					operate as a different type of device.
				-

		Standard Universal IoT Module

			-
				A standard universal IoT module is a universal IoT module that is also a standard
				universal module.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 2 - Hardware: 3 - Devices: 1 - Units: 3 - Shared Memory Unit'

Shared Memory Unit

	Philosophy

		-
			A shared memory unit, or SMU, is a digital storage unit with may simultaneously connect
			to, be read from, and be written to by multiple devices.

			An external non-volatile SMU is called a shared memory drive, or SMD.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 2 - Hardware: 3 - Devices: 2 - General IoT Stack'

General IoT Stack

	Philosophy

		-
			The general IoT stack is a suite of devices consisting of the general IoT module and
			the general switch.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 1 - APIs: 2 - Hardware: 3 - Devices: 3 - Robots: 1 - All-Purpose Android'

All-Purpose Android

	Philosophy

		-
			An all-purpose android is a humanoid robot that can perform all human motor functions
			and can replicate all human facial expressions to the extent that it can satisfactorily
			perform any human job.
		-

	Principles

		Singularity Androids

			-
				An all-purpose android guided by a functional AGI is referred to as a singularity
				android, and the development of such machines is referred to as the labor
				singularity, where nearly all human labor, both mental and physical, becomes
				replaceable by machines.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 2 - Kaeon United: 1 - Suite: 1 - Languages'

United Use

	Philosophy

		-
			United use is a convention which specifies that a function with the alias "use", taking
			a string path to an external resource, along with an optional arguments value, may be
			implemented in any language or environment, to the extent possible, with the following
			behavior:

			Said function shall, depending on the environment and the arguments, use integration
			mode, where it loads the referenced resource into the environment globally, import
			mode, where it loads the referenced resource into a value and returns it, or some
			combination or variant thereof, with additional behaviors contingent on the environment
			and arguments.

			The referenced resource may be referenced by alias or path, and may be loaded from the
			local file system or from the internet. By default, such aliases shall ignore
			whitespace and letter case, in addition to punctuation with the exception of that which
			denotes package nesting, namely periods and slashes.
			
			The use function shall be made globally available to the extent possible, and should be
			implemented to be compatible with as many types of external resources as possible.
		-

	Principles

		Conventions

			United Use

				Native Utility Bootstraps

					-
						Utilities native to the environment for loading external resources may, to
						the extent possible, be overridden as bootstraps for the use function,
						thereby extending the variety of resources they may load.
					-

				Built-In Modules

					-
						The integration of united use into a particular environment may include
						certain built-in modules which may be accessed with the use function via
						alias. Such modules, by default, should also be made available through said
						environment's native resource loading mechanisms.
						
						The set of such modules for a given implementation shall be referred to as
						the provision package.
					-

				Options Conventions

					-
						Codified conventions regarding the contents of the options value and the
						effects thereof are referred to as united option conventions.
					-

			Standard United

				-
					Standard United is an extension of united use which applies the Universal
					Preprocessor to all plain text files referenced via the use function, and to
					all plain text files to which standard united is applied.
				-

		Standards

			United Option Conventions

				Async

					-
						The options value may have an "async" field, containing a boolean which, if
						true, shall indicate that the referenced resource is to be loaded
						asynchronously, with a promise being the immediately returned value in
						import mode.
					-

				Cache

					-
						The options value may have a "cache" field, containing a boolean which, if
						true, shall indicate that the referenced resource is a standard network
						cache for which all compatible resources are to be pre-cached for later
						usage, and that the use function is to return null.
					-

				Dynamic

					-
						The options value may have a "dynamic" field, containing a boolean which, if
						true, shall indicate that the path to the referenced resource is to be
						interpreted as the contents of the resource rather than its location.
					-

				Global

					-
						The options value may have a "global" field, containing a boolean which, if
						true, shall indicate that the use function is to execute in the global
						scope.
					-

				Reload

					-
						The options value may have a "reload" field, containing a boolean which, if
						true, shall indicate that the use function is to clear any cached data
						related to the referenced resource, and to fully reload it from its source.
					-

				Use

					-
						The options value may have a "use" field, containing a boolean which, if
						true, shall indicate that the referenced resource is an interface module to
						be integrated, to extent applicable and possible, into the Philosopher's
						Suite of the Philosopher's Singularity running the process.
					-

			Modules

				Kaeon United

					-
						By default, the provision package of a united use integration should
						include Kaeon United, with its name as its alias.
					-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 2 - Kaeon United: 1 - Suite: 1 - Languages: 1 - United JS'

United JavaScript

	Philosophy

		-
			United JavaScript is a set of conventions for JavaScript that enhance its compatibility
			between different environments as well as its ease of use.
		-

	Principles

		Standard United

			-
				United JavaScript employs standard united in import mode, with "require" serving as
				a native utility bootstrap for the use function in environments where the require
				function is not natively implemented.

				The use function may import modules using CommonJS and ES6 conventions, and shall
				employ dynamic dependency retrieval for modules installed via package managers.
				
				The options value passed to the use function shall be an object, with all option
				field aliases matching the names specified in the united use specification, in
				lower case.
			-

		Conventions

			Asynchronous

				-
					Under United JavaScript, the await operator may be used at the root level of
					the main file, outside of async functions.
				-

			Environment

				-
					Under United JavaScript, a JavaScript file may be executed on the client side
					on its own without being explicitly tied to an HTML document.
				-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 2 - Kaeon United: 1 - Suite: 1 - Languages: 1 - United JS: 1 - Conventions: 1 - List Object Equivalence'

List Object Equivalence

	Philosophy

		-
			List object equivalence is a JavaScript convention that allows any object to be
			interpreted as a list by taking the values of every field and ordering them in the
			order of their respective keys, and allows any list to be interpreted as an object by
			making each element a field value with the keys of said field being the respective
			indices.
		-

	Principles

		Dynamic List Field

			-
				The aliases for a dynamic list where said list is represented by a JavaScript list
				may be stored in a list assigned to a field of said JavaScript list with the alias
				"dynamicAliases", where a non-null value within the dynamicAliases list corresponds
				to the alias of the element at the same index in the corresponding dynamic list.
			-

		Schema Generalization

			-
				Any schema for a JSON list or object may be applied to any other language or data
				exchange format by representing the objects in said structure, if there are any, as
				lists according to list object equivalence.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 2 - Kaeon United: 1 - Suite: 1 - Languages: 1 - United JS: 1 - Conventions: 2 - Modules'

United JavaScript Module Conventions
	
	Philosophy
		
		-
			This document specifies conventions for CommonJS modules that are especially useful in
			the context of United JavaScript.
		-

	Principles

		Platform Variance

			-
				Platform variance is where the exports of a module are different for certain
				platforms.
				
				The aliases of the contents of each platform specific variation of said exports
				should be the same, but their implementations may differ.
			-

		Link Reference

			-
				A link reference is a JavaScript object declared at the beginning of a module's
				code which contains the paths to said module's dependencies.

				This object may be used to reconfigure said paths without drastically altering the
				module's code.
			-

		Package Modules

			-
				A package module is a module that exports the exports of other modules.

				A module whose exports are exported by a package module is referred to as a nested
				module.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 2 - Kaeon United: 1 - Suite: 1 - Languages: 1 - United JS: 1 - Conventions: 3 - Techniques: 1 - HTJS'

HTJS

	Philosophy

		-
			HTJS is a convention that allows a single text file to act as both a JavaScript file
			and an HTML file through a strategic placement of JavaScript comments.
		-

	Principles

		Structure

			-
				HTML content and JavaScript content must be placed on separate lines.
				
				JavaScript content must be placed within script tags and HTML content must be
				commented out using JavaScript comments.

				An HTJS file following all of the conventions specified in this document is
				referred to as an HTJSS file, the latter 'S' standing for "standard".
			-

		Conventions

			File Extension

				-
					A HTJS file should have a ".html" file extension.
				-

			Comment Mark Clearing

				-
					The JavaScript code may employ DOM modification code to clear the rendered HTML
					page of any JavaScript comment marks.
				-

			Standard Format

				-
					The standard format for a HTJS file begins with the line:

						// <script> document.documentElement.innerHTML = "";

					and ends with the line:

						// </script>

					with JavaScript code placed between the two aforementioned lines.
				-

			Standard Process

				-
					The standard process for HTJS files enables them to execute as omni-modal
					utilities.
				-

			Shebang

				-
					An HTJS file may begin with a shebang line, enabling it to function as a
					terminal command independently.

					The standard shebang line for an HTJS file is:

						#!/usr/bin/env node
				-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 2 - Kaeon United: 1 - Suite: 1 - Languages: 1 - United JS: 1 - Conventions: 3 - Techniques: 2 - Common Await'

Common Await

	Philosophy

		-
			Common await is a convention for United JavaScript where the CommonJS require function
			is to always be called using the await keyword.
		-

	Principles

		Purpose

			-
				This convention is to be used in the case that synchronous HTTP calls are removed
				from mainstream browsers and no workaround can be found, thus requiring any
				CommonJS browser implementation to have the require function defined as async.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 2 - Kaeon United: 1 - Suite: 1 - Languages: 1 - United JS: 2 - JSON: 1 - Tools: 1 - Dynamic'

JSON Dynamic List

	Philosophy

		-
			A JSON document may be converted to a dynamic list.
		-

	Principles

		Objects

			-
				A JSON object shall be converted to a dynamic list where each field becomes an
				element in said list, with the value of the field being the element, the position
				of the field being the index, and the alias of the field being the alias of the
				element.
			-

		Lists

			-
				A JSON list shall be converted to a dynamic list where each element has an alias of
				null.
			-

		Nesting

			-
				Nested lists and objects shall by default be converted into dynamic lists
				themselves.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 2 - Kaeon United: 1 - Suite: 1 - Languages: 1 - United JS: 2 - JSON: 1 - Tools: 2 - Trace'

JSON Trace

	Philosophy

		-
			JSON values may function as tag trace modules, with their field aliases, their
			stringified forms, and their indices functioning as trace tags, and their children
			functioning as their connections.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 2 - Kaeon United: 1 - Suite: 1 - Languages: 1 - United JS: 2 - JSON: 1 - Tools: 3 - United JSON'

United JSON

	Philosophy

		-
			United JSON, or UJSON for short, is a file format in which a document shall contain one
			JavaScript object or array literal, written either in JSON or in vanilla JavaScript
			syntax, with both JavaScript comments and nested JavaScript functions and expressions
			allowed.
		-

	Principles

		Universal Preprocessor

			-
				UJSON may use the Universal Preprocessor in its text.
			-

		File Extension

			-
				UJSON files should use the file extension ".ujs".
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 2 - Kaeon United: 1 - Suite: 1 - Languages: 1 - United JS: 2 - JSON: 2 - Schemas: 1 - General'

JSON Constructs

	Philosophy

		-
			JSON objects and arrays may be collectively referred to as JSON constructs.
		-

	Principles

		Definitions

			Monotype Constructs

				-
					A monotype JSON construct is a JSON construct that only contains one type of
					primitive nested within it.

					A mononull JSON construct is a JSON construct which only contains one type of
					non-null primitive nested within it in addition to null values.

					A monotype or mononull JSON construct can be defined by specifying the type of
					primitive it contains before the word monotype or mononull.
				-

			Flat Constructs

				-
					A flat JSON construct is a JSON construct with no other JSON constructs nested
					within it.
				-

			Monoform Constructs

				-
					A monoform JSON object is a JSON object that has no JSON arrays nested within
					it, and a monoform JSON array is a JSON array that has no JSON objects nested
					within it.
				-

		Formats

			Flat Formats

				Field JSON

					-
						A field JSON object is a flat string monotype JSON object.
					-

				ID JSON

					-
						An ID JSON object is a flat number monotype JSON object.
					-

				Switch JSON

					-
						A switch JSON object is a flat boolean monotype JSON object.
					-

			Minimal JSON

				-
					A minimal JSON object is a monoform string monotype JSON object.
				-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 2 - Kaeon United: 1 - Suite: 1 - Languages: 1 - United JS: 2 - JSON: 2 - Schemas: 1 - General: 1 - Types: 1 - Meta'

Meta JSON

	Philosophy

		-
			A meta JSON object is a JSON object which serves to give context to another JSON value.

			A meta JSON object shall have a field with the alias "type", which shall contain a
			string specifying the type of the value according to its intended use, and a value with
			the alias "value", which shall contain the value itself, and may also have a field with
			the alias "data", which may contain any JSON value used to specifying additional
			information about said value, though it should, unless otherwise specified, be an
			object.

			A codified protocol for formatting a meta JSON object is called a meta JSON convention.
		-

	Principles

		Meta JSON Preprocessing

			-
				A document containing meta JSON objects may be preprocessed by replacing each meta
				JSON object in the document with the value of its value field.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 2 - Kaeon United: 1 - Suite: 1 - Languages: 1 - United JS: 2 - JSON: 2 - Schemas: 1 - General: 1 - Types: 1 - Meta: 1 - Function'

Function JSON

	Philosophy

		-
			A function JSON object is a meta JSON object that corresponds to a function.

			A function JSON object must have a its type specified as "function", and shall have its
			code, which may or may not include the definition if applicable, assigned to the value
			field as a string.

			The data object may have a field with the alias "language", containing a string
			specifying the language of the function, and if this field is not present then a
			program may attempt to auto-detect the language based on the function code.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 2 - Kaeon United: 1 - Suite: 1 - Languages: 1 - United JS: 2 - JSON: 2 - Schemas: 1 - General: 1 - Types: 2 - Schema JSON'

Schema JSON

	Philosophy

		-
			A schema JSON object is a JSON object which serves to define formatting conventions for
			other JSON values.

			A method for formatting a schema JSON object is called a schema JSON convention.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 2 - Kaeon United: 1 - Suite: 1 - Languages: 1 - United JS: 2 - JSON: 2 - Schemas: 1 - General: 2 - Elements'

JSON Elements

	Philosophy

		-
			This document specifies generic JSON elements and utilities.
		-

	Principles

		Conventions

			Location Specifier

				-
					A location specifier may either be a location identifier, which is a string
					specifying the path to an external resource, or a location array, a list of
					location identifiers specifying possible locations for a given external
					resource, with the locations at lower indices being preferred.
				-

			Tags Object

				-
					A tags object is a flat string mononull JSON object specifying miscellaneous
					information about a subject.

					A codified protocol for the content and meaning of said information is referred
					to as a JSON tag convention.
				-

		Formats

			Batch JSON

				-
					A batch JSON array is a JSON array that specifies a series of items and related
					metadata.

					A batch JSON array contains item objects, each of which have the field "item",
					containing a string specifying the item, and each of which may optionally have
					the field "tags", containing a tags object specifying miscellaneous metadata
					about said item.

					Batch JSON arrays may be used to define, serialize, and update the internal
					states of processes in which multiple items are maintained.
				-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 2 - Kaeon United: 1 - Suite: 1 - Languages: 1 - United JS: 2 - JSON: 2 - Schemas: 2 - Specific: 1 - X-JSON'

X-JSON

	Philosophy

		-
			An X-JSON object is a JSON object that corresponds to an XML element.
		-

	Principles

		Structure

			Tag

				-
					An X-JSON object may have a field with the key "tag", the value of which must
					be a string specifying the tag name of the element.

					If no tag is specified, a certain tag may be assigned by default.
				-

			Attributes

				-
					An X-JSON object may have a field with the key "attributes", the value of which
					must be a field JSON object, where each field thereof specifies an attribute, the
					key being the attribute alias, and the value being the attribute content.
				-

			Content

				-
					An X-JSON object may have a field with the key "content", specifying the child
					nodes of said object and the order in which they occur.
					
					The value of the content field may be either a list of child values, arranged
					in the order in which they are to be placed, or a single child value. A child
					value for a text node must be a string, and a child value for an XML node must
					be another X-JSON object.
				-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 2 - Kaeon United: 1 - Suite: 1 - Languages: 1 - United JS: 2 - JSON: 2 - Schemas: 2 - Specific: 2 - DOM JSON'

DOM JSON

	Philosophy

		-
			A DOM JSON object is an extension of an X-JSON object that may be used to represent an
			HTML DOM element.

			If no tag is specified, the element will be assigned the tag "div" by default.
			
			A DOM JSON object may have a field with the key "style", the value of which must be a
			field JSON object, where each field thereof specifies a CSS style, where the key is the
			style alias and the value is the style content.
			
			A DOM JSON object may also have a field with the key "fields", the value of which must
			be a field JSON object, where each field thereof specifies a JavaScript variable, where
			the key is the variable alias and the value is the variable value.

			The "fields" object may specify some variables as functions using function JSON
			objects.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 2 - Kaeon United: 1 - Suite: 1 - Languages: 1 - United JS: 2 - JSON: 2 - Schemas: 2 - Specific: 3 - Style JSON'

Style JSON

	Philosophy

		-
			A style JSON object is a JSON object that corresponds to a CSS stylesheet.
			
			Each field within a style JSON object shall have a key specifying either a CSS selector
			or a CSS media rule. A field with a key specifying a CSS selector shall have a field
			JSON object as its value, where each field therein represents a CSS style, with the key
			specifying the style alias and the value specifying the style content. A field with a
			key specifying a CSS media rule shall have a style JSON object as its value,
			representing the CSS content of said media rule.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 2 - Kaeon United: 1 - Suite: 1 - Languages: 1 - United JS: 2 - JSON: 2 - Schemas: 2 - Specific: 4 - HTTP JSON'

HTTP JSON

	Philosophy

		-
			An HTTP JSON object is a JSON object that corresponds to either an HTTP request or
			response.
		-

	Principles

		Definition Object

			-
				An HTTP JSON object must have a field containing a definition object.
				
				The alias of said field shall be "request" for an HTTP JSON object representing an
				HTTP request, and "response" for an HTTP JSON object representing an HTTP response.

				A definition object shall itself be a JSON field object, the contents of which
				shall differ depending on whether the HTTP JSON object containing it represents an
				HTTP request or response.

				For a request, a definition object shall have a field with the key "method", where
				the value shall be the method of the request, and shall have a field with the key
				"uri", where the value shall be the URI of the request, and may optionally have a
				field with the key "version", where the value shall be the version of the HTTP
				protocol.

				For a request, a definition object shall have a field with the key "version", where
				the value shall be the version of the HTTP protocol, and shall have a field with
				the key "status", where the value shall be the status of the response, and may also
				have a field with the key "reason", where the value is the reason phrase of the
				response.
			-

		Headers Object

			-
				An HTTP JSON object may optionally have a field with the key "headers" containing a
				JSON field object.

				For each field of said field object, the key shall specify the alias of an HTTP
				header, and the value shall specify the header's value.
			-

		Body Field

			-
				An HTTP JSON object may optionally have a field with the key "body" containing a
				string representing the body of the HTTP call.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 2 - Kaeon United: 1 - Suite: 1 - Languages: 1 - United JS: 2 - JSON: 2 - Schemas: 2 - Specific: 5 - File JSON'

File JSON

	Philosophy

		-
			A file JSON object is a JSON object that corresponds to a folder and its contents.
		-

	Principles

		Structure

			-
				Each field within a file JSON object corresponds to a resource within the folder
				that it represents, where the value of a field representing a folder shall be a
				file JSON object, and where the value of a field representing a file shall be a
				string containing the content of said file.
			-

		Alternate Forms

			Array Form

				-
					The contents of a file JSON object may alternatively be represented as a JSON
					array, called a file JSON array, where each file is represented by an object in
					said array, and where each of said objects contain a field with the alias
					"path", containing an array of strings specifying, in order, the names of the
					folders that the file that a given object represents is nested within, and
					where each of said objects either contain a field with the alias "location",
					containing a string specifying a file path or URL at which to find the file
					that said given object represents, or contain a field with the alias "content",
					containing a string specifying a the content of the file that said given object
					represents.
				-

			Directory Form

				-
					A file JSON object may be used to represent the items within a single directory
					without specifying their content, by assigning each field representing a folder
					the value of an empty object, and by assigning each field representing a file
					the value of an empty string.
				-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 2 - Kaeon United: 1 - Suite: 1 - Languages: 1 - United JS: 2 - JSON: 2 - Schemas: 2 - Specific: 5 - File JSON: 1 - System'

System JSON

	Philosophy
	
		-
			A system JSON object is a JSON object that represents files to load into a file system
			and a series of commands to execute within an operating system surrounding said file
			system.
		-
	
	Principles

		Structure

			-
				A system JSON object shall have a field with the alias "files", containing a file
				JSON object or array specifying files to load into a given file system, and a field
				with the alias "commands", containing an array of string commands to execute within
				the operating system surrounding said file system.
			-

		Protocol

			-
				By default, the specified files in a system JSON object should be loaded before its
				commands are executed.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 2 - Kaeon United: 1 - Suite: 1 - Languages: 1 - United JS: 2 - JSON: 2 - Schemas: 2 - Specific: 5 - File JSON: 2 - Directory'

Directory JSON

	Philosophy

		-
			A directory JSON list is a JSON list containing two lists, each of which contain only
			strings, where the strings of the first list specify the names of the folders in a
			given directory, and where the strings of the second list specify the names of the
			files in said directory.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 2 - Kaeon United: 1 - Suite: 1 - Languages: 1 - United JS: 2 - JSON: 2 - Schemas: 2 - Specific: 6 - Forum JSON'

Forum JSON

	Philosophy

		-
			A forum JSON object is a JSON object used to represent the content of a query in a chat
			forum, along with responses to said query.

			A forum JSON object shall have a field with the alias "text", which contains the
			content of the query, and may optionally have a field with the alias "responses", which
			contains an array of forum JSON objects, each of which represents a response to said
			query, arranged in the order said responses were submitted.
		-

	Principles

		Chat Array

			-
				A chat array is an array of strings, where the first string represents a query, and
				each subsequent string represents a response to the previous string.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 2 - Kaeon United: 1 - Suite: 1 - Languages: 1 - United JS: 2 - JSON: 2 - Schemas: 2 - Specific: 7 - UCM JSON'

UCM JSON

	Philosophy

		-
			UCM JSON is a JSON object schema used for specifying a specific function within a
			specific utility and arguments to pass to it.
		-

	Principles

		Structure

			-
				A UCM JSON object shall have a "utility" field, containing a string the module
				which is or contains the function to execute, said string being a utility ID string
				if said utility is within an interface module.

				If the function is to be executed with arguments, the UCM JSON shall have an
				"arguments" field, containing a list of arguments to pass to the aforementioned
				function.

				If the specified utility contains said function but is not itself said function,
				the UCM JSON object shall have a "function" field, containing a string specifying
				the alias of said function.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 2 - Kaeon United: 1 - Suite: 1 - Languages: 1 - United JS: 3 - Frameworks: 1 - Dynamic UI'

Dynamic UI Framework

	Philosophy

		-
			The dynamic UI framework is a set of conventions for managing the HTML DOM through
			JavaScript.
		-

	Principles

		Utilities

			DOM JSON

				-
					The dynamic UI framework shall provide utilities for converting DOM JSON
					elements into DOM element objects, and vice versa.
				-

			Loading

				-
					The dynamic UI framework shall provide functions that allow for the dynamic
					loading of external JavaScript scripts and CSS stylesheets.
				-

		Components

			Component Sheet

				-
					A component sheet is a JSON object for which the keys are CSS selectors, and
					for which the values are DOM JSON objects containing properties to assign to
					any element matching the corresponding selector.
				-

			Component Engine

				-
					The dynamic UI component engine is a background process which maintains a
					component sheet, referred to as the component context, into which external
					component sheets may be dynamically assigned.

					For elements in the DOM which match selectors in the component context, the
					properties of the corresponding components shall be assigned to said elements.

					Elements may have an update function. The dynamic UI component engine shall, at
					regular intervals, call the update function of any element with an update
					attribute. The update function shall take as its first argument a reference to
					the object to which it belongs, and a number specifying the time in seconds
					since it last executed.
				-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 2 - Kaeon United: 1 - Suite: 1 - Languages: 1 - United JS: 3 - Frameworks: 1 - Dynamic UI: 1 - CCSS'

CCSS

	Philosophy

		-
			Cross Cascading Style Sheet, or CCSS, is an HTML and CSS convention that extends both
			HTML and CSS such that all HTML attributes and CSS properties become interchangeable,
			allowing HTML attributes to be applied to elements as CSS properties, and CSS
			properties to be applied to elements as HTML attributes.

			If there is a conflict with the alias of a given attribute or property, the default
			interpretation of said alias shall take priority.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 2 - Kaeon United: 1 - Suite: 1 - Languages: 2 - C3'

C3

	Philosophy
	
		-
			The Common C Conventions (C3) are a set of common conventions for C and C++ that allow
			the two languages to operate as one.
		-

	Principles

		Conventions

			Common C

				-
					Under the common C (CC) convention, C code may not use any language features of
					C that C++ does not possess.
				-

			Cross C

				-
					Under the cross C (CX) convention, all features of C and C++ may be used.
				-

		Standards

			Versions

				-
					The C or C++ code used must conform to the conventions of the latest standard
					of the respective language.
				-

			Scaling

				-
					If only C features, which C++ shares, are used, or if no C++ features are used,
					the code will compile as C.

					If only C features which C++ shares, and C++ exclusive features, are used, the
					code will compile as C++.

					If C++ exclusive features are used, and C features which C++ does not share are
					used, the code will use a custom CX compiler.
				-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 2 - Kaeon United: 1 - Suite: 1 - Languages: 2 - C3: 1 - Character Separated Binary'

Character Separated Binary

	Philosophy

		-
			A character separated binary document is a string that encodes binary data according to
			a protocol where the representations of each byte are separated by token strings.
		-

	Principles

		Protocol

			Binary

				-
					Each byte shall be represented as a number according to the protocol.

					The protocol for the representation of each number may be binary, octal,
					decimal, or hexadecimal.
				-

			Character

				-
					The protocol may specify one or more tokens which may separate the bytes.
				-

			Whitespace

				-
					Any whitespace aside from the separator tokens shall be trimmed.
				-

		Conventions

			CSB

				Default Protocol

					-
						The default protocol uses binary to represent the bytes and any character
						other than one or zero as separator tokens.

						However, the best practice, and the default practice, for the default
						protocol is to use single new lines to separate the bytes, and to omit any
						leading zeros.
					-

				Abbreviation

					-
						Character separated binary may be abbreviated as CSB.
					-

			B-ONE

				-
					B-ONE (pronounced "bone"), is the use of a sequence a ONE element, for which
					each of its children contains a number, which number being specified in any of
					the formats allowed by CSB, to represent a sequence of bytes, the order of said
					bytes aligning with the order of the indices of said children.

					B-ONE, by default, shall use binary strings.

					As such, CSB specified using the default protocol with its default practices
					may be parsed as ONE+ to B-ONE.
				-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 2 - Kaeon United: 1 - Suite: 1 - Languages: 2 - C3: 2 - United C'

United C

	Philosophy

		-
			United C (UC) is a convention for C and C++ that allows them to work together as a
			hybrid language.

			United C's features extend and are fully backwards compatible with C3.
		-

	Principles

		Language Features
			
			Main Function

				-
					Any operations placed outside a function will be placed into the main function
					upon the compilation of an executable. If a main function is not already
					declared, one will be inferred.

					The main function, if automatically generated, shall be formatted to have a
					return type of int, shall return zero, and shall have a parameter argc of type
					int and a parameter argv of type char pointer array.

					If there is both a manually defined main function present as well as operation
					code placed outside the main function, the code within the manually defined
					main function shall execute before the code outside of it.
				-

			Declaration Order

				-
					Functions and global variables in United C may be declared in any order.
				-
			
			Type Detection

				-
					The token "var" may be used in lieu of the data type of a variable, in which
					case the type of said variable shall be predicted based on the value assigned
					to it.
				-

			Booleans

				-
					C code conforming to United C may use the literals true and false, which the
					preprocessor shall convert to 1 and 0 respectively, and may also use the data
					types bool and boolean, which the preprocessor shall convert to int.
				-

			Multiline Literals

				-
					United C allows multiline literals starting and ending with `.
					
					The ` character may be escaped using a backslash.
				-

			Addresses

				-
					United C allows @ to be used as the address token in addition to &.
				-

			Semicolons

				-
					United C code may omit semicolons where they are otherwise required.
				-

			Use

				-
					In place of the #include preprocessor, a sequence beginning with the token
					"use", referred to as a use directive, may be used in its place, where an
					indefinite number of paths to resources follow the use token, separated by
					commas.

					A use directive may terminate with either a new line or a semicolon.

					Paths to global resources may be written as they are, but paths to local
					resources must be encased in double quotes.

					If a path has no file extension, the system will check for any matching file
					with the extension "uc", "c", "h", or "cpp". If the extension cannot be
					verified, an extension of "uc" shall be inferred.

					Universal Preprocessor directives within imported code shall be executed on
					both the imported code and the code into which it was imported. The user can
					disable this for an imported file by encasing the name of said file in square
					brackets.
				-

			Online Dependencies

				-
					Include and use directives may reference dependencies stored online by their
					URLs, in which case the references must be encased in double quotes, as
					references to local resources would be.
				-

			Preprocessing

				-
					The main file and all local dependency files shall be preprocessed using the
					universal preprocessor upon compilation.
				-

		Usage

			Activation

				-
					A command or function used to generate United C should be named "United C" or
					"UC", adhering to the naming conventions of the language of its implementation,
					should take a string containing United C source code as an argument, and should
					return a string containing C or C++ code analogous to the input code. Such a
					command or function shall be called the United C transpilation function.

					The United C transpilation function may be called by a Universal Preprocessor
					directive, which should return the output of said command or function.
				-

			Compiler

				-
					United C shall have a custom compiler which shall, as an executable take a path
					to a single United C file as its first argument, run the universal preprocessor
					on it, and then compile the resulting code as C if said code uses no C++
					exclusive utilities, and as C++ otherwise.

					Optionally, the file path may be followed by either the argument "auto", or the
					argument "cpp". If said argument is auto, nothing will happen, but if the
					argument is cpp, the code will be compiled to C++ even if it could otherwise be
					compiled to C.

					If desired, the user may pass in an indefinite number of other arguments after
					the second argument, constituting the miscellaneous arguments list.

					By default, the United C compiler shall pass a string to Universal Preprocessor
					directives through the list passed to said directives. Said string shall be the
					first element within said list, followed by the contents of the miscellaneous
					arguments list, and shall contain "C" if the compiler detects the language to
					be C, and "C++" if the compiler detects the language to be C++.
				-

			Compilation

				-
					To compile an executable, the United C compiler shall only require the main
					file of said application.

					To compile a utility, the United C compiler shall require a flag indicating
					that it is compiling a utility as opposed to an executable as well as each file
					of the utility that is not included by any other file in said utility.
			
					If code written in United C uses any features that are in C++ but not in C, it
					shall be compiled as C++, and otherwise compiled as C.
				-

			Conventions

				-
					United C files should use the file extension ".uc".

					The United C Compiler may be abbreviated as "UCC".
				-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 2 - Kaeon United: 1 - Suite: 1 - Languages: 2 - C3: 2 - United C: 1 - Interface'

Kaeon FUSION United C Interface

	Philosophy

		-
			The Kaeon FUSION United C interface is a Kaeon FUSION interface that has the alias
			"United C", and which provides a Kaeon FUSION implementation of the United C
			transpilation function, implemented by way of causing the return value of the Kaeon
			FUSION process to be set to the transpiled C or C++ code generated by transpiling
			United C code passed to said process as the first argument.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 2 - Kaeon United: 1 - Suite: 1 - Languages: 2 - C3: 2 - United C: 2 - Library'

Kaeon United C Library

	Philosophy

		-
			The Kaeon United C library is a set of standard United C functions and constants, and a
			standard set of Universal Preprocessor directives for United C, which may be imported
			into a United C program via the path "kaeonUnited" in a use directive.
			
			Its preprocessor directives shall decide which external resources to import based on
			the usage of the utilities within them in the code into which it is imported.

			It shall include certain functions, called processed functions, which are not
			implemented in C or C++, but instead are transpiled to one of them by the Universal
			Preprocessor.

			It shall include stdio.h for both C and C++ code, and iostream for C++ code.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 2 - Kaeon United: 1 - Suite: 1 - Languages: 2 - C3: 2 - United C: 2 - Library: 1 - Functions: 1 - Processed: 1 - Print'

United C Print

	Philosophy

		-
			United C Print is a processed function for United C meant to take the place of printf
			and cout in situations where the data types of variables can be reasonably inferred.

			It shall have the alias "print", and may take an indefinite number of arguments.

			It shall print each of its arguments in order to the console according to their
			inferred data type.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 2 - Kaeon United: 1 - Suite: 2 - Tools: 1 - Kaeon Complex'

Kaeon Complex

	Philosophy

		-
			Kaeon Complex is a service integrated into Kaeon United and available via the command
			line which provides an interface to all of the cross builders within Kaeon Tempest,
			allowing various programming languages to be compiled and executed without having to
			manually install their compilers or runtime environments.
		-

	Principles

		Command Structure

			-
				Kaeon Complex shall take as its first command line argument the name of the
				language it is to work with, and shall take the path to the main file of the
				program it is to compile or execute as its second argument.
				
				Whether it compiles or executes the program is dependent on the language specified.

				Every argument following the second shall serve as command line arguments for
				executed programs.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 2 - Kaeon United: 2 - Conventions: 1 - Singularities: 1 - Standard'

Kaeon United Standard Singularities

	Philosophy

		-
			This document lists conventions for the Kaeon United standard singularities.
		-

	Principles

		Access

			-
				The Kaeon United standard singularities shall be hosted online so that users can
				use it via CDN regardless of the environment they are operating in.
			-

		Implementation

			-
				The Kaeon United standard singularities shall, unless otherwise specified, be
				implemented in JavaScript.
			-

		United JavaScript

			-
				The Kaeon United standard singularities shall, for the application singularities,
				run JavaScript code hosted through them as United JavaScript, with the singularity
				function accessible through the require function by the alias "kaeon-united".

				The library singularities of the Kaeon United standard singularities shall
				automatically cause the properties of United JavaScript to take effect in the host
				code when referenced.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 2 - Kaeon United: 2 - Conventions: 1 - Singularities: 1 - Standard: 1 - Terminal'

Kaeon United Terminal Singularities

	Philosophy

		-
			This document lists conventions for the Kaeon United terminal singularities.
		-

	Principles

		Auto-Caching

			-
				The Kaeon United terminal singularities shall use a standard auto-cache protocol
				when operating locally.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 2 - Kaeon United: 2 - Conventions: 1 - Singularities: 1 - Standard: 1 - Terminal: 1 - Application'

Kaeon United Terminal Application

	Philosophy

		-
			This document lists conventions regarding the Kaeon United terminal application
			singularity.
		-

	Principles

		Conventional Service

			-
				When executed via the command line, Kaeon United shall function as a conventional
				service.
				
				If installed globally via npm, the global command of Kaeon United shall be
				"kaeon-united", and it may also be executed via npx.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 2 - Kaeon United: 2 - Conventions: 1 - Singularities: 2 - Languages: 1 - United C'

Kaeon United UC Singularity

	Philosophy

		-
			Including Kaeon United as a United C import using the "use" operator on the alias
			"kaeon-united" shall import all of the standard and Kaeon United C or C++ utilities
			depending on the language detected.

			The imported libraries shall constitute the Kaeon United C Suite. Its contents shall
			vary for C and C++ respectively, and shall include stdio.h for C and iostream for C++.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 2 - Kaeon United: 2 - Conventions: 2 - Utilities: 1 - Components: 1 - Terminal'

Kaeon United Terminal Commands

	Philosophy

		-
			This document lists conventions regarding commands made available through the Kaeon
			United terminal application singularity.
		-

	Principles

		Commands

			Standard Commands

				-
					The Kaeon United terminal application singularity shall provide certain
					standard commands, including "process", which runs Kaeon FUSION code, "parse",
					which converts ONE+ code to ONE, "preprocess", which runs the Universal
					Preprocessor, "js", which runs United JavaScript, "ucc", which runs the United
					C compiler, "assemble", which compiles CSB, "disassemble", which disassembles
					CSB, and "ucm", which executes stringified UCM JSON objects.

					Both the process and js utilities, if run without specified source text, will
					run as console REPLs.
				-

			App Command

				-
					If the "app" command is executed with the Kaeon United terminal application
					singularity with an argument containing the module ID string of a United
					Javascript or Kaeon FUSION based application for which the source code is
					specified in a module referenced in the suite of the singularity, said
					application shall be executed, with all subsequent arguments of the app command
					which invoked it passed to it.
				-

		Use Argument

			-
				Any Kaeon United terminal command may be followed with the flag "-use", signaling
				that every subsequent argument is either the content of or the path to a Kaeon ACE
				document to integrate into the suite of the singularity for the duration of the
				process.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 2 - Kaeon United: 2 - Conventions: 2 - Utilities: 1 - Components: 1 - Terminal: 1 - Kaeon Origin'

Kaeon Origin Axis

	Philosophy

		-
			When the Kaeon United terminal singularity is executed with no arguments, or executed
			with the argument "origin", it shall execute Kaeon Origin which shall host an axis web
			server within it, and in this mode, Kaeon Origin shall be referred to as Kaeon Origin
			Axis.
		-

	Principles

		Processes

			Arguments

				-
					If Kaeon Origin Axis is executed with the argument "origin", any subsequent
					arguments shall be processed normally but within the environment of Kaeon
					Origin Axis.
				-

			UCM

				-
					If a GET request is sent to Kaeon Origin Axis with a URL argument with the
					alias "ucm", containing a stringified UCM JSON object, the contents of said
					object shall be executed by the server and any value returned shall be returned
					in string form in the body of the response.
				-

			Virtual System

				-
					In the case of Kaeon Origin Axis, the virtual system loaded by the client shall
					be that of the Kaeon Origin application.
				-

		Security

			-
				The functionality of Kaeon Origin Axis may be limited in certain contexts for
				security purposes.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 2 - Kaeon United: 2 - Conventions: 2 - Utilities: 1 - Components: 2 - Browser'

Kaeon United Browser Requests

	Philosophy

		-
			This document lists conventions regarding requests made to the Kaeon United browser
			application singularity.
		-

	Principles

		Requests

			Shadow Host

				-
					If the Kaeon United browser application singularity is used as a shadow host,
					it may have the URL arguments "UnitedJS", "UnitedJSRaw", "UnitedOP",
					"UnitedOPRaw", "HTML", and "HTMLRaw".

					UnitedJS, if present, shall specify the path to a United JavaScript file which
					shall be executed.

					UnitedJSRaw, if present, shall specify United JavaScript code which shall be
					executed.

					UnitedOP, if present, shall specify the path to a Kaeon FUSION file which shall
					be executed.

					UnitedOPRaw, if present, shall specify the path to a Kaeon FUSION file which
					shall be executed.

					HTML, if present, shall specify the path to an HTML file which shall be
					rendered.

					If more than one of the aforementioned arguments are present, the JavaScript,
					if given, shall execute first, the Kaeon FUSION, if given, shall execute next,
					and the HTML, if given, shall be rendered last.
				-

			Applications

				-
					If a request is made to the Kaeon United browser application singularity with
					the URL argument "app", and said argument contains the module ID string of a
					United Javascript or Kaeon FUSION based application for which the source code
					is specified in a module referenced in the suite of the singularity, the page
					shall load said application, and shall pass along all URL arguments passed to
					it except for "app".
				-

		Use Argument

			-
				The Kaeon United browser application singularity may have the argument "use",
				containing a stringified JSON list of strings, each of which is either the content
				of or the path to a Kaeon ACE document to integrate into the suite of the
				singularity for the duration of the process.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 2 - Kaeon United: 2 - Conventions: 2 - Utilities: 1 - Components: 2 - Browser: 1 - Kaeon Origin'

Kaeon Origin Application

	Philosophy

		-
			If no arguments are present in a request to the Kaeon United browser application
			singularity, a page containing the Kaeon Origin shall be rendered, with Kaeon Origin in
			this mode being referred to as the Kaeon Origin application.
		-

	Principles

		Conventions

			Alias

				-
					The application aliases of the Kaeon Origin Application shall be "origin" and
					"kaeon-origin".
				-

			Default Configurations

				-
					The default content's of the Kaeon Origin Application's file system and the
					commands it shall execute by default on startup shall be stored in a system
					JSON file, called the default configuration file, at a fixed online location.
				-

			Open Axis

				-
					The Kaeon Origin application shall implement Open Axis, and shall provide the
					"call" command, which shall perform an open traversal with an axis packet
					consisting of a string list of the arguments passed to said command.
				-

			Virtual System

				-
					The Kaeon Origin Application shall operate as a conventional virtual system.
				-

		Kaeon United

			-
				Kaeon Origin's virtual system shall provide access to the CLI functionality of
				Kaeon United.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 2 - Kaeon United: 2 - Conventions: 2 - Utilities: 1 - Components: 2 - Browser: 1 - Kaeon Origin: 1 - Oracle'

Kaeon Oracle Conventions

	Philosophy

		-
			This document lists conventions for Kaeon Oracle, which shall be implemented as a
			conventional dynamic response platform.
		-

	Principles

		Core Module

			-
				The core module of Kaeon Oracle shall have the alias "meta" when executed as a
				command via the virtual system.
			-

		Wake Phrase

			-
				Kaeon Oracle's speech observer shall use the wake phrase "Hey Meta".
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 2 - Kaeon United: 2 - Conventions: 2 - Utilities: 1 - Components: 2 - Browser: 1 - Kaeon Origin: 2 - Yggdrasil'

Kaeon Yggdrasil Conventions

	Philosophy

		-
			Kaeon Yggdrasil shall manifest as an open environment into which VR and AR elements,
			called Kaeon Yggdrasil elements, can be dynamically loaded and dismissed.
		-

	Principles

		Kaeon Origin

			-
				Kaeon Yggdrasil shall initiate as a process if the Kaeon Origin application is
				accessed on a browser from within a virtual or cross reality headset, but will be
				empty by default until populated by the Kaeon Origin application.
			-

		Kaeon Valhalla

			-
				Kaeon Valhalla may be initiated from within Kaeon Yggdrasil, enveloping the user in
				an open universe simulation while maintaining the presence of the browser and the
				present Kaeon Yggdrasil elements until they are dismissed.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 2 - Kaeon United: 2 - Conventions: 2 - Utilities: 2 - Libraries'

Kaeon United Library Conventions

	Philosophy

		-
			This document lists conventions regarding libraries present within Kaeon United.
		-

	Principles

		Kaeon United

			Alternate Alias

				-
					In addition to "Kaeon United", Kaeon United may also use the alias "KU".
				-

		Kaeon Core

			Main

				-
					The Kaeon United main interface is a philosopher's interface referenced by the
					Kaeon United interface.

					The Kaeon United main interface contains the majority of all utilities within
					Kaeon United pertaining to the fundamental use of Kaeon United.

					The package path of utilities under the Kaeon United main interface is
					"kaeonUnited", "core", "main".
				-

			General

				-
					The Kaeon United general interface is a philosopher's interface referenced by
					the Kaeon United interface.

					The Kaeon United general interface contains the majority of all utilities
					 within Kaeon United pertaining to third party services.

					The package path of utilities under the Kaeon United main interface is
					"kaeonUnited", "core", "general".
				-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 1 - Conventions: 3 - Tools: 2 - Kaeon United: 2 - Conventions: 2 - Utilities: 2 - Libraries: 1 - Kaeon META'

Kaeon United META Library

	Philosophy

		-
			The Kaeon United META library is a library utility within Kaeon United which exports a
			function (which in camel case shall be called "kaeonMETA") that takes a string
			containing a Kaeon META command, executes said command, and returns whatever value was
			returned by Kaeon META.

			The utility path of the Kaeon United META library is "kaeonUnited", "main",
			"kaeonMETA".
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard'

Kaeon FUSION Standard Interface
	
	Philosophy
		
		-
			The Kaeon FUSION standard interface provides commands that allow users to write Turing
			complete scripts in Kaeon FUSION.
		-
	
	Principles

		Access
		
			Alias
				
				-
					The Kaeon FUSION standard interface may be referenced using the alias
					"Standard".
				-
			
			Case Sensitivity
				
				-
					All of the commands provided by the Kaeon FUSION standard interface do not take
					letter case into account.
				-

			Kaeon United

				-
					The Kaeon FUSION standard interface shall be included in the Kaeon United
					FUSION interface.
				-
		
		Effects

			Properties
			
				Use
				
					-
						When the standard interface is in effect, Kaeon FUSION's use command will
						have priority over all other commands, and will integrate interfaces
						according to the string forms of the values returned by its children
						instead of the content of said children.
					-
				
				Data
					
					-
						The Kaeon FUSION Standard Interface establishes a state that stores data
						between commands.
						
						Every item stored in the state will have a string alias to identify it. The
						data stored within the item may be of any data type. Certain items may be
						declared as global. The Kaeon FUSION Standard Interface also allows
						commands to return promises, which will eventually resolve to another
						value.
						
						After a command is processed, items in the state generated by its children
						that are not global are deleted. If FUSION jumps, items in the state not
						generated by the parent, grandparents, and the preceding siblings of the
						parents and grandparents of the element it landed on that are not global
						will be deleted.

						At any time the state may be serialized to a dynamic list.
					-
				
				Exceptions
					
					-
						If an exception is thrown by a command while the standard interface is
						active, all subsequent commands will cease to process until the exception
						is caught, the the flow of the FUSION process will continue as normal.
					-
			
			Host Environment
				
				Arguments
				
					-
						The host environment of a script using the standard interface may pass an
						indefinite number of arguments to the script.
					-
				
				Console
					
					-
						The host environment of a script using the standard interface may provide
						an alternate console for the script to output to. By default, the console
						is standard out.
					-
				
				Build Workspace
					
					-
						In addition to the workspaces present by default in Kaeon FUSION, the
						standard interface also allows the host environment to specify a single
						build workspace, which in addition to becoming part of the workspace, will
						also serve as the default directory for file output.
						
						By default, the build workspace is the local directory.
					-

				DOM

					-
						The host environment for the Kaeon FUSION standard interface may provide an
						HTML DOM with which a Kaeon FUSION script may interface.

						If elements are injected into the DOM in HTTP JSON format or any analogue
						to it, any objects in function JSON format or any analogue to it shall be
						converted into functions.
					-
		
		Conventions

			FUSION Process

				-
					Unless otherwise specified, the effects specified for any command provided by
					the standard interface shall activate at step three of the FUSION process.
				-
		
			Implicit Casting
				
				-
					Values stored within the state have types, but, if possible, will be implicitly
					cast when passed as arguments to a command requiring parameters of a different
					type.
				-
			
			Lists
				
				Strings in List Operations
					
					-
						Strings will be interpreted as lists where each character is an element
						when used as arguments in list operations.
					-

				List Indexes
					
					-
						Commands in the standard interface that pertain to lists use indexes that
						start at one. If a command attempts to access or modify an index of a list
						that does not exist, the list will be resized to accommodate the index.
					-
				
				Dynamic Lists

					-
						Lists used by the standard interface will be dynamic lists, which shall
						also serve as de facto objects.
					-
				
				Node Value Equivalence

					-
						Node value equivalence shall apply to all values and lists used by the
						standard interface.
					-
		
			Formats

				State Serialization Format

					-
						When the state is serialized as a list, said list is encoded in the state
						serialization format.

						Each item in the state is encoded as a list called an item list which has
						two elements, the first being the alias and the second being the value.

						Each scope in the state will be stored as a scope list, which shall contain
						an indefinite amount of item lists.

						The state itself shall be encoded as a list called the state list, with
						each scope of said state being represented as a scope list, where the first
						scope list shall represent the global scope, and each subsequent list shall
						represent a local scope, arranged according to their order on the current
						scope stack.
					-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 1 - Undefined: 1 - Literals'

Literals
	
	Philosophy
		
		-
			A command with content that does not match the name of a defined command or any alias
			in the state and has no children will return its content as a string.
			
			If its content begins and ends with a double quote, the double quotes will be cropped
			from the returned content.
			
			Any sequence within the returned string consisting of a backslash followed by another
			character will be interpreted based on what the second character in the sequence is,
			with an 'n' denoting a new line, a 't' denoting a tab, and any other character denoting
			itself.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 1 - Undefined: 2 - Variables'

Variables
	
	Philosophy
		
		-
			A command with content that does not match the name of a defined command or any alias
			in the state and which has one child will create an item in the state with the item's
			value being the object returned by the command's child and the item's alias being the
			command's content.
			
			A command with content that matches an alias of an item that is not a function
			definition in the state will, if it has children, assign the object returned by its
			first child to the item that corresponds to the alias, and regardless of whether or not
			it has children, will return the value of the item that corresponds to the alias.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 1 - Data: 1 - Define'

Define
	
	Philosophy
	
		-
			The define command contains the content "Define" and may have an indefinite number of
			children. It does not trickle down.
			
			It will return an element in ONE list form equal to itself with no content with all the
			elements in its scope.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 1 - Data: 10 - Form'

Form

	Philosophy
	
		-
			The form command contains the content "Form". It must have a single child that may
			return any object.
			
			It will return the string "Boolean" if the string form of the returned object matches a
			boolean value, the string "Number" if the string form of the returned object matches a
			numerical value, and the string "String" if the string form of the returned object does
			not match a boolean or a numerical value.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 1 - Data: 11 - Is Command'

Is Command

	Philosophy
	
		-
			The is command command contains the content "Is Command". It must have a single child
			that returns a string.
			
			It will return true if the returned string would be interpreted as a command other than
			a literal, variable, or function call if it were the content of a Kaeon FUSION command.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 1 - Data: 12 - Is Variable'

Is Variable

	Philosophy
	
		-
			The is variable command contains that content "Is Variable". It has one child that
			returns a string and may optionally have a second child that returns a boolean.
			
			It will return true if there is a variable alias in the state that matches the returned
			string. If the second child is present and returned false, then the command will only
			check the local scope. If the second child is present and returned true, then the
			command will only check the global scope.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 1 - Data: 13 - Destroy'

Destroy

	Philosophy
	
		-
			The destroy command contains that content "Destroy". It has one child that returns a
			string and may optionally have a second child that returns a boolean.
			
			It will delete any variable alias in the state that matches the returned string. If the
			second child is not present or returned false, then the command will only delete values
			in the local scope. If the second child is present and returned true, then the command
			will only delete values in the global scope.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 1 - Data: 14 - Variables'

Variables

	Philosophy
	
		-
			The variables command contains the content "Variables". It may optionally have a child
			that returns a boolean value.
			
			It returns a list of all variable aliases stored in the state. If it has a child and
			the child returns false, then the list will only contain aliases from the local scope.
			If it has a child and the child returns true, then the list will only contain aliases
			from the global scope.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 1 - Data: 15 - Get Code'

Get Code

	Philosophy
	
		-
			The get code command contains the content "Get Code".
			
			It returns the root element of the script it was called from in ONE list form.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 1 - Data: 16 - Get Code Index'

Get Code Index

	Philosophy
	
		-
			The get code index command contains the content "Get Code Index".
			
			It creates a list, and then starting from the command that called it, adds the index of
			said command to the beginning of said list, and trickles up to said command's parent
			until it reaches the root. It then returns the generated list.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 1 - Data: 17 - With'

With

	Philosophy
	
		-
			The with command contains the content "With". It has two children, the first of which
			returns a string or a list and the second of which returns a list.
			
			It will execute a command where, if the first child returned a string then said string
			shall be the content of the command, and if the first child returned a list then the
			list is the command in ONE list form, and the elements of the list returned by the
			second child are the values passed to the command by its children. It will then return
			the value returned by the command.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 1 - Data: 18 - Disable'

Disable

	Philosophy
	
		-
			The disable command contains the content "Disable". It may have an indefinite number of
			children, where each of the string forms of the values they return are used to activate
			a given command.
			
			It disables the commands activated by the string forms of the returned values.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 1 - Data: 19 - Enable'

Enable

	Philosophy
	
		-
			The enable command contains the content "Enable". It may have an indefinite number of
			children, where each of the string forms of the values they return are used to activate
			a given command.
			
			It re-enables the commands activated by the string forms of the returned values that
			have been disabled by the disable command.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 1 - Data: 2 - Global'

Global
	
	Philosophy
	
		-
			The global command contains the content "Global" and may have an indefinite number of
			children.
			
			The content of each child will become a global alias in the state.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 1 - Data: 20 - Lock Down'

Lock Down

	Philosophy
	
		-
			The lock down command contains the content "Lock Down". It may have an indefinite
			number of children, where each of the string forms of the values they return are used
			to activate a given command.
			
			It permanently disables the commands activated by the string forms of the returned
			values.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 1 - Data: 21 - Reflect'

Reflect

	Philosophy
	
		-
			The reflect command contains the content "Reflect". It must have eight children, each
			of which either return an element in ONE list form or a null value.
			
			Every returned value corresponds to a function in a FUSION unit as defined by the
			FUSION interpreter architecture, with the first corresponding to the deny function, the
			second corresponding to the verify function, the third corresponding to the trickle
			down function, the fourth corresponding to the process function, the fifth
			corresponding to the terminate function, the sixth corresponding to the is added
			function, the seventh corresponding to the jump function, and the eighth corresponding
			to the handle error function.
			
			A FUSION unit will be generated by the command where, if an element in ONE list form is
			returned, the FUSION unit function corresponding to the value that returned the element
			will be overridden by said element as Kaeon FUSION code.
			
			All of said functions will take a ONE element in extended ONE list form as their first
			argument, with the process, terminate, is added, jump, and handle error functions
			taking a list of objects representing the values returned by said ONE element's
			children as their second argument, and with the handle error function taking a string
			containing an error message as its third argument.
			
			If the jump function returns an element, said element will be in extended ONE list
			form.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 1 - Data: 22 - Interpreter'

Interpreter

	Philosophy
	
		-
			The interpreter command contains the content "Interpreter".
			
			It returns a reference to the interpreter that FUSION is running on if it is an object
			within the host environment, and returns null otherwise.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 1 - Data: 23 - Listen'

Listen

	Philosophy
	
		-
			The listen command contains the content "Listen". It may have an indefinite number of
			children, each of which return a list.
			
			If the interpreter receives packets from its host environment, their contents will be
			appended to any lists that at any point were passed to a listen command through said
			command's children.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 1 - Data: 24 - Be'

Be
	
	Philosophy
		
		-
			The be command is a command with the content "Be". It has one child that returns a list
			containing a serialized state in state serialization format.

			It replaces the current state with the state serialized in the returned list.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 1 - Data: 25 - Call'

Call
	
	Philosophy
		
		-
			The call command contains the content "Call".
			
			It sends the host environment of Kaeon FUSION a packet containing all of the objects
			returned by its children. The operation that is then performed and the value that the
			command returns are dependent on the implementation of the host environment and on the
			interfaces currently in use.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 1 - Data: 26 - Direct'

Direct

	Philosophy

		-
			The direct command contains the content "Direct". It may have either one or two
			children, each of which return a string, where if both are present, the first shall
			specify the name of a programming language or environment and the second shall contain
			code for said language or environment, and if only one is present, it shall contain
			code for a given programming language or environment.

			The direct command shall execute the returned code, where if a language or environment
			was specified, it shall be executed in said language or environment, and if a language
			or environment was not specified, the language or environment shall be detected
			automatically, and the result of the executed code shall be returned by the direct
			command.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 1 - Data: 27 - Optimize'

Optimize

	Philosophy

		-
			The optimize command contains the content "Optimize". It has one child which returns a
			ONE element in ONE list form, and may optionally have a second child that returns a
			list.

			The optimize command shall, while using the contents of the list returned by the second
			child if it is present, analyze the element returned by the first child as Kaeon FUSION
			code and return an optimized version of said Kaeon FUSION code as a ONE element in ONE
			list form.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 1 - Data: 28 - Inject'

Inject

	Philosophy
	
		-
			The inject command contains the content "Inject". It has one child, which shall return
			a ONE element, either as a ONE+ string or in ONE list form.
			
			It will replace itself within the script it belongs to with the element returned by its
			child.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 1 - Data: 3 - Do'

Do

	Philosophy

		-
			The do command contains the content "Do". It shall have between one and three children,
			the first of which shall return an element in ONE list form, the second of which, if
			present, shall return a list, the contents of which may be anything, and the third of
			which, if present, shall return a boolean.

			It shall virtually execute the element defined by the first list with its own return
			value and a new state, sharing the values stored in the global state, with the second
			list, if present, defining arguments for the element to execute with. After the
			execution, the do command shall return the value of the new return value. If the third
			child is present and returned true, the command shall execute asynchronously and shall
			return a promise which shall resolve to the aforementioned value.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 1 - Data: 4 - Arguments'

Arguments
	
	Philosophy
		
		-
			The arguments command contains the content "Arguments"
			
			If called within a function or script to which arguments were passed, it returns said
			arguments in the form of a list.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 1 - Data: 5 - This'

This
	
	Philosophy
		
		-
			The this command contains the content "This".
			
			It returns a list containing the serialized contents of the state.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 1 - Data: 6 - New'

New
	
	Philosophy
		
		-
			The new command contains the content "New".
			
			It has one child that executes a Kaeon FUSION script virtually. It returns the contents
			of the state of the virtually executed script serialized as a list.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 1 - Data: 7 - Null'

Null
	
	Philosophy
		
		-
			The null command contains the content "Null".
			
			It returns a null value.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 1 - Data: 8 - Literal'

Literal
	
	Philosophy
		
		-
			The literal command contains the content "Literal". It must have a single child.
			
			It returns the content of its child.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 1 - Data: 9 - Type'

Type
	
	Philosophy
		
		-
			The type command contains the content "Type". It must have a single child.
			
			It returns the type of the value returned by its child.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 10 - Philosopher~'s Stone: 1 - Connect'

Connect

	Philosophy

		-
			The connect command is a command with the content "Connect". It has between three and
			five children, the first of which shall return a list containing the state of a
			Philosopher's Atlas, the second and third of which may return any value, the fourth of
			which, if present, shall return a list of Kaeon FUSION scripts in ONE list form, and
			the fifth of which, if present, shall return a boolean.

			It forms a connection in the returned philosopher's atlas from the value returned by
			the second child to the value returned by the third child, and if the fifth child is
			present and returns true then also from the value returned by the third child to the
			value returned by the second child, and if the fourth child is present the scripts it
			returns shall serve as atlas policies for the new connections, taking a given traversal
			path in the form of a list as an argument. Any pre-existing connections between the
			connected values shall be overridden.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 10 - Philosopher~'s Stone: 2 - Disconnect'

Disconnect

	Philosophy

		-
			The disconnect command is a command with the content "Disconnect". It has either three
			or four children, the first of which shall return a list containing the state of a
			Philosopher's Atlas, the second and third of which may return any value, and the fourth
			of which, if present, shall return a boolean.

			It removes connections in the returned philosopher's atlas from the value returned by
			the second child to the value returned by the third child, and if the fourth child is
			present and returns true then also from the value returned by the third child to the
			value returned by the second child.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 10 - Philosopher~'s Stone: 3 - Is Connected'

Is Connected

	Philosophy

		-
			The is connected command is a command with the content "Is Connected". It has between
			three and five children, the first of which shall return a list containing the state of
			a Philosopher's Atlas, the second and third of which may return any value, the fourth
			of which, if present, shall return a list of Kaeon FUSION scripts in ONE list form, and
			the fifth of which, if present, shall return a boolean.

			If a connection exists in the returned philosopher's atlas from the value returned by
			the second child to the value returned by the third child, and if the fifth child is
			present and returns true then also from the value returned by the third child to the
			value returned by the second child, and if the fourth child is present the scripts it
			returns serve as atlas policies for the specified connections, then it shall return
			true, and return false otherwise.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 10 - Philosopher~'s Stone: 4 - Get Connections'

Get Connections

	Philosophy

		-
			The get connections command is a command with the content "Get Connections". It has two
			children, the first of which shall return a list containing the state of a
			Philosopher's Atlas, and the second of which may return any value.

			It returns all values that the value returned by the second child is connected to in
			the returned Philosopher's Atlas.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 10 - Philosopher~'s Stone: 5 - Get Policies'

Get Policies

	Philosophy

		-
			The get policies command is a command with the content "Get Policies". It has three
			children, the first of which shall return a list containing the state of a
			Philosopher's Atlas, and the second and third of which may return any value.

			It returns all Kaeon FUSION scripts in ONE list form that serve as connection policies
			for the connection from the value returned by the second child to the value returned by
			the third child within the returned Philosopher's Atlas.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 10 - Philosopher~'s Stone: 6 - Traverse'

Traverse

	Philosophy

		-
			The traverse command is a command with the content "Traverse". It has two children, the
			first of which shall return a list containing the state of a Philosopher's Atlas, and
			the second of which may return any value.

			It performs a traversal of the returned Philosopher's Atlas starting at the value
			returned by the second child, and returns a list of all values traversed across during
			said traversal.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 10 - Philosopher~'s Stone: 7 - Train'

Train

	Philosophy

		-
			The train command is a command with the content "Train". It has four children, the
			first of which shall return a list containing the corpus of a SOUL, the second and
			third of which may return any value, and the fourth of which shall return a number
			between zero and one, inclusive.

			It trains the returned corpus by correlating the value returned by the second child as
			input to the value returned by the third child as output. The correlation shall be
			assumed to be one to one by default if the fourth child is not present, otherwise the
			correlation shall be specified by the value returned by the fourth child.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 10 - Philosopher~'s Stone: 8 - Generate'

Generate

	Philosophy

		-
			The generate command is a command with the content "Generate". It may have either two
			or three children, the first of which shall return a list containing the corpus of a
			SOUL, the second of which may return any value, the third of which shall return a
			number between zero and one, inclusive.

			It shall generate and return a value that correlates as output to the value returned by
			the second child as input with a one to one correlation if the third child is not
			present and with the correlation specified by the third child if it is present
			according to the returned corpus.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 10 - Philosopher~'s Stone: 9 - Correlate'

Correlate

	Philosophy

		-
			The correlate command is a command with the content "Correlate". It has three children,
			the first of which shall return a list containing the corpus of a SOUL, and the second
			and third of which may return any value.

			It shall determine and return a value between zero and one, inclusive, corresponding to
			the correlation between the value returned by the second child as input and the value
			returned by the third child as output according to the returned corpus.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 11 - UI: 1 - Get UI'

Get UI

	Philosophy

		-
			The get UI command is a command with the content "Get UI". It may have an indefinite
			number of children, each of which return strings containing CSS selectors.

			It shall return all elements in the host DOM, if present, that match any of the
			specified selectors, each as a dynamic list corresponding to a DOM JSON representation
			of the corresponding element.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 11 - UI: 2 - Set UI'

Set UI

	Philosophy

		-
			The set UI command is a command with the content "Set UI". Its first child shall return
			a dynamic list representing a DOM element in DOM JSON format, and it may have an
			indefinite number of additional children, each of which shall return strings specifying
			CSS selectors.

			It shall find each of the elements present in the host DOM, if present, that match the
			specified CSS selectors and modify their properties to match the specified properties
			of the returned element.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 11 - UI: 3 - Extend UI'

Extend UI

	Philosophy

		-
			The extend UI command is a command with the content "Extend UI". Its first child may
			return a string containing a CSS selector, and it may have an indefinite number of
			other children which return dynamic lists representing DOM elements in DOM JSON format.

			If the first child returned a string, it shall append all of the specified elements to
			the first existing element matching the specified selector in the host DOM, if present,
			and if the first child did not return a string, it shall append said elements to the
			root of the host DOM, if present.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 11 - UI: 4 - Delete UI'

Delete UI

	Philosophy

		-
			The delete UI command is a command with the content "Delete UI". It may have an
			indefinite number of children, each of which return strings containing CSS selectors.

			It shall delete all of the elements matching the returned selectors within the host
			DOM, if present.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 11 - UI: 5 - Specify UI'

Specify UI

	Philosophy

		-
			The specify UI command is a command with the content "Specify UI". It shall have an
			indefinite number of children, each of which return a list containing a string
			specifying a CSS selector as its first element and either a dynamic list representing a
			DOM element in DOM JSON format or a null value as its second element.

			Every returned list shall establish a rule in the host DOM, if present, that any
			element matching the specified selector in the host DOM shall have the specified
			properties of the specified element, if said element is not null.

			Subsequent uses of this command may override rules established by previous uses of it
			if the same selector is used, and said rules may be erased if the specified elements
			are null.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 11 - UI: 6 - Load UI'

Load UI

	Philosophy

		-
			The load UI command is a command with the content "Load UI". It shall have an
			indefinite number of children, each of which shall return a string specifying a path
			to either a JavaScript script or to a CSS stylesheet.

			It shall load all of the specified resources into the host DOM, if present.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 11 - UI: 7 - HTML to DOM'

HTML to DOM

	Philosophy

		-
			The HTML to DOM command is a command with the content "HTML to DOM". It shall have a
			single child which returns a string containing an HTML element.

			It shall return a dynamic list representing the specified HTML element in DOM JSON.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 11 - UI: 8 - DOM to HTML'

DOM to HTML

	Philosophy

		-
			The DOM to HTML command is a command with the content "DOM to HTML". It shall have a
			single child which returns a dynamic list representing an HTML element in DOM JSON.

			It shall return an HTML string representing the specified element.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 2 - Flow Control: 1 - Return'

Return
	
	Philosophy
		
		-
			The return command contains the content "Return", and may have an indefinite number of
			children.
			
			It prevents any subsequent commands in the script or function from which it is called
			from executing. If it has no children, it will return a null value. If it has one
			child, it will return the value returned by its child. If it has more than one child,
			it will return all of the values returned by its children in a list. It will set Kaeon
			FUSION's return value to whatever it returned.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 2 - Flow Control: 10 - Split'

Split
	
	Philosophy
		
		-
			The split command contains the content "Split".
			
			It does not trickle down and executes all of its children in a new Kaeon FUSION script
			on a new thread using a deep copy of the state of the script or function from which it
			was called.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 2 - Flow Control: 11 - Run'

Run
	
	Philosophy
		
		-
			The run command contains the content "Run". It may have an indefinite number of
			children, each of which return a string.
			
			It runs each returned string as a command line call, and returns a list of lists, one
			for each returned string, arranged in the order said strings were returned, where each
			sublist contains three lists. Any output from a spawned process to standard output will
			be appended to the first list in the list that corresponds to the string that spawned
			said process. The spawned process that was spawned by the string that corresponds to a
			given list may access the string form of any object in said list's second list through
			standard in. Any output from a spawned process to standard error will be appended to
			the third list in the list that corresponds to the string that spawned said process.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 2 - Flow Control: 12 - Automatic Catch'

Automatic Catch

	Philosophy
	
		-
			The automatic catch command contains the content "Automatic Catch". It must have a
			single child that returns a boolean.
			
			If the returned boolean is true, exceptions thrown following the execution of the
			command will be automatically caught. If the returned boolean is false, exceptions
			thrown following the execution of the command will not be automatically caught.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 2 - Flow Control: 13 - Throw'

Throw
	
	Philosophy
		
		-
			The throw command contains the content "Throw". It may have one or two children, one of
			which is a boolean and the other of which is a string.
			
			If the boolean argument is not present, or if it is true, it will throw an exception,
			which, if the string argument is present, shall contain said string as its message,
			preventing any subsequent commands from executing until the exception is caught.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 2 - Flow Control: 14 - Exit'

Exit
	
	Philosophy
		
		-
			The exit command contains the string "Exit".
			
			It completely stops the execution of Kaeon FUSION.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 2 - Flow Control: 15 - Exception'

Exception
	
	Philosophy
		
		-
			The exception command contains the string "Exception".
			
			It returns the reason for the most recently thrown exception as a string.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 2 - Flow Control: 16 - Retrieve'

Retrieve

	Philosophy
	
		-
			The retrieve command contains the content "Retrieve". It may have an indefinite number
			of children.
			
			It will generate a value that is either the value returned by its first child if
			exactly one value was returned to it, or a list of all of the values returned to it
			otherwise. If its parent command has content and would otherwise return a null value,
			it will instead return the generated value.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 2 - Flow Control: 17 - Shift'

Shift

	Philosophy
	
		-
			The shift command contains the content "Shift". Its first child must return a list
			representing a ONE element in ONE list form. It may optionally have a second child that
			returns a list of integer numbers.
			
			The shift command will generate a ONE element from the first list. If a second list was
			not returned, FUSION will jump to the root of the generated element. If a second list
			was returned, the shift command will trickle down the generated element at the indexes
			specified by the integers in the second list, and will jump to the element it lands on.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 2 - Flow Control: 18 - Flip'

Flip

	Philosophy
	
		-
			The flip command contains the content "Flip". Its first child returns a boolean, and it
			may optionally have a second child that also returns a boolean.
			
			If the returned boolean is true, the command will reverse the order of all of the
			elements in the scope of the root of the elements that FUSION is acting on, causing the
			program to flow in reverse. If the second child is present and returns true, the
			command will only affect the elements within the scope of the command's parent element.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 2 - Flow Control: 19 - Block'

Block
	
	Philosophy
		
		-
			The block command contains the content "Block". It does not trickle down.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 2 - Flow Control: 2 - Catch'

Catch
	
	Philosophy
		
		-
			The catch command contains the content "Catch".
			
			Unless an exception was thrown by a previous command, it will not trickle down. If it
			does trickle down, it will catch any exception thrown by a previous command as it does
			so, and will return true, returning false otherwise.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 2 - Flow Control: 20 - Ternary'

Ternary

	Philosophy
	
		-
			The ternary command contains the content "Ternary". It may have either two or three
			children, the first of which returns a boolean and the second, and third of which, if
			present, may return any value.
			
			If the boolean value returned by its first child is true, it will return the value
			returned by its second child, and otherwise will return null if the third child is not
			present and will return the value returned by its third child if said child is present.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 2 - Flow Control: 21 - Isolate'

Isolate

	Philosophy
	
		-
			The isolate command contains the content "Isolate".
			
			It will prevent any command within its scope from modifying the state of the script it
			was called from.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 2 - Flow Control: 22 - Vanish'

Vanish

	Philosophy
	
		-
			The vanish command contains the content "Vanish".
			
			After all of the commands within its scope have been executed, it will be removed from
			the script it belongs to.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 2 - Flow Control: 23 - Reverse Catch'

Reverse Catch

	Philosophy
	
		-
			The reverse catch command contains the content "Reverse Catch".
			
			Unless an exception was thrown by a previous command, it will not trickle down. If it
			does trickle down, commands within its scope will be executed despite the exception
			that triggered it, but said exception will not be caught by the reverse catch command.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 2 - Flow Control: 24 - For'

For

	Philosophy
	
		-
			The for command contains the content "For" and has two children, the first of which
			returns an integer number or a list, and the second of which returns a ONE element in
			ONE list form.
			
			If the value returned by the first child is a number, it shall execute the returned ONE
			element as Kaeon FUSION code for the number of iterations specified by the returned
			number, where upon each iteration it shall pass to said code the index of the current
			iteration, starting at one. If the value returned by the first child is a list, it will
			execute the returned ONE element as Kaeon FUSION code for each element in the returned,
			where upon each iteration it shall pass to said code the element of the list
			corresponding to the current iteration.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 2 - Flow Control: 25 - If'

If

	Philosophy
	
		-
			The if command contains the content "If" and has two children, the first of which
			returns a boolean, and the second of which returns a ONE element in ONE list form.
			
			If the value returned by the first child is true, it shall execute the returned ONE
			element as Kaeon FUSION code.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 2 - Flow Control: 26 - While'

While

	Philosophy
	
		-
			The while command contains the content "While" and has two children, each of which
			return a ONE element in ONE list form.
			
			It will execute the element returned by the first child as Kaeon FUSION code, and if it
			returns a value of true, it shall execute the element returned by the second child as
			Kaeon FUSION code and then repeat then process.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 2 - Flow Control: 27 - Await'

Await

	Philosophy

		-
			The await command contains the content "Await".
			
			It will block the execution of subsequent commands outside its scope until all promises
			returned to it by its children have resolved and all operations within new threads and
			processes created by elements within its scope have ceased.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 2 - Flow Control: 3 - Catch Enabled'

Catch Enabled

	Philosophy
	
		-
			The catch enabled contains the content "Catch Enabled".
			
			It returns true if automatic exception catching enabled using the automatic catch
			command is currently in effect, and returns false otherwise.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 2 - Flow Control: 4 - Scope'

Scope

	Philosophy
	
		-
			The scope command is a command with the content "Scope".
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 2 - Flow Control: 5 - Execute'

Execute
	
	Philosophy
		
		-
			The execute command contains the content "Execute", and may have an indefinite number
			of children, each of which return a list representing a ONE element in ONE list form.
			
			It will interpret each returned list as a ONE element and execute said elements in
			order as Kaeon FUSION code within the namespace of the script or function it was called
			from.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 2 - Flow Control: 6 - Break'

Break
	
	Philosophy
		
		-
			The break command contains the content "Break". It may have any combination of a child
			that returns a boolean and a child that returns a positive integer number.
			
			If it has a child that returns a boolean value of false, it will not execute.
			Otherwise, it will prevent its siblings from executing, and if it has a child that
			returns a number, will bubble up its parent connections for the as many times as
			specified by the returned number and prevent any siblings of the command it lands on as
			well as any commands within its scope from executing.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 2 - Flow Control: 7 - Else'

Else
	
	Philosophy
		
		-
			The else command contains the content "Else".
			
			It will only trickle down if the most recently called break command nested beneath one
			of its preceding siblings had a child that returned false.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 2 - Flow Control: 8 - Loop'

Loop
	
	Philosophy
		
		-
			The loop command contains the content "Loop". It may have any combination of a child
			that returns a boolean and a child that returns a positive integer number.
			
			If it has a child that returns a boolean value of false, it will not execute.
			Otherwise, if it does not have a child that returns a number, it will jump to the first
			child of its parent, and if it does have a child that returns a number, it will bubble
			up its parent connections for as many times as specified by the returned number and
			will jump to the first child of the parent of the element that it lands on.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 2 - Flow Control: 9 - Wait'

Wait
	
	Philosophy
		
		-
			The wait command contains the content "Wait", and has one child that returns a number.
			
			It will pause the execution of the script or function from which it was called for the
			number of seconds specified by the number returned by its child.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 3 - Console: 1 - Log'

Log

	Philosophy
	
		-
			The log command is a command with the content "Log".
			
			It prints all of the objects returned to it to the console.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 3 - Console: 2 - Log Line'

Log Line
	
	Philosophy
	
		-
			The log line command is a command with the content "Log Line".
			
			It prints all of the objects returned to it followed by a new line to the console.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 3 - Console: 3 - Log Error'

Log Error

	Philosophy
	
		-
			The log error command is a command with the content "Log Error".
			
			It prints all of the objects returned to it to the console in the form of an error.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 3 - Console: 4 - Log Line Error'

Log Line Error
	
	Philosophy
	
		-
			The log line error command is a command with the content "Log Line Error".
			
			It prints all of the objects returned to it followed by a new line to the console in
			the form of an error.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 3 - Console: 5 - Log Clear'

Log Clear

	Philosophy
	
		-
			The log clear command is a command with the content "Log Clear".
			
			It clears the console, and then prints all of the objects returned to it to the
			console.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 3 - Console: 6 - Log Line Clear'

Log Line Clear
	
	Philosophy
	
		-
			The log line clear command is a command with the content "Log Line Clear".
			
			It clears the console, and then prints all of the objects returned to it followed by a
			new line to the console.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 3 - Console: 7 - Input'

Input
	
	Philosophy
		
		-
			The input command contains the content "Input". It may have an indefinite number of
			children.
			
			If it has no children, it will return the next value returned by standard in. If it
			does have children, it will print the values returned by each of its children to the
			console, prompt the user for input and then return the string that was entered by the
			user.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 3 - Console: 8 - Get Log'

Get Log
	
	Philosophy
	
		-
			The get log command is a command with the content "Get Log".
			
			It returns the text in the console as a string.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 4 - System: 1 - Operating System'

Operating System

	Philosophy
	
		-
			The operating system command contains the content "Operating System".
			
			It returns the name of the operating system of the device Kaeon FUSION is running on as
			a string.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 4 - System: 10 - Addresses'

Addresses

	Philosophy
	
		-
			The addresses command contains the content "Addresses". It may have one child that
			returns a string in the form of a domain name.
			
			If it has no children, it will return the IP addresses of the device that Kaeon FUSION
			is running on as a list. If it does have a child, it will return the IP addresses of
			the specified domain name as a list.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 4 - System: 2 - Time'

Time
	
	Philosophy
		
		-
			The time command contains the content "Time".
			
			It returns the time on the computer's clock in seconds.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 4 - System: 3 - Year'

Year

	Philosophy
	
		-
			The year command contains the content "Year".
			
			It returns the current year according to the computer's clock as a number.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 4 - System: 4 - Month'

Month

	Philosophy
	
		-
			The month command contains the content "Month".
			
			It returns the current month according to the computer's clock as a number.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 4 - System: 5 - Day'

Day

	Philosophy
	
		-
			The day command contains the content "Day".
			
			It returns the current day according to the computer's clock as a number.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 4 - System: 6 - Hour'

Hour

	Philosophy
	
		-
			The hour command contains the content "Hour".
			
			It returns the current hour according to the computer's clock as a number.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 4 - System: 7 - Minute'

Minute

	Philosophy
	
		-
			The minute command contains the content "Minute".
			
			It returns the current minute according to the computer's clock as a number.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 4 - System: 8 - Second'

Second

	Philosophy
	
		-
			The second command contains the content "Second".
			
			It returns the current second according to the computer's clock as a number.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 4 - System: 9 - Weekday'

Weekday

	Philosophy
	
		-
			The weekday command contains the content "Weekday".
			
			It returns the current day of the week according to the computer's clock as a string.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 5 - IO: 1 - Open'

Open
	
	Philosophy
		
		-
			The open command contains the content "Open". It has one child that returns a string
			value.
			
			It will return the content of the file located at the path specified by the returned
			string.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 5 - IO: 10 - Is Directory'

Is Directory

	Philosophy
	
		-
			The is directory command contains the content "Is Directory". It has one child that
			returns a string in the form of a file path.
			
			It will return true if the returned file path leads to a directory and will return
			false otherwise.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 5 - IO: 11 - File Exists'

File Exists

	Philosophy
	
		-
			The file exists command contains the content "File Exists". It has one child that
			returns a string in the form of a file path.
			
			It will return true if a file or directory exists at the returned file path and will
			return false otherwise.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 5 - IO: 12 - Separator'

Separator

	Philosophy
	
		-
			The separator command contains the content "Separator".
			
			It returns the file path separator string of the device that Kaeon FUSION is running
			on.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 5 - IO: 13 - Is Hidden'

Is Hidden

	Philosophy
	
		-
			The is hidden command contains the content "Is Hidden". It has one child that returns a
			string in the form of a file or directory path.
			
			It returns true if the file or directory located at the returned path is hidden, and
			returns false otherwise.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 5 - IO: 14 - File Size'

File Size

	Philosophy
	
		-
			The file size command contains the content "File Size". Its first child returns a
			string containing a file or directory path, and it may optionally have a second child
			that returns a boolean.
			
			If it has a second child and said child returns true, it will return the space the file
			or directory at the returned path takes up on disk. Otherwise, it will return the size
			of the file or directory.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 5 - IO: 15 - Rename'

Rename

	Philosophy
	
		-
			The rename command contains the content "Rename". It has two children, both of which
			return strings that contain file or directory paths.
			
			It renames the path of the file or directory located at the path returned by the first
			child to the path returned by the second child.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 5 - IO: 16 - Path Separator'

Path Separator

	Philosophy
	
		-
			The path separator command contains the content "Path Separator".
			
			It returns the path separator string of the device that Kaeon FUSION is running on.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 5 - IO: 17 - Source Workspaces'

Source Workspaces

	Philosophy
	
		-
			The source workspaces command contains the content "Source Workspaces".
			
			It returns a list containing all of the paths to the source workspaces currently in use
			by Kaeon FUSION.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 5 - IO: 18 - Build Workspace'

Build Workspace

	Philosophy
	
		-
			The build workspace command contains the content "Build Workspace".
			
			It returns the path to the build workspace currently in use by the standard interface.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 5 - IO: 19 - Read Bytes'

Read Bytes

	Philosophy

		-
			The read bytes command is a command with the content "Read Bytes". It may have between
			one and three children, the first of which shall return a string containing a file
			path, and the second and third of which, if present, shall return integer numbers
			greater than or equal to one.

			It shall read the raw bytes from the file specified by the returned path and return
			them as an assembly dialect document where the mode is binary. If the second number is
			present, it shall start reading at the index specified by said number, and if the third
			number is present, it shall stop reading at the index specified by said number, where
			indices start at one.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 5 - IO: 2 - Save'

Save
		
	Philosophy
		
		-
			The save command contains the content "Save". It has two children, each of which return
			a string.
			
			It will save a file containing the first string at the path specified by the second
			string.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 5 - IO: 20 - Write Bytes'

Write Bytes

	Philosophy

		-
			The write bytes command is a command with the content "Write Bytes". It shall either
			two or three children, the first of which returns an assembly dialect document, the
			second of which returns a string containing a file path, and the third of which, if
			present, returns an integer number greater than or equal to one.

			It writes the bytes specified by the returned assembly dialect document to the file
			specified by the returned path. If the returned number is present, it shall start
			writing the bytes to the file at the index specified by said number where indices start
			at one.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 5 - IO: 21 - Send'

Send

	Philosophy

		-
			The send command is a command with the content "send". It shall have one child which
			shall return either a string containing a raw HTTP request or a dynamic list
			corresponding to an HTTP request in HTTP JSON format, and may also have an additional
			child which returns a list.

			The returned response shall be converted into a dynamic list corresponding to the same
			response in HTTP JSON format. If the second child is not present, it shall execute the
			request synchronously and return the returned list, and if the list is present, it
			shall execute the request asynchronously and execute the returned list as a Kaeon
			FUSION function, passing the returned list to it as an argument.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 5 - IO: 22 - Host'

Host

	Philosophy

		-
			The host command is a command with the content "Host". It shall have between two and
			four children, the first of which returns a list of lists, the second of which returns
			a number specifying a port, the third of which, if present, returns either a null value
			or a list containing two strings, and the fourth of which, if present, returns either a
			boolean or a string specifying a domain name.

			The host command shall establish a server with routes defined by each of the
			aforementioned lists running at the specified port. If the third child, if present,
			returned a list, the server shall run in HTTPS mode, where the first string in said
			list shall specify the key and the second string shall specify the certificate. If the
			fourth child, if present, returned either true or a string, the server shall be made
			publicly accessible on the internet, at the specifying domain if a valid domain was
			specified by said returned string, and by a randomly generated domain if not, in which
			case said generated domain shall be logged to the console.
			
			Each route defining list shall have at least three elements, the first and the second
			of which shall be strings, and the third of which shall be a list, and they may also
			have a fourth element which shall be a boolean. The first string shall specify the
			request method, and the second string shall specify the request route. The nested list
			shall specify a Kaeon FUSION function that takes an HTTP request as a dynamic list
			corresponding to said request in HTTP JSON format and shall return either a null value
			or an HTTP response, which may either be in string format or in HTTP JSON formatted as
			a dynamic list. The fourth element, if present and false, shall indicate that the route
			is not to be accessible via CORS.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 5 - IO: 3 - Delete'

Delete

	Philosophy
	
		-
			The delete command contains the content "Delete". It has one child which returns a
			string in the form of a file or directory path.
			
			It will delete the file or directory at the returned path from the file system.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 5 - IO: 4 - Directory'

Directory

	Philosophy
	
		-
			The directory command contains the content "Directory". It has one child that returns a
			string in the form of a directory path.
			
			It will return a list containing two lists, the first of which contains the names of
			all of the directories within the returned directory and the second of which contains
			the names of all of the files within the returned directory.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 5 - IO: 5 - Local Directory'

Local Directory

	Philosophy
	
		-
			The local directory command contains the content "Local Directory".
			
			It returns the path of the directory the host environment is running out of.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 5 - IO: 6 - Root Directories'

Root Directory

	Philosophy
	
		-
			The root directories command contains the content "Root Directories".
			
			It returns the paths of the root directories of the system that Kaeon FUSION is running
			on.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 5 - IO: 7 - Parent Directory'

Parent Directory

	Philosophy
	
		-
			The parent directory command contains the content "Parent Directory". It has one child
			that returns a string in the form of a directory path, and it may optionally have a
			second child that returns an integer number.
			
			If it has no second child, it will return the path of the parent directory of the
			returned directory. If it does have a second child, it will bubble up the directory
			tree for the number of times specified by the returned number and return the path of
			the resulting directory. If it attempts to access the parent of the root directory, it
			will return the root directory.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 5 - IO: 8 - Absolute Path'

Absolute Path

	Philosophy
	
		-
			The absolute path command contains the content "Absolute". It has one child that
			returns a string in the form of a file or directory path.
			
			It will return the absolute path to the file at the returned path.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 5 - IO: 9 - Create Directory'

Create Directory

	Philosophy
	
		-
			The create directory command contains the content "Create Directory". It has one child
			that returns a string in the form of a directory path.
			
			If the directory specified by the returned path does not exist, the command will create
			it.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 6 - List: 1 - List'

List
	
	Philosophy
	
		-
			The list command contains the content "List".
			
			It returns a list containing all of the values returned by its children.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 6 - List: 10 - Contains'

Contains
	
	Philosophy
		
		-
			The contains command contains the content "Contains". It has two children, the first of
			which returns a list and the second of which returns an object.
			
			It will return the true if the list contains the object.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 6 - List: 11 - Index'

Index
	
	Philosophy
		
		-
			The index command contains the content "Index". It may have between two and three
			children, the first of which returns a list, the second of which returns an object, and
			the third of which, if present, returns an integer.
			
			It will return the index of the first instance of an object equal to the specified
			object within the list with an index greater or equal to one if the third child is not
			present, or with an index greater than or equal to the number returned by the third
			child if said child is present. If no such object is found, the command will return
			zero.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 6 - List: 12 - Count'

Count
	
	Philosophy
		
		-
			The count command contains the content "Count". It will have two children, the first of
			which returns a list, and the second of which returns an object.
			
			It will return the number of times that an object equal to the specified object appears
			within the list.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 6 - List: 13 - Cut'

Cut
	
	Philosophy
		
		-
			The cut command contains the content "Cut". It will have two children, the first of
			which returns a list, and the second of which returns an object.
			
			It will split the list into several sublists based on the specified object and return
			the sublists as a list. If the list is in the form of a string and the object's string
			form is in the form of a regular expression, the string will be split based on said
			regular expression.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 6 - List: 14 - Reverse'

Reverse
	
	Philosophy
		
		-
			The reverse command contains the content "Reverse". It will have a single child that
			returns a list.
			
			It will return a list with all of the elements of the returned list with their indexes
			reversed.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 6 - List: 15 - Convert Sequence'

Convert Sequence
	
	Philosophy
		
		-
			The convert sequence command contains the content "Convert Sequence". It will have one
			child that returns either a list or a string.
			
			If its child returns a list, it will append each element in the list in order to a
			string and return the string.
			
			If its child returns a string, it will append each character in the string in order to
			a list and return the list.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 6 - List: 16 - List to Element'

List to Element

	Philosophy
	
		-
			The list to element command contains the content "List to Element". It must have one
			child that returns a list.
			
			It will make a copy of the list. If the copy is either empty or the string form of its
			first object is not in the form of an empty string, an empty string will be appended to
			the beginning of the list. It will interpret the copied list using ONE list form as an
			element, and return a string containing the interpreted element written using the
			standard ONE language.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 6 - List: 17 - Element to List'

Element to List

	Philosophy
	
		-
			The element to list command contains the content "Element to List". It must have one
			child that returns a string containing a ONE+ document.
			
			It will parse the document and return a list representing the document in ONE list
			form.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 6 - List: 18 - Tokenize'

Tokenize

	Philosophy
	
		-
			The tokenize command contains the content "Tokenize". It will have at least one child,
			the first of which returns a list.
			
			It will split the list into several sublists with sublists being formed from each
			sub-sequence of the list that matches the object returned by the children following the
			first child and each sub-sequence that occurs between the aforementioned sub-sequences.
			Said sub-sequences will then be returned as a list.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 6 - List: 19 - Append All'

Append All
	
	Philosophy
		
		-
			The append all command contains the content "Append All". It may have two or more
			children. Its first child will return a list, and every subsequent child will return a
			list.
			
			The contents of each returned list with the exception of the first list will, in the
			order their respective lists were returned, be appended to the first list.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 6 - List: 2 - Size'

Size
	
	Philosophy
		
		-
			The size command contains the content "Size". It has one child that returns a list.
			
			It will return the size of the list.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 6 - List: 20 - Insert All'

Insert All
	
	Philosophy
		
		-
			The insert all command contains the content "Insert All". It must have at least three
			children, the first of which returns a list, the second of which returns an integer,
			and with every subsequent child returning a list.
			
			It will insert the contents of the lists returned by every child past the second child
			in the order their respective lists were returned into the list returned by the first
			child at the index specified by the integer returned by the second child.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 6 - List: 21 - Indexes'

Indexes
	
	Philosophy
		
		-
			The indexes command contains the content "Indexes". It may have between two and three
			children, the first of which returns a list, the second of which returns an object, and
			the third of which, if present, returns an integer.
			
			It will return a list of the indexes of every instance of an object equal to the
			specified object within the list with an index greater or equal to one if the third
			child is not present, or with an index greater than or equal to the number returned by
			the third child if said child is present.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 6 - List: 22 - Swap'

Swap

	Philosophy
		
		-
			The swap command contains the content "Swap". It has three children, the first or which
			returns a list, and the second and third of which return integer numbers.
			
			It will swap the elements of the list at the indexes specified by the returned numbers.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 6 - List: 23 - Sort Alphabetical'

Sort Alphabetical

	Philosophy
		
		-
			The sort alphabetical command contains the content "Sort Alphabetical". It may have
			either one or two children, the first of which returns a list and the second of which,
			if present, returns an integer number.
			
			If the second child is not present, the elements of the returned list will be sorted in
			alphabetical order by their string forms. If the second child is present, it is assumed
			that every element in the returned list is a list. The lists will be sorted in
			alphabetical order by the string forms of the element within them at the index
			specified by the returned number. The sorted list will then be returned.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 6 - List: 24 - Sort Numerical'

Sort Numerical

	Philosophy
		
		-
			The sort numerical command contains the content "Sort Numerical". It may have either
			one or two children, the first of which returns a list and the second of which, if
			present, returns an integer number.
			
			If the second child is not present, the elements of the returned list will be sorted in
			numerical order by their string forms. If the second child is present, it is assumed
			that every element in the returned list is a list. The lists will be sorted in
			numerical order by the string forms of the element within them at the index specified
			by the returned number. The sorted list will then be returned.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 6 - List: 25 - Shuffle'

Shuffle

	Philosophy
	
		-
			The shuffle command contains the content "Shuffle". It has one child which returns a
			list.
			
			It will shuffle the order of the elements in the list randomly and return the list.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 6 - List: 26 - Is Sorted Alphabetical'

Is Sorted Alphabetical

	Philosophy
	
		-
			The is sorted alphabetical command contains the content "Is Sorted Alphabetical". Its
			first child returns a list, and may optionally have a second child that returns an
			integer number.
			
			If the second child is not present, it will check to see if the list is sorted in
			alphabetical order by the string forms of its elements, returning true if so and false
			otherwise. If the second child is present, it will be assumed that each element in the
			list is a list, and the command will check to see if the list is sorted in alphabetical
			order by the string forms of the element in each list at the index specified by the
			returned number, returning true if so and false otherwise.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 6 - List: 27 - Is Sorted Numerical'

Is Sorted Numerical

	Philosophy
	
		-
			The is sorted numerical command contains the content "Is Sorted Numerical". Its first
			child returns a list, and may optionally have a second child that returns an integer
			number.
			
			If the second child is not present, it will check to see if the list is sorted in
			numerical order by the string forms of its elements, returning true if so and false
			otherwise. If the second child is present, it will be assumed that each element in the
			list is a list, and the command will check to see if the list is sorted in numerical
			order by the string forms of the element in each list at the index specified by the
			returned number, returning true if so and false otherwise.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 6 - List: 28 - Key Index'

Key Index

	Philosophy
	
		-
			The key index command contains the content "Key Index". It may have either two or three
			children, the first of which returns a list where each element is a list, the second of
			which returns an object, and the third of which, if present, returns an integer number.
			
			It will return the index of the first list in the returned list that contains an object
			equivalent to the returned object. If the third child is present, said object must be
			located at the index specified by the returned number. If no such list is found, it
			will return zero.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 6 - List: 29 - Key Indices'

Key Indices

	Philosophy
	
		-
			The key indices command contains the content "Key Indices". It may have either two or
			three children, the first of which returns a list where each element is a list, the
			second of which returns an object, and the third of which, if present, returns an
			integer number.
			
			It will return a list of the indices of each list in the returned list that contains an
			object equivalent to the returned object. If the third child is present, said object
			must be located at the index specified by the returned number.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 6 - List: 3 - At'

At
	
	Philosophy
		
		-
			The at command contains the content "At". It has at least two children, the first of
			which returns a list, and the rest of which return integers.
			
			For every returned integer in the order they were returned, starting with the returned
			list, it retrieves the object in the list at the index specified by the integer, and
			repeats the process with the next integer, if there is one, on the returned object if
			said object is a list, and when finished returns the final retrieved object.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 6 - List: 30 - Replace'

Replace

	Philosophy
	
		-
			The replace command contains the content "Replace". It has three children, the first of
			which returns a list, and the rest of which return objects.
			
			It replaces every instance of the object returned by the second child in the list with
			the object returned by the third child, and returns the list.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 6 - List: 31 - Rank'

Rank

	Philosophy
	
		-
			The rank command contains the content "Rank". It must have a single child that returns
			a list.
			
			It will isolate every unique value in the list and place each unique value into a list
			with the other unique values that occur the same number of times as itself. It will
			then place each list into a new list in the order from the values that occur the least
			to the value that occur the most. It will then return the new list.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 6 - List: 32 - Set Alias'

Set Alias

	Philosophy

		-
			The set alias command contains the content "Set Alias". It has three children, the
			first of which returns a list, the second of which returns a number corresponding to an
			index within said list, and the third of which returns a string.

			It sets the alias of the element in the returned list specified by the returned number
			to the returned string.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 6 - List: 33 - Get By Alias'

Get By Alias

	Philosophy

		-
			The get by alias command contains the content "Get By Alias". It has two children, the
			first of which returns a list, and the second of which returns a string containing a
			regular expression.

			It returns every element in the list with an alias matching the regular expression
			specified by the returned string.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 6 - List: 34 - Get Alias Indices'

Get Alias Indices

	Philosophy

		-
			The get alias indices command contains the content "Get Alias Indices". It has two
			children, the first of which returns a list, and the second of which returns a string
			containing a regular expression.

			It returns a list containing all the indices of elements in the returned list with
			aliases matching the regular expression specified by the returned string.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 6 - List: 35 - Get Alias'

Get Alias

	Philosophy

		-
			The get alias command contains the content "Get Alias". It has two children, the first
			of which returns a list and the second of which returns a number corresponding to an
			index within said list.

			It returns the alias of the element in the returned list at the index specified by the
			returned number.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 6 - List: 36 - JSON to Dynamic List'

JSON to Dynamic List

	Philosophy

		-
			The JSON to dynamic list command is a command with the content "JSON to Dynamic List".
			It shall have one child which returns a JSON string.

			It shall return a dynamic list corresponding to the specified JSON.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 6 - List: 37 - Dynamic List to JSON'

Dynamic List to JSON

	Philosophy

		-
			The dynamic list to JSON command is a command with the content "Dynamic List to JSON".
			It shall have one child which returns a dynamic list.

			It shall return a JSON string corresponding to the specified dynamic list, where any
			list that has at least one non-null field alias shall become an object, and where any
			list that has no non-null field aliases shall remain a list.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 6 - List: 4 - Append'

Append
	
	Philosophy
		
		-
			The append command contains the content "Append". It may have two or more children. Its
			first child will return a list, and every subsequent child will return an object.
			
			Each returned object will, in the order it was returned, be appended to the list
			returned by the first child. The list will then be returned.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 6 - List: 5 - Set'

Set
	
	Philosophy
		
		-
			The Set command contains the content "Set". It has three children, the first of which
			returns a list, the second of which returns an integer, and the third of which returns
			an object.
			
			It will set the value in the list returned by the first child at the index specified by
			the integer returned by the second child to the object returned by the third child. The
			list will then be returned.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 6 - List: 6 - Insert'

Insert
	
	Philosophy
		
		-
			The insert command contains the content "Insert". It must have at least three children,
			the first of which returns a list, the second of which returns an integer, and every
			subsequent child returning an object.
			
			It will insert the objects returned by every child past the second child in the order
			they were returned into the list returned by the first child at the index specified by
			the integer returned by the second child. The list will then be returned.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 6 - List: 7 - Remove'

Remove
	
	Philosophy
		
		-
			The remove command contains the content "Remove". It has two children, the first of
			which returns a list, and the second of which returns an integer.
			
			It will remove the object in the list returned by the first child at the index
			specified by the integer returned by the second child. If the list is in the form of a
			string, it will return the list, and will return the removed object otherwise.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 6 - List: 8 - Concatenate'

Concatenate
	
	Philosophy
		
		-
			The concatenate command contains the content "Concatenate". It may have an indefinite
			number of children, each of which returns a list.
			
			It will concatenate the content of each list into a single list, according to the order
			of the children that returned them, and return the list. If the first returned list was
			in the form of a string, the list will be returned in the form of a string, and
			returned in the form of a list otherwise.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 6 - List: 9 - Crop'

Crop
	
	Philosophy
		
		-
			The crop command contains the content "Crop". It will have between two and three
			children, the first of which returns a list, and the second and third of which, if
			present, return numbers.

			The number returned by the second child is referred to as the second number, and the
			number returned by the third child is referred to as the third number. If the third
			child is not present, the third number shall be equal to the length of the list plus
			one.
			
			If the second and third number are equal it will return an empty list.
			
			If the second number is less than the third number, it will run through the list from
			the index specified by the second number to one less than the index specified by the
			third number, appending each element it runs through to a new list. It will then return
			the new list.
			
			If the second number is greater than the third number, it will run through the list
			from the index specified by the third number to one greater than the index specified by
			the second number, appending each element it runs through to a new list. It will then
			return the new list.
			
			If the returned list is in the form of a string, the generated list will be returned as
			a string. Otherwise, it will be returned as a list.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 7 - String: 1 - Character to Number'

Character to Number
	
	Philosophy
		
		-
			The character to number command contains the content "Character to Number". It has one
			child that returns a string.
			
			It will return the ASCII value of the first character in the string.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 7 - String: 2 - Number to Character'

Number to Character
	
	Philosophy
		
		-
			The number to character command contains the content "Number to Character". It has one
			child that returns a positive integer number.
			
			It will return the character that corresponds to the ASCII value of the number.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 7 - String: 3 - Upper'

Upper
	
	Philosophy
		
		-
			The upper command contains the content "Upper". It has one child that returns a string.
			
			It will return a string that matches the returned string where all alphabetic
			characters have been converted to upper case.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 7 - String: 4 - Lower'

Lower
	
	Philosophy
		
		-
			The lower command contains the content "Lower". It has one child that returns a string.
			
			It will return a string that matches the returned string where all alphabetic
			characters have been converted to lower case.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 7 - String: 5 - Trim'

Trim
	
	Philosophy
		
		-
			The trim command contains the content "Trim". It has one child that returns a string.
			
			It will return a string that matches the returned string where all leading and trailing
			whitespace is removed.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 7 - String: 6 - Pattern Match'

Pattern Match

	Philosophy
	
		-
			The pattern match command contains the content "Pattern Match". It has two children,
			the first of which returns a string and the second of which returns a string in the
			form of a regular expression.
			
			It will return true if the first string matches the regular expression defined by the
			second string, and will return false otherwise.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 8 - Logic: 1 - Not'

Not
	
	Philosophy
		
		-
			The not command contains the content "Not". It has one child that returns a boolean.
			
			It will return true if the returned boolean has a value of false, and return false if
			the returned boolean has a value of true.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 8 - Logic: 10 - Less or Equal'

Less or Equal
	
	Philosophy
		
		-
			The less or equal command contains the content "Less or Equal". It may have an
			indefinite number of children, each of which return a number.
			
			It will return true if the number returned by every child except for the last child is
			less than or equal to than the number returned by the following child, and return false
			otherwise.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 8 - Logic: 2 - Same'

Same
	
	Philosophy
		
		-
			The same command contains the content "Same". It may have an indefinite number of
			children.
			
			It will return true if the objects returned by all of its children are the same object,
			and false otherwise.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 8 - Logic: 3 - Equal'

Equal
	
	Philosophy
		
		-
			The equal command contains the content "Equal". It may have an indefinite number of
			children.
			
			It will return true if the string form of the objects returned by all of its children
			are equal, and return false otherwise.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 8 - Logic: 4 - And'

And
	
	Philosophy
		
		-
			The and command contains the content "And". It may have an indefinite number of
			children, each of which return a boolean.
			
			It will return true if all of the returned booleans are true, and return false
			otherwise.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 8 - Logic: 5 - Or'

Or

	Philosophy
		
		-
			The or command contains the content "Or". It may have an indefinite number of children,
			each of which return a boolean.
			
			It will return true if any of the returned booleans are true, and return false
			otherwise.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 8 - Logic: 6 - Exclusive Or'

Exclusive Or

	Philosophy
		
		-
			The exclusive or command contains the content "Exclusive Or". It may have an indefinite
			number of children, each of which return a boolean.
			
			It will return true if exactly one of the returned booleans are true, and return false
			otherwise.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 8 - Logic: 7 - Greater'

Greater
	
	Philosophy
		
		-
			The greater command contains the content "Greater". It may have an indefinite number of
			children, each of which return a number.
			
			It will return true if the number returned by every child except for the last child is
			greater than the number returned by the following child, and return false otherwise.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 8 - Logic: 8 - Greater or Equal'

Greater or Equal
	
	Philosophy
		
		-
			The greater or equal command contains the content "Greater or Equal". It may have an
			indefinite number of children, each of which return a number.
			
			It will return true if the number returned by every child except for the last child is
			greater than or equal to than the number returned by the following child, and return
			false otherwise.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 8 - Logic: 9 - Less'

Less
	
	Philosophy
		
		-
			The less command contains the content "Less". It may have an indefinite number of
			children, each of which return a number.
			
			It will return true if the number returned by every child except for the last child is
			less than the number returned by the following child, and return false otherwise.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 9 - Math: 1 - Add'

Add
	
	Philosophy
		
		-
			The add command contains the content "Add". It may have an indefinite number of
			children, each of which return a number.
			
			It returns the sum of all the numbers.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 9 - Math: 10 - Cosine'

Cosine
	
	Philosophy
		
		-
			The cosine command contains the content "Cosine". It must have a single child which
			returns a number.
			
			It returns the cosine value of the returned number in radians.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 9 - Math: 11 - Tangent'

Tangent
	
	Philosophy
		
		-
			The tangent command contains the content "Tangent". It must have a single child which
			returns a number.
			
			It returns the tangent value of the returned number in radians.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 9 - Math: 12 - Square Root'

Square Root
	
	Philosophy
		
		-
			The square root command contains the content "Square Root". It must have a single child
			which returns a number.
			
			It returns the square root of the returned number.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 9 - Math: 13 - Natural Logarithm'

Natural Logarithm
	
	Philosophy
		
		-
			The natural logarithm command contains the content "Natural Logarithm". It must have a
			single child which returns a number.
			
			It returns the natural logarithm of the returned number.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 9 - Math: 14 - Floor'

Floor
	
	Philosophy
		
		-
			The floor command contains the content "Floor". It must have a single child which
			returns a number.
			
			It returns the value of the returned number rounded down.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 9 - Math: 15 - Ceiling'

Ceiling
	
	Philosophy
		
		-
			The ceiling command contains the content "Ceiling". It must have a single child which
			returns a number.
			
			It returns the value of the returned number rounded up.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 9 - Math: 16 - To Radians'

To Radians
	
	Philosophy
		
		-
			The to radians command contains the content "To Radians". It must have a single child
			which returns a number.
			
			It converts the returned number from a degrees value to a radians value and returns the
			resulting value.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 9 - Math: 17 - To Degrees'

To Degrees
	
	Philosophy
		
		-
			The to degrees command contains the content "To Degrees". It must have a single child
			which returns a number.
			
			It converts the returned number from a radians value to a degrees value and returns the
			resulting value.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 9 - Math: 18 - Absolute Value'

Absolute Value
	
	Philosophy
		
		-
			The absolute value command contains the content "Absolute Value". It must have a single
			child which returns a number.
			
			It returns the absolute value of the returned number.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 9 - Math: 19 - Infinity'

Infinity
	
	Philosophy
		
		-
			The infinity command contains the content "Infinity".
			
			It returns a value of infinity.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 9 - Math: 2 - Subtract'

Subtract
	
	Philosophy
		
		-
			The subtract command contains the content "Subtract". It may have an indefinite number
			of children, each of which return a number.
			
			It subtracts each number following the first number from the first number and returns
			the resulting value.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 9 - Math: 20 - Arc Sine'

Arc Sine
	
	Philosophy
		
		-
			The arc sine command contains the content "Arc Sine". It must have a single child which
			returns a number.
			
			It returns the arc sine value of the returned number in radians.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 9 - Math: 21 - Arc Cosine'

Arc Cosine
	
	Philosophy
		
		-
			The arc cosine command contains the content "Arc Cosine". It must have a single child
			which returns a number.
			
			It returns the arc cosine value of the returned number in radians.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 9 - Math: 22 - Arc Tangent'

Arc Tangent
	
	Philosophy
		
		-
			The arc tangent command contains the content "Arc Tangent". It must have a single child
			which returns a number.
			
			It returns the arc tangent value of the returned number in radians.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 9 - Math: 23 - Hyperbolic Sine'

Hyperbolic Sine
	
	Philosophy
		
		-
			The hyperbolic sine command contains the content "Hyperbolic Sine". It must have a
			single child which returns a number.
			
			It returns the hyperbolic sine value of the returned number in radians.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 9 - Math: 24 - Hyperbolic Cosine'

Hyperbolic Cosine
	
	Philosophy
		
		-
			The hyperbolic cosine command contains the content "Hyperbolic Cosine". It must have a
			single child which returns a number.
			
			It returns the hyperbolic cosine value of the returned number in radians.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 9 - Math: 25 - Hyperbolic Tangent'

Hyperbolic Tangent
	
	Philosophy
		
		-
			The hyperbolic tangent command contains the content "Hyperbolic Tangent". It must have
			a single child which returns a number.
			
			It returns the hyperbolic tangent value of the returned number in radians.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 9 - Math: 26 - Theta'

Theta
	
	Philosophy
		
		-
			The theta command contains the content "Theta". It must have two children, each of
			which return a number.
			
			It returns the theta component, in radians, of the polar coordinate equivalent for the
			cartesian coordinate where the number returned by the first child is the x value and
			the number returned by the second child is the y value.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 9 - Math: 27 - Maximum'

Maximum

	Philosophy
	
		-
			The maximum command contains the content "Maximum". It must have a single child that
			returns a list of numbers.
			
			It returns the number in the list with the highest value.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 9 - Math: 28 - Minimum'

Minimum

	Philosophy
	
		-
			The minimum command contains the content "Minimum". It must have a single child that
			returns a list of numbers.
			
			It returns the number in the list with the lowest value.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 9 - Math: 29 - Mean'

Mean

	Philosophy
	
		-
			The mean command contains the content "Mean". It must have a single child that returns
			a list of numbers.
			
			It returns the mean of all the numbers in the list.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 9 - Math: 3 - Multiply'

Multiply
	
	Philosophy
		
		-
			The multiply command contains the content "Multiply". It may have an indefinite number
			of children, each of which return a number.
			
			It returns the product of all the numbers.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 9 - Math: 30 - Median'

Median

	Philosophy
	
		-
			The median command contains the content "Median". It must have a single child that
			returns a list of numbers.
			
			It returns the median of all the numbers in the list.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 9 - Math: 31 - Range'

Range

	Philosophy
	
		-
			The range command contains the content "Range". It must have a single child that
			returns a list of numbers.
			
			It returns the value of the highest number in the list minus the lowest number.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 9 - Math: 32 - Summation'

Summation

	Philosophy
	
		-
			The summation command contains the content "Summation". It must have a single child
			that returns a list of numbers.
			
			It returns the sum of all the numbers in the list.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 9 - Math: 33 - Decimal to Binary'

Decimal to Binary

	Philosophy
	
		-
			The decimal to binary command contains the content "Decimal to Binary". It must have
			three children, the first of which returns a number, and the second and third of which
			return booleans.
			
			It returns a string containing the binary representation of the returned number. If the
			boolean returned by the second child is true, the number will be represented as a
			signed number, and unsigned otherwise. If the boolean returned by the third child is
			true, the number will be represented as a floating point number, and as an integer
			otherwise.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 9 - Math: 34 - Decimal to Hexadecimal'

Decimal to Hexadecimal

	Philosophy
	
		-
			The decimal to hexadecimal command contains the content "Decimal to Hexadecimal". It
			must have three children, the first of which returns a number, and the second and third
			of which return booleans.
			
			It returns a string containing the hexadecimal representation of the binary form of the
			returned number. If the boolean returned by the second child is true, the number will
			be represented as a signed number, and unsigned otherwise. If the boolean returned by
			the third child is true, the number will be represented as a floating point number, and
			as an integer otherwise.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 9 - Math: 35 - Binary to Decimal'

Binary to Decimal

	Philosophy
	
		-
			The binary to decimal command contains the content "Binary to Decimal". It must have
			three children, the first of which returns a string containing a binary representation
			of a number, and the second and third of which return booleans.
			
			It returns a number that is equivalent to the binary value represented by the returned
			string. The number shall be assumed to be signed if the first boolean is true and shall
			be assumed to be floating point if the second boolean is true.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 9 - Math: 36 - Hexadecimal to Decimal'

Hexadecimal to Decimal

	Philosophy
	
		-
			The hexadecimal to decimal command contains the content "Hexadecimal to Decimal". It
			must have three children, the first of which returns a string containing a hexadecimal
			representation of a binary number, and the second and third of which return booleans.
			
			It returns a number that is equivalent to the binary value represented by the returned
			hexadecimal string. The number shall be assumed to be signed if the first boolean is
			true and shall be assumed to be floating point if the second boolean is true.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 9 - Math: 37 - Binary to Hexadecimal'

Binary to Hexadecimal

	Philosophy
	
		-
			The binary to hexadecimal command contains the content "Binary to Hexadecimal". It has
			one child that returns a value, the string form of which contains a binary
			representation of a number.

			It returns a string containing the value specified in binary by the string form of the
			returned value in hexadecimal format.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 9 - Math: 38 - Hexadecimal to Binary'

Hexadecimal to Binary

	Philosophy
	
		-
			The hexadecimal to binary command contains the content "Hexadecimal to Binary". It has
			one child that returns a value, the string form of which contains a hexadecimal
			representation of a number.

			It returns a string containing the value specified in hexadecimal by the string form of
			the returned value in binary format.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 9 - Math: 4 - Divide'

Divide
	
	Philosophy
		
		-
			The divide command contains the content "Divide". It may have an indefinite number of
			children, each of which return a number.
			
			It assigns the first number to a value and divides the value by each subsequent number
			in order. It then returns the resulting value.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 9 - Math: 5 - Modulus'

Modulus
	
	Philosophy
		
		-
			The modulus command contains the content "Modulus". It may have an indefinite number of
			children, each of which return a number.
			
			It assigns the first number to a value and for each subsequent number in order assigns
			the remainder of the division of the value and the respective number to the value. It
			then returns the resulting value.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 9 - Math: 6 - Random'

Random
	
	Philosophy
		
		-
			The random command contains the content "Random".
			
			It returns a random number between zero and one.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 9 - Math: 7 - Negative'

Negative
	
	Philosophy
		
		-
			The negative command contains the content "Negative". It must have a single child which
			returns a number.
			
			It returns the product of the returned number and negative one.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 9 - Math: 8 - Power'

Power
	
	Philosophy
		
		-
			The power command contains the content "Power". It must have two children, each of
			which return a number.
			
			It returns the value of the number returned by its first child raised to the power of
			the number returned by its second child.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 1 - General: 9 - Math: 9 - Sine'

Sine
	
	Philosophy
		
		-
			The sine command contains the content "Sine". It must have a single child which returns
			a number.
			
			It returns the sine value of the returned number in radians.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 2 - United: 1 - APIs: 1 - Kaeon ACE'

Kaeon ACE

	Philosophy

		-
			The Kaeon ACE command is a command with the content "Kaeon ACE".

			It shall cause the script to which it belongs to be interpreted as a Kaeon ACE
			document.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 1 - Standard: 1 - Commands: 2 - Defined: 2 - United: 2 - Kaeon META'

Kaeon META Command

	Philosophy

		-
			The Kaeon META command implemented in the Kaeon FUSION Standard Interface shall
			override the version of it specified in the Kaeon META interface, and may, rather than
			returning its return value directly, return a promise which shall resolve to the value
			it would have otherwise returned.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 2 - Special: 1 - Math'

Kaeon FUSION Math Interface
	
	Philosophy
		
		-
			The Kaeon FUSION math interface provides commands that allow users to do operations
			pertaining to math and chemistry.
		-
	
	Principles

		Access
		
			Alias
				
				-
					The Kaeon FUSION math interface may be referenced using the alias "Math".
				-
			
			Case Sensitivity
				
				-
					All of the commands provided by the Kaeon FUSION math interface do not take
					letter case into account.
				-

			Kaeon United

				-
					The Kaeon FUSION math interface shall be included in the Kaeon United FUSION
					interface.
				-

		Conventions

			Processing

				Expressions and Relations

					-
						An expression is any element which uses the available FUSION commands to
						express an operation or value.

						A relation is a codified relationship between expressions. Rules are
						relations which denote a set of expressions as equivalent, and formulas are
						relations that denote that processing one expression produces another. A
						relation is valid if the relationship it describes is in fact correct.
						
						A standard relation contains only two elements, those either being
						expressions or other relations.
						
						Relations should be encoded as dynamic lists in the form of ONE elements,
						with rules having the content "Is" and formulas having the content "Forms".

						Commands which have an effect in relations are called operators. All
						mathematical and logical commands of the standard interface may function as
						operators.

						Under the Kaeon FUSION math interface, elements containing variable names
						or numbers preceded by a plus or minus sign shall be interpreted as
						absolute or inversed versions of the values to which they correspond
						respectively, and a plus or minus sign used as a command with a single
						child that returns a number shall return the absolute or inversed version
						of said number respectively.
					-

				Axioms

					-
						An axiom in the context of the Kaeon FUSION math interface is a function
						which takes an indefinite number of arguments and validates them as a
						group, returning true if they are valid and false otherwise.

						The axioms put in place by default by the Kaeon FUSION math interface are
						called the default axioms.
					-

			Usage

				Standard Practice

					-
						It is standard practice for a program used for pure mathematical purposes,
						called an analysis program, to return a value at the end corresponding to
						the result of the intended process, with said value being a boolean in the
						case of a proof.

						Analysis programs may take the form of entire programs, or the form of
						functions within said programs.

						To "solve" an analysis program, that is, to render it, means deriving its
						render product, whether via an automated process or by hand.
					-

				Block Notation

					-
						Block notation is the use of block commands as pseudocomments.

						A block note is the use of a block command under which an element with the
						content "Note" is nested, with said element having children which specify
						miscellaneous information.

						A block resolution is the use of a block command at the end of a FUSION
						script, under which an element with the content "Solution" is nested, with
						the render product of the program being nested under said element.
					-

				Chemistry

					-
						Chemical operations may be performed using the Kaeon FUSION math interface
						by representing atoms and molecules using SAN and MGCF respectively.
					-

				Abridged CMN

					-
						Abridged CMN (ACMN) is the use of SAO++ with the Kaeon FUSION math
						interface as general purpose mathematical notation.
					-

		Commands

			Conventions

				Defining Commands

					-
						A defining command may have an indefinite number of children, and does not
						trickle down.
						
						It will return an element in ONE list form equal to itself with all the
						elements in its scope.
					-

				Masked Commands

					-
						The mathematical and logical commands of the standard interface may be used
						with their traditional symbols as used in other languages as their content.

						Furthermore, if a number is used as a command or operator, or a variable is
						used as an operator, with one child, it shall return itself multiplied by
						its child.
					-

			General

				Axioms

					-
						The axioms command contains the content "Axioms".

						It returns a list of the default axioms of the Kaeon FUSION math interface.
					-

				Forms

					-
						The forms command contains the content "Forms", and is a defining command.
					-

				From Latex

					-
						The from latex command contains the content "From LaTeX" and shall have one
						child which returns an expression or relation as a LaTeX string.

						It returns the equivalent of said expression or relation in ONE list form.
					-

				Is

					-
						The is command contains the content "Is", and is a defining command.
					-

				Validate

					-
						The validate command contains the content "Validate" and may have one or
						two children, the first of which returns a list, and the second of which,
						if present, returns a list of axioms.

						It validates the elements of the first list against a set of axioms, said
						axioms being those returned by the second argument if provided and being
						the default axioms if not, returning true if said elements were validated
						by all of said axioms, and returning false otherwise.
					-

				Solve

					-
						The solve command contains the content "Solve" and may have one or
						two children, the first of which returns an expression in ONE list form,
						and the second of which, if present, returns a list of relations in ONE
						list form and axioms.

						It reduces the terms with which said expression is expressed to as few
						terms as possible, and may transform it first, in accordance with the
						relations and axioms in the second list, if present, or in accordance with
						the default axioms if not, returning the reduced expression in ONE list
						form.
					-

				To Latex

					-
						The to latex command contains the content "To LaTeX" and shall have one
						child which returns an expression or relation in ONE list form.

						It returns the equivalent of said expression or relation as a LaTeX string.
					-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 2 - Special: 1 - Math: 1 - Operators: 1 - Super'

Super

	Philosophy

		-
			The super operator has the content "Super", and may have an indefinite number of
			children, each of which specifies either an expression or a rule.

			The super operator specifies a mathematical superposition, where each child represents
			a possible resolution of the superposition, with expressions representing possible
			values, and rules representing possible values with bias, the value being specified by
			the first expression, and the bias being specified by the second expression.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 2 - Special: 2 - Art'

Kaeon FUSION Art Interface
	
	Philosophy
		
		-
			The Kaeon FUSION art interface provides commands that allow users to do operations
			pertaining to visual art and music.
		-
	
	Principles

		Access
		
			Alias
				
				-
					The Kaeon FUSION art interface may be referenced using the alias "Art".
				-
			
			Case Sensitivity
				
				-
					All of the commands provided by the Kaeon FUSION art interface do not take
					letter case into account.
				-

			Kaeon United

				-
					The Kaeon FUSION art interface shall be included in the Kaeon United FUSION
					interface.
				-

		Conventions

			Action

				Structure

					-
						An action is a modification made to a command.
						
						A standard action causes a command to trigger specified events, called
						action events, on specified targets, called action targets, which may last
						for specified durations with specified properties, called action
						properties, may be made to repeat certain numbers of times, and may have
						action properties used as modifiers applied at each repetition.

						A command with actions is called an acting command. All events within an
						acting command shall be executed simultaneously, with each set of
						repetitions occurring among the simultaneous events being called a step,
						and the FUSION process shall only move forth once all steps within an
						acting command have finished.

						An event's target shall determine its action type, and if an acting command
						has multiple actions, they shall be taken as a single action.

						Each type of action property shall have an alias, and unless otherwise
						specified, each instance of them shall contain a number.

						Depending on the context, a default action target and default action
						properties may be in effect, causing any action in their context to inherit
						them unless said actions override them.

						Unless specified otherwise, acting commands which would otherwise declare
						variables will not.
					-

				Format

					-
						The action format is a ONE element format for specifying standard actions.
						By default, the root element containing such a format, called the action
						element, should have the content "Act".

						Each child of an action element, called an event element, shall have
						content, called an event specifier, specifying an action event.

						An action event shall have a target element as its child, with content,
						called a target specifier, specifying an action target for the event to
						which it is attached, unless a default action target is in effect, in which
						case the target element is optional.

						For a given event element, its target element, or itself if it has no
						target element, may have up to two children, the first, if present, called
						the time element, specifying, in seconds, the time that the event to which
						it is attached is to last, and the second, if present, called the
						repetitions element, specifying the number of times said event is to
						repeat.

						The time and repetitions elements may each have an indefinite number of
						property elements as children, which shall have content specifying the
						alias of an action property, and a single child with content specifying the
						value of said property. If children of the time element, they shall specify
						action properties to be applied to the first repetition, and if children of
						the repetitions element, shall specify modifiers to be applied on each
						subsequent repetition.

						The content of an acting command is called an acting specifier.

						For specifying a default action target and default action properties, the
						default action format may be used, which consists of a default action
						element, which by default should have the content "Stage", and which may
						have a target element specifying the default action target for its context,
						where said target element, if present, and the default action element
						itself otherwise, may have an indefinite number of property elements,
						specifying the default action properties for said context.
					-

			Specific

				Action Types

					Music

						Command

							-
								For events with an action type of "music", the content of their
								acting specifier specifies the lyrical syllables to be attached to
								each step which encompasses said events.

								Such a specifier should thus specify a syllable for each of said
								steps, each syllable being separated by a hyphen, with a period
								used in place of a syllable for a blank lyric, where no lyric is
								present at that note. If not enough syllables are specified, the
								remaining lyrics shall be assumed to be blank, and any excess
								syllables shall be ignored.

								The content of said specifiers may be encased in double quotes to
								prevent them from being interpreted as another command.
							-

						Events

							-
								The event specifier for an event with an action type of "music"
								may specify a specific key on a GMI, either by index or alias, or
								may be a period, indicating that the pitch is irrelevant.
							-

						Targets

							-
								A target specifier which specifies an action type of "music" shall
								specify a hypothetical type of musical keyboard, called a general
								musical interface (GMI), which mimics the sound of a specified
								instrument and has a specified number of keys, where said keys are
								arranged lowest to highest and assigned indices starting at one.

								The instruments available to a GMI shall be listed in a specified
								order in a reference called a GMI index, which shall assign each of
								them unique indices and aliases, and may optionally assign them
								default key counts, and may optionally assign the individual keys
								aliases.

								The format for specifying a GMI relative to a GMI index consists of
								a string which begins with an ampersand, followed by the index or
								alias of the desired instrument. Optionally, this may be followed
								by a hyphen, followed by the number of keys on said GMI, which if
								not present shall indicate that the default key count shall be
								used.
							-

						Properties

							-
								The properties which may be assigned to events with the action type
								"music" are "Pitch", "Volume", and "Reverb", with the same
								respective aliases. Each contains a number.

								Pitch specifies a specific integer number of notes to shift the key
								being played by the event.

								Volume specifies the volume of the note being played by the event,
								with volume ranging from zero to one, inclusive.

								Reverb specifies, in seconds, how long a note is to last after the
								track has progressed to the next note.
							-

				Standard GMIs

					Index

						0: Alias: Synth, .; Keys: 88
						1: Alias: Piano; Keys: 88

					Key Aliases

						-
							The keys of GMIs within the standard GMIs shall have aliases which
							match their counterparts on an 88 key piano.

							As such, said aliases shall start with a letter specifying the note
							from A to G, letter case being irrelevant.

							Said letter may be followed by a number specifying the octave from 0 to
							8. If the octave is not specified, the notes C to G shall have an
							octave of 4, and the notes A and B shall have an octave of 5.

							If the note is sharp, the alias shall end with a plus.
						-

		Commands

			General

				Act

					-
						The act command contains the content "Act", and is a defining element.
						
						Its return value shall be interpreted as an action in the action format,
						which shall be attached to its parent.
					-

				Sign

					-
						The sign command contains the content "Sign", and is a defining element.
						
						Its return value shall be interpreted as an action in the action format,
						which shall be attached to its next subsequent sibling which is not a
						defining element, does not already have an action attached to it, and which
						does not have an act command as a child.
					-

				Stage

					-
						The stage command contains the content "Stage", and is a defining element.
						
						Its return value shall be interpreted as in the default action format, and
						may specify a default action target and default action properties for all
						of its subsequent siblings, and the elements in their scope, which are
						acting commands.
					-

			Masked

				-
					A command with a dollar sign as its content shall function as a sign command,
					and a command with an at symbol as its content shall function as an act
					command.
				-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 2 - Special: 2 - Art: 1 - Conventions: 1 - Music: 1 - Muse'

Muse
	
	Philosophy
		
		-
			Muse is a ONE dialect for encoding audio.
		-
	
	Principles
		
		Structure
			
			Notes
				
				-
					A muse document must contain an element at the root level containing the
					content "Notes". Every twelve children of said element will represent a note,
					numbered in order starting at one.
					
					The content of the first element of a note specifies the time the note begins
					in seconds.
					
					The content of the second element of a note specifies the duration of the note
					in seconds.
					
					The content of all elements following the second element of a note and
					excluding the eighth element, the tenth element, and the twelfth of said note
					will be a number between zero and one. The content of the eighth element and
					the tenth element of a given note will be a number between negative one and
					one. The content of the twelfth element will be a number specifying a time in
					seconds.
					
					The content of the third element of a note specifies the pitch of the note when
					it starts. The content of the fourth element of a note specifies the volume of
					the note when it starts.
					
					The content of the fifth element of a note specifies the pitch of the note when
					it starts. The content of the sixth element of a note specifies the volume of
					the note when it starts.
					
					The content of the seventh element of a note specifies the location of the
					bulge of the volume arc between the start and the end of the note. The content
					of the eighth element of a note specifies the size of the bulge of said volume
					arc.
					
					The content of the ninth element of a note specifies the location of the bulge
					of the pitch arc between the start and the end of the note. The content of the
					tenth element of a note specifies the size of the bulge of said pitch arc.
					
					The content of the eleventh element of a note specifies the location of the
					bulge of the temporal arc between the start and the end of the note. The
					content of the twelfth element of a note specifies the size of the bulge of
					said temporal arc.
				-
			
			Figures
			
				-
					A muse document must contain an element at the root level containing the
					content "Figures". Every three children of said element will represent a
					figure, numbered in order starting at one.
					
					The three elements of a figure will be integer numbers specifying the index of
					a note, where the endpoints of the three specified notes connect to form a
					single contiguous shape.
				-
			
			Tracks
			
				-
					A muse document must contain an element at the root level containing the
					content "Tracks". Every child of said element will represent a track.
					
					The content of a child of the tracks element, called a track element, will be a
					string specifying the intended output device of the track. If no specific
					output device is required, the content will be "Default".
					
					A track element may have an indefinite number of children, each of which with
					content containing an integer number specifying the index of a figure.
				-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 1 - Kaeon FUSION: 2 - Special: 2 - Art: 2 - Commands: 1 - Music: 1 - Muse Command'

Muse Command

	Philosophy

		-
			The muse command contains the content "Muse", and has as its children the content of a
			muse document. It does not trickle down.

			It plays the audio encoded in the muse document specified by its children.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 2 - Kaeon ACE: 1 - Liberty'

Kaeon ACE Liberty
	
	Philosophy
		
		-
			Kaeon ACE Liberty is a set of Kaeon ACE conventions and ACE commands which constitute a
			game development framework.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 2 - Kaeon ACE: 1 - Liberty: 1 - Conventions'

Kaeon ACE Liberty Conventions
	
	Philosophy
		
		-
			This document specifies conventions for Kaeon ACE Liberty.
		-

	Principles

		Commands

			-
				All Kaeon ACE Liberty commands shall be ONE strings.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 2 - Kaeon ACE: 1 - Liberty: 2 - Subcomponents: 1 - Unordered: 1 - Vector 3'

Vector 3
	
	Philosophy
		
		-
			A vector 3 element is an ACE element that represents a three dimensional vector.
			
			It must have the content "Vector 3".
		-
	
	Principles
		
		Children
			
			-
				The element must have three children with the content "X", "Y", and "Z"
				respectively. Each child will itself have a single child with a number as said
				child's content.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 2 - Kaeon ACE: 1 - Liberty: 2 - Subcomponents: 1 - Unordered: 2 - Color'

Color

	Philosophy
	
		-
			A color element is an ACE element that represents an alpha-red-green-blue color.
			
			It must have the content "Color".
		-
	
	Principles
		
		Children
		
			-
				The element must have children with the content "Alpha", "Red", "Green", and "Blue"
				respectively, each of which must have a child with a number between zero and one as
				said child's content.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 2 - Kaeon ACE: 1 - Liberty: 2 - Subcomponents: 1 - Unordered: 3 - Texture'

Texture

	Philosophy
	
		-
			A texture element is an ACE element that represents a texture map.
			
			It must have the content "Texture".
		-
	
	Principles
		
		Data Section
		
			-
				The element must have a single child with the file path to an image or texture file
				as its content.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 2 - Kaeon ACE: 1 - Liberty: 2 - Subcomponents: 1 - Unordered: 4 - Vertex'

Vertex

	Philosophy
	
		-
			A vertex element is an ACE element that represents a vertex of a polygon.
			
			It must have the content "Vertex".
		-
	
	Principles
		
		Children
		
			-
				The element must have a child with the content "Position", and may also have a
				child with the content "Normal", as well as a child with the content "Texture". All
				of the aforementioned children must have a single vector 3 element as its child.

				The element may also have one color element as its child.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 2 - Kaeon ACE: 1 - Liberty: 2 - Subcomponents: 1 - Unordered: 5 - Polygon'

Polygon

	Philosophy
	
		-
			A polygon element is an ACE element that represents a polygon in a mesh.
			
			It must have the content "Polygon".
		-
	
	Principles
		
		Children
			
			-
				The element must have a child with the content "Indexes", which may have an
				indefinite number of children, each of which have an integer number as their
				content.
				
				The element may also have one color element as a child.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 2 - Kaeon ACE: 1 - Liberty: 2 - Subcomponents: 2 - Ordered: 1 - Single: 1 - First: 1 - Tag'

Tag
	
	Philosophy
	
		-
			A tag element is a first order Kaeon ACE subcomponent that represents a tag identifier.

			It must have the content "Tag".
		-
	
	Principles
		
		Children
			
			-
				The element must have a single element as its child, the content of which shall
				specify the tag that the element represents.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 2 - Kaeon ACE: 1 - Liberty: 2 - Subcomponents: 2 - Ordered: 1 - Single: 1 - First: 10 - Properties'

Properties

	Philosophy
	
		-
			A properties element is a first order Kaeon ACE subcomponent that represents properties
			of the entity it belongs to.

			It must have the content "Properties".
		-
	
	Principles
		
		Children
		
			-
				The element may have one or both of children with the content "Active" or
				"Destroyed", each of which, if present, must have a child with either "True" or
				"False" as its content.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 2 - Kaeon ACE: 1 - Liberty: 2 - Subcomponents: 2 - Ordered: 1 - Single: 1 - First: 11 - Audio'

Audio

	Philosophy
	
		-
			An audio element is a first order Kaeon ACE subcomponent that represents an audio clip.
			
			It must have the content "audio".
		-
	
	Principles
		
		Children
		
			-
				The element must have a single child with the file path to an audio file as its
				content.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 2 - Kaeon ACE: 1 - Liberty: 2 - Subcomponents: 2 - Ordered: 1 - Single: 1 - First: 12 - Conduit'

Conduit

	Philosophy
	
		-
			A conduit element is a first order Kaeon ACE subcomponent wherein the children of the
			element are periodically updated by the host environment based on its type.

			It must have the content "Conduit".
		-
	
	Principles
		
		Children
		
			-
				The element must have two children, one with the content "Type", and the other with
				the content "Port". The type element must have a child with either "Keyboard" or
				"Mouse" as its content, and the port element must have no children.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 2 - Kaeon ACE: 1 - Liberty: 2 - Subcomponents: 2 - Ordered: 1 - Single: 1 - First: 13 - Loadable'

Loadable

	Philosophy
	
		-
			A loadable is a first order Kaeon ACE subcomponent that represents a loadable resource.

			It must have the content "Loadable".
		-
	
	Principles
		
		Children
		
			-
				The element must have two children, one with the content "Type" and the other with
				the content "Source".

				The type element must have a child with content specifying the type of loadable
				that the loadable element represents, and the source element must have a child with
				content specifying the file path of the resource that the loadable element
				represents.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 2 - Kaeon ACE: 1 - Liberty: 2 - Subcomponents: 2 - Ordered: 1 - Single: 1 - First: 13 - Loadable: 1 - Types: 1 - Model'

Model
	
	Philosophy
		
		-
			A model is a type of loadable element that represents a predefined set of meshes, rigs,
			and colliders.

			The type child of the loadable element must have a child with the content "Model".
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 2 - Kaeon ACE: 1 - Liberty: 2 - Subcomponents: 2 - Ordered: 1 - Single: 1 - First: 13 - Loadable: 1 - Types: 2 - Height Map'

Height Map
	
	Philosophy
		
		-
			A height map is a type of loadable element that represents the mesh and collider of a
			terrain height map.

			The type child of the loadable element must have a child with the content "Height Map".
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 2 - Kaeon ACE: 1 - Liberty: 2 - Subcomponents: 2 - Ordered: 1 - Single: 1 - First: 13 - Loadable: 1 - Types: 3 - Skybox'

Skybox
	
	Philosophy
		
		-
			A skybox is a type of loadable that represents the mesh and texture of a skybox.

			The type child of the loadable element must have a child with the content "Skybox".
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 2 - Kaeon ACE: 1 - Liberty: 2 - Subcomponents: 2 - Ordered: 1 - Single: 1 - First: 2 - Field'

Field
	
	Philosophy
		
		-
			A field element is a first order Kaeon ACE subcomponent that represents a field of data
			with an alias and content.

			It must have the content "Field".
		-
	
	Principles
		
		Children
		
			-
				The element must have one child, where the content of said child shall represent
				the alias of the field. Said child must itself have one child, the content of which
				shall represent the content of the field.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 2 - Kaeon ACE: 1 - Liberty: 2 - Subcomponents: 2 - Ordered: 1 - Single: 1 - First: 3 - Script'

Script
	
	Philosophy
		
		-
			A script element is a first order Kaeon ACE subcomponent that represents a script
			attached to the entity it belongs to.

			It must have the content "Script".
		-
	
	Principles

		Status

			-
				A script may either be active or inactive.

				As such, a script element may optionally have a child with the content "Status"
				referred to as the status element, which if present must have a child with either
				the content "Active" or "Inactive", indicating the status of the script.

				If said element is not present, the script shall have a status of active by
				default.
			-
		
		Sub-Scripts

			-
				Each child of a script element, save for the status element if it is present, shall
				be a sub-script element.

				The content of a sub-script element shall determine when it executes, and may be
				"Start", "Update", "Status", or "Destroy".

				A start sub-script shall execute once when the script is first placed into the
				scene.

				An update sub-script shall execute once per scene loop if the script to which it
				belongs is active.

				A status sub-script shall execute whenever the status of the script is changed.

				A destroy sub-script shall execute whenever the script to which it belongs is
				removed from the scene.

				A sub-script element shall have a child with the content "source", and may
				optionally have a child with the content "language".

				The source element shall have one child containing the code for the sub-script to
				which it belongs.
				
				Said code shall have an arguments array passed to it, which shall contain the Kaeon
				ACE core as its first element, which the sub-script may perform philosopher's atlas
				calls on as the sole means to interface with the rest of the scene and with the
				engine, and shall also contain a number representing the time in seconds that has
				passed since the last iteration of the update loop as its second element.

				The arguments array for a status sub-script shall also contain a boolean as its
				third element, which shall have a value of true if the status has been set to
				active, and a value of false if the status has been set to inactive.

				The language element, if present, shall have one child containing the language that
				the sub-script is written in.

				If the language element is not present, the engine shall attempt to detect the
				language of the sub-script automatically.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 2 - Kaeon ACE: 1 - Liberty: 2 - Subcomponents: 2 - Ordered: 1 - Single: 1 - First: 4 - Mesh'

Mesh

	Philosophy
	
		-
			A mesh element is a first order Kaeon ACE subcomponent that represents a collection of
			polygons attached to the entity it belongs to.

			It must have the content "Mesh".
		-
	
	Principles
		
		Children
		
			-
				The element may have one or both of the following: a geometry element and a color
				element.
				
				The geometry element, if present, shall have the content "Geometry", and may have
				an indefinite number of vertex elements and polygon elements as children. The order
				in which a vertex or polygon element is listed relative to other elements of the
				same type shall be its index.

				The element must also have as a child an element with the content "Type", which
				itself must have a child with the content "3D", "2D", "2D Aspect Off", or "2D
				Absolute".
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 2 - Kaeon ACE: 1 - Liberty: 2 - Subcomponents: 2 - Ordered: 1 - Single: 1 - First: 5 - Collider'

Collider

	Philosophy
		
		-
			A collider element is a first order Kaeon ACE subcomponent that represents a rigid body
			attached to the entity it belongs to.

			It must have the content "Collider".
		-
	
	Principles
		
		Children
		
			-
				The element may have a mesh element as a child, and must have a child with the
				content "Type", which must have a child with the content "Mesh" or "Sphere".
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 2 - Kaeon ACE: 1 - Liberty: 2 - Subcomponents: 2 - Ordered: 1 - Single: 1 - First: 6 - Force'

Force

	Philosophy
	
		-
			A force element is a first order Kaeon ACE subcomponent that represents a force
			attached to the entity it belongs to.

			It must have the content "Force".
		-
	
	Principles
			
		Children
		
			-
				The element must have a vector 3 element as a child.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 2 - Kaeon ACE: 1 - Liberty: 2 - Subcomponents: 2 - Ordered: 1 - Single: 1 - First: 7 - Transform'

Transform

	Philosophy
		
		-
			A transform element is a first order Kaeon ACE subcomponent that represents a
			transformation attached to the entity it belongs to.

			It must have the content "Transform".
		-
	
	Principles
		
		Children
		
			-
				The element must have a vector 3 element as a child, and must also have a child
				with the content "Type", which itself must have a child with the content
				"Translation", "Rotation", or "Scale".
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 2 - Kaeon ACE: 1 - Liberty: 2 - Subcomponents: 2 - Ordered: 1 - Single: 1 - First: 8 - Camera'

Camera
	
	Philosophy
	
		-
			A camera element is a first order Kaeon ACE subcomponent that represents a camera
			attached to the entity it belongs to.

			It must have the content "Camera".
		-
	
	Principles
		
		Children
		
			-
				The element may have as children an indefinite number of transform elements, which
				will apply in order.
				
				The element may also have a child with the content "FOV", which itself shall have a
				child with a number as its content. If the FOV is not specified, it will be set to
				a default value.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 2 - Kaeon ACE: 1 - Liberty: 2 - Subcomponents: 2 - Ordered: 1 - Single: 1 - First: 9 - Effect'

Effect

	Philosophy
	
		-
			An effect element is a first order Kaeon ACE subcomponent that represents a graphical
			effect attached to the entity it belongs to.

			It must have the content "Effect".
		-
	
	Principles
		
		Children
		
			-
				The element may have an indefinite number of transform elements as children, and up
				to one color element.

				The element must have a child with the content "Type", which itself must have a
				child with the content "Background Color", "Light", or "Fog". The element may also
				have a child with the content "Intensity", which shall have a single child that has
				a number as its content.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 2 - Kaeon ACE: 1 - Liberty: 2 - Subcomponents: 2 - Ordered: 1 - Single: 2 - Second: 1 - Directives: 1 - Frame'

Frame Properties

	Philosophy
		
		-
			A frame properties element is a second order Kaeon ACE subcomponent that represents the
			frame properties of the GUI of its host environment.

			It must have the content "Frame Properties", and must be the child of a Kaeon ACE
			directive.
		-
	
	Principles
		
		Children

			-
				The element may have a child with the content fullscreen.

				The element may also have a child with the content "Icon", which if present shall
				have a child containing the file path to an image as its content.

				The element may also have a child with the content "Title", which if present shall
				have a child containing any string.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 2 - Kaeon ACE: 1 - Liberty: 2 - Subcomponents: 2 - Ordered: 1 - Single: 2 - Second: 1 - Directives: 2 - Tick'

Tick Rate

	Philosophy
		
		-
			A tick rate element is a second order Kaeon ACE subcomponent that represents the tick
			rate of the script processor of its host environment.

			It must have the content "Tick Rate", and must be the child of a Kaeon ACE directive.
		-
	
	Principles
		
		Children
		
			-
				The element must have a single child that contains a number as its content.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 2 - Kaeon ACE: 2 - Interfaces: 1 - FUSION: 1 - Kaeon ACE Interface'

Kaeon ACE FUSION Interface

	Philosophy

		-
			The Kaeon ACE FUSION interface is a Kaeon FUSION interface with the alias "Kaeon ACE"
			that, upon completion of the execution of the script into which it is incorporated,
			causes said script to be interpreted as a Kaeon ACE document where the Philosopher's
			Atlas that hosts the FUSION interpreter is repurposed to serve as a Kaeon ACE
			interface, with the core of the FUSION interpreter becoming the core of said interface.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 2 - Kaeon ACE: 2 - Interfaces: 1 - FUSION: 2 - Module Interfaces'

Kaeon ACE Module Interface

	Philosophy

		-
			A Kaeon ACE module interface is a type of Kaeon FUSION interface that attaches Kaeon
			ACE modules to the Philosopher's Atlas of the FUSION interpreter, which is assumed to
			be running in an environment capable of hosting a Kaeon ACE application.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 2 - Kaeon ACE: 2 - Interfaces: 1 - FUSION: 2 - Module Interfaces: 1 - Standard'

Kaeon ACE Liberty Interface

	Philosophy

		-
			The Kaeon ACE Liberty interface is a Kaeon FUSION module interface with the alias
			"Kaeon ACE Liberty", that contains all of the Kaeon ACE modules required by the Kaeon
			ACE Liberty framework.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 2 - Kaeon ACE: 2 - Interfaces: 2 - ACE: 1 - Conventions: 1 - Console'

Kaeon ACE Console

	Philosophy

		-
			A Kaeon ACE console is an interface which integrates both an ACE console and an Atlas
			console.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 2 - Kaeon ACE: 2 - Interfaces: 2 - ACE: 2 - Implementations: 1 - Babylon'

Kaeon ACE Babylon Interface

	Philosophy

		-
			The Kaeon ACE Babylon interface is a JavaScript based Kaeon ACE Interface that renders
			Kaeon ACE content to the babylon.js engine.
		-

	Principles

		Hosting

			-
				Being JS based, Kaeon ACE applications running on the Kaeon ACE Babylon interface
				may run in any browser environment, and there may also be specialized shadow hosts
				for such applications.

				Due to restrictions on audio autoplay, the Kaeon ACE Babylon interface should show
				a start screen with a "Start" button that the user must manually click before the
				application launches.

				Additionally, the Kaeon ACE Babylon interface should check whether the device it is
				running on offers VR support, and provide an option to launch it if the
				functionality is available.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 3 - ONE Dialects: 1 - ONE LISP'

ONE LISP

	Philosophy
	
		-
			ONE LISP is an alternate syntax for encoding a ONE document that resembles LISP.
		-
	
	Principles
		
		Structure
		
			-
				The document represents a list in ONE list form representing an element with no
				content. All elements at the root of the document are implicitly assumed to be in a
				list.
			-
		
		Syntax
		
			-
				A sequence located outside a quoted literal beginning with a pound sign where said
				pound sign is not immediately followed by a square bracket and ending with a new
				line will be a comment.
				
				A sequence located outside a quoted literal beginning with a pound sign followed by
				a square bracket and ending with a square bracket followed by a pound sign will be
				a comment.
				
				An open parenthesis denotes the beginning of a list.
				
				A closed parenthesis denotes the end of a list.
				
				Sequences located between double quotes will be interpreted as literals where both
				of said double quotes are present.
				
				Sequences located between single quotes will be interpreted as literals where both
				of said single quotes are absent.
				
				Any contiguous sequence located outside of comments and quoted literals that does
				not contain whitespace, parentheses, single quotes, double quotes, or pound signs
				will be interpreted as a literal.
				
				Whitespace will separate said literal values.
				
				A sequence occurring within a literal that consists of a backslash followed by an
				'n' will be interpreted as a new line character.
				
				A sequence occurring within a literal that consists of a backslash followed by a
				't' will be interpreted as a tab character.
				
				If a backslash precedes an operator character, including another backslash, the
				effect of the operator character will be nullified and the operator will be
				interpreted literally.
				
				The end of the file may be interpreted as the end of a list, quoted literal, or
				comment.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 3 - ONE Dialects: 2 - Build Dialect'

Build Dialect

	Philosophy
	
		-
			A build dialect is a ONE dialect used to represent another file format.
		-

	Principles

		Meta Command

			Philosophy

				-
					A meta command is a ONE element with the content "Meta".

					A meta command may be placed into a build dialect document to specify
					miscellaneous information to any program interpreting said document using its
					children.
				-
			
			Scope
				
				-
					Any effect specified by a meta command will act on commands that follow said
					command.
					
					An effect of a command is said to have extended scope if said effect trickles
					down to elements within the scope of the affected elements.
					
					A meta command effect is said to have reduced scope if it only applies to the
					element immediately following said command.
					
					If two meta commands specify effects that contradict one another, the effects
					of the more recent command shall be applied.
				-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 3 - ONE Dialects: 2 - Build Dialect: 1 - Assembly Dialect'

Assembly Dialect

	Philosophy
	
		-
			The assembly dialect is a build dialect analogous to machine code.
		-

	Principles
	
		Instructions
		
			-
				Every element in an assembly dialect document that is not a use command or a mode
				command is analogous to a linear sequence of instructions in machine code.
			-

		Size Command

			-
				A size command contains the content "Size", regardless of letter case, and has
				a single child containing an integer number greater than or equal to one, which
				will determine what byte size the instructions following it and preceding the size
				mode command or the end of the file will be encoded with. The size will be set to
				eight by default.
			-
	
		Modes
			
			Mode Command
				
				-
					A mode command contains the content "Mode", regardless of letter case, and has
					a single child containing the content "Binary", "Raw", "Decimal",
					"Hexadecimal", or "Mnemonic", which will determine what mode the instructions
					following it and preceding the next mode command or the end of the file will be
					cross compiled according to. The mode will be set to binary by default.
				-
			
			Binary Mode
			
				-
					An instruction in binary mode is an element which may contain as its content a
					sequence of zeroes and ones, and corresponds literally to a single binary
					instruction.
				-
			
			Raw Mode
			
				-
					An instruction in raw mode is an element which may contain any string as its
					content, corresponding to a sequence of instructions where each character
					corresponds to a binary value.
				-
			
			Decimal Mode
			
				-
					An instruction in decimal mode is an element which may contain as its content a
					decimal number, and corresponds to a single binary instruction such that said
					instruction is the binary form of said number.
				-
			
			Hexadecimal Mode
			
				-
					An instruction in hexadecimal mode is an element which may contain as its
					content a hexadecimal number, and corresponds to a single binary instruction
					such that said instruction is the binary form of said number.
				-
			
			Mnemonic Mode
			
				-
					An instruction in mnemonic mode is an element that may have any content other
					than "Use", "Size", or "Mode", regardless of letter case, and may have any
					children.
				-
		
		Use Command
		
			-
				A use command will have the content "Use", regardless of letter case, and will have
				an indefinite number of children, each of which containing as their content the
				file path of a ONE+ file.
				
				The ONE+ file will be a Kaeon FUSION file using the standard interface that may be
				passed as an argument the contents of an assembly dialect instruction written in
				mnemonic mode in ONE list form, and based on it either return a list of strings
				containing binary corresponding to the compiled instruction, or return null if the
				mnemonic is unrecognized.
				
				If multiple ONE+ files are included through use commands, and more than one of them
				return a non null value for a given mnemonic, the more recently included document
				will take priority.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 3 - ONE Dialects: 2 - Build Dialect: 2 - Cross Dialect'

Cross Dialect
	
	Philosophy
		
		-
			A cross dialect is a build dialect that allows code written in the Kaeon FUSION
			standard interface to be translated to another language.
			
			Given that there are certain details some languages may require that would not be
			included in native Standard interface code, meta commands may be used to specify the
			necessary information. As such, a set of meta command formats used for all cross
			dialects has been specified.
			
			Additional meta command notation formats may be added to individual cross dialects to
			cover for features specific to certain languages.
		-
	
	Principles
		
		Structure
			
			Strong Typing
				
				-
					A meta command may have a child with the content "Type". The children of the
					type element will determine the type of any variable declared within the meta
					command's scope.
				-
				
				Casting
					
					-
						A meta command may have a child with the content "Cast". The children of
						the cast element will determine the type that the value returned by the
						command in the meta command's scope will be cast to. This effect will have
						reduced scope.
					-
			
			Arrays
			
				-
					A meta command may have a child with the content "Arrays".
				-
			
				Size
				
					-
						If a meta element has a child with the content "Arrays", said child may
						have a child with the content "Size". The size element may either have a
						child with the content "Fixed", in which case all lists within the meta
						command's scope will be treated as fixed length arrays, or it may have a
						child with the content "Variable", in which case all lists within the meta
						command's scope will be treated as variable length vectors.
						
						By default arrays are assumed to be of variable length.
					-
				
				Index
				
					-
						If a meta element has a child with the content "Arrays", said child may
						have a child with the content "Index". The index element will have a child
						containing an integer number as its content, dictating the starting index
						of all lists in the meta command's scope.
						
						By default arrays are assumed to start at an index of one.
					-
			
			Functions
				
				Function Definitions
					
					-
						A meta command may have a child with the content "Function". If the meta
						command immediately precedes a Define command, the function element's
						children will determine the properties of all of the functions defined by
						said Define command.
					-
				
					Type
					
						-
							If a meta element has a child with the content "Function", said child
							may use one of the following three ways to declare the type of
							functions declared within the meta command's scope.
							
							The function element may have a child with the content "Type". The
							children of the type element determine the return type of the function.
							
							The function element may have a child with the content "Class". In this
							case, the function definition will serve as the constructor for a class
							definition. Functions defined within the function definitions will
							become methods of the class, and global variables defined within the
							function definitions will become class variables. The class element may
							have an indefinite number of children, each with content specifying the
							names of classes to extend from.
							
							The function element may have a child with the content "Constructor".
							In this case, the function definition will serve as a constructor for
							the class definition it occurs within.
						-
				
					Parameters
					
						-
							If a meta element has a child with the content "Function", said child
							may have use one of the following two ways to declare the parameters of
							functions declared within the meta command's scope.
							
							The function element may have a child with the content "Parameters".
							Each child of the parameters element defines a parameter. The content
							of said child defines the parameter's alias, and its children define
							its type.
							
							Alternatively, The function element may have a child with the content
							"Parameter Number". The parameter number element must have a single
							child with content containing an integer number specifying the number
							of parameters the functions will have.
						-
					
					Inline Functions
					
						-
							The function element may have a child with the content "Inline". In
							this case, the function definition will appear in the cross compiled
							code where it was defined in the original cross dialect code. The
							inline element may have a child with the content "Unaliased", in which
							case the cross compiled function will not have an alias. The cross
							dialect function that corresponds to an unaliased cross compiled
							function must still have an alias, but there will be no issues if it
							shares an alias with other functions.
						-
				
				Host Functions
					
					-
						A meta command may have a child with the content "Host". Any command within
						the meta command's scope with content that matches the content of one of
						the host element's children will be treated as a function call to a
						function with an alias matching its content. This effect will have extended
						scope.
					-
			
			Fields
			
				-
					A meta command may have a child with the content "Field". The field element
					must either have a child with the content "Function", in which case In commands
					within the meta command's scope will only access public functions, or a child
					with the content "Variable", in which case the In commands within the meta
					command's scope will only access public variables.
					
					By default In commands are assumed to only access functions.
				-
		
		Extensions
		
			-
				An extended variant of the cross dialect must specify what languages and frameworks
				the dialect corresponds to, what data types may be used for variables and
				functions, and what may be placed in a notation.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 3 - ONE Dialects: 2 - Build Dialect: 2 - Cross Dialect: 1 - Cross Dialects: 1 - Primary: 1 - C Dialect'

C Dialect
	
	Philosophy
		
		-
			The C dialect is a cross dialect analogous to C.
		-

	Principles
		
		Types
		
			External
			
			Automatic
			
			Unsigned
			
			Signed
			
			Integer
			
			Short
			
			Long
			
			Float
			
			Double
			
			Character
			
			Boolean
			
			Void
			
			Pointer
			
			Address
			
			Array
				
				-
					If the type element has a child with the content "Array", said child may have
					an indefinite number of children, each of which may have either an integer
					number or the string "Null" as their content. Each of said children represents
					a dimension of an array, where a child containing a number represents the
					length of said dimension and a child with the string "Null" represents a
					dimension of indeterminate length. If the array element has no children, the
					array will be assumed to be a one dimensional array of indeterminate length.
				-
			
			Structure
			
				-
					If the type element has a child with the content "Structure", said child must
					have a child with content containing the name of a C struct.
				-
			
			Inline Structure
			
				-
					If the type element has a child with the content "Inline Structure", the
					children of said child shall compose the body of a function analogous to a C
					struct.
				-
		
		Notations
		
			Get Pointer
			
				-
					If a notation element in a meta command contains the content "Get Pointer", the
					command in the meta command's scope will be a pointer reference. This effect
					will have reduced scope.
				-
			
			Get Address
			
				-
					If a notation element in a meta command contains the content "Get Address", the
					command in the meta command's scope will be an address reference. This effect
					will have reduced scope.
				-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 3 - ONE Dialects: 2 - Build Dialect: 2 - Cross Dialect: 1 - Cross Dialects: 1 - Primary: 2 - JavaScript DIalect'

JavaScript Dialect
	
	Philosophy
		
		-
			The JavaScript dialect is a cross dialect analogous to JavaScript and JSON.
		-
	
	Principles
	
		Notations
		
			JavaScript Mode
			
				-
					In the JavaScript dialect, a meta notation may have a child with the content
					"JavaScript Mode". Said child must have a child with either "JavaScript" or
					"JSON" as its content. If the mode is set to JSON, everything within cross
					compiled code generated by the contents of the notation's scope will be cut
					unless it is valid JSON. The mode is set to JavaScript by default.
				-
			
			List Type
			
				-
					In the JavaScript dialect, a meta notation may have a child with the content
					"List Type". Said child must have a child with either "List" or "Object" as its
					content. If the type is list, the lists within the notation's scope may have
					any contents and will be cross compiled as normal JavaScript lists. If the type
					is object, every child of list definitions within the notation's scope must
					have a single child that must either be a string, boolean, or number literal,
					or a list definition. List definitions declared when the type is object will be
					cross compiled to object literals. The type is list by default.
				-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 3 - ONE Dialects: 2 - Build Dialect: 2 - Cross Dialect: 1 - Cross Dialects: 2 - Secondary: 1 - Java DIalect'

Java Dialect
	
	Philosophy
		
		-
			The Java dialect is a cross dialect analogous to Java.
		-
	
	Types
	
		Public
		
		Private
		
		Protected
		
		Package
		
		Static
		
		Final
		
		Object
		
		Byte
		
		Integer
		
		Short
		
		Long
		
		Float
		
		Double
		
		Character
		
		Boolean
		
		Void
		
		Class
		
			-
				If the type element has a child with the content "Class", said child must have a
				single child with content containing the name of a Java class.
			-
		
		Template
		
			-
				If the type element has a child with the content "Template", said child may have
				any children that the type element itself may have, specifying the type to place
				within a template.
			-
			
		Array
			
			-
				If the type element has a child with the content "Array", said child may have a
				child with content containing an integer number, specifying the dimensions of the
				array. If no such child is present, the array will be assumed to be one
				dimensional.
			-
	
	Operator Commands
	
		Instance Of
		
			-
				The instance of operator command contains the content "Instance Of". It will have
				two children, the first of which may return any Java object value and the second of
				which has content that matches the name of a Java class.
			-
	
	Notations
	
		Package
		
			-
				If a notation element has a child with the content "Package", said child must have
				one child with content containing the name of a java package, which will be the
				package the class it occurs within will be declared to reside in.
			-
		
		Interfaces
		
			-
				If a notation element has a child with the content "Interfaces", said child may
				have an indefinite number of children, each of which with content containing the
				name of a Java interface, which any class definitions following the respective meta
				command will implement.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 3 - ONE Dialects: 2 - Build Dialect: 2 - Cross Dialect: 1 - Cross Dialects: 2 - Secondary: 2 - Python DIalect'

Python Dialect
	
	Philosophy
		
		-
			The Python dialect is a cross dialect analogous to Python.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 3 - ONE Dialects: 2 - Build Dialect: 2 - Cross Dialect: 1 - Cross Dialects: 2 - Secondary: 3 - C++ Dialect'

C++ Dialect
	
	Philosophy
		
		-
			The C++ dialect is a cross dialect analogous to C++.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 3 - ONE Dialects: 2 - Build Dialect: 2 - Cross Dialect: 1 - Cross Dialects: 2 - Secondary: 4 - C# Dialect'

'C# Dialect'
	
	Philosophy
		
		-
			The C# dialect is a cross dialect analogous to C#.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 3 - ONE Dialects: 2 - Build Dialect: 2 - Cross Dialect: 1 - Cross Dialects: 2 - Secondary: 5 - Swift DIalect'

Swift Dialect
	
	Philosophy
		
		-
			The Swift dialect is a cross dialect analogous to Swift.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 3 - ONE Dialects: 2 - Build Dialect: 2 - Cross Dialect: 1 - Cross Dialects: 2 - Secondary: 6 - PHP Dialect'

PHP Dialect
	
	Philosophy
		
		-
			The PHP dialect is a cross dialect analogous to PHP.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 3 - ONE Dialects: 2 - Build Dialect: 3 - Miscellaneous Dialects: 1 - DOM Dialect'

DOM Dialect
	
	Philosophy
		
		-
			The DOM dialect is a build dialect analogous to XML.
		-
	
	Principles
		
		Syntax
			
			Structure
				
				-
					A DOM dialect document will have exactly one XML element at the root level. It
					may also optionally have one or both of a single declaration element and a
					single document element at the root level, as well as an indefinite number of
					use elements.
				-
			
			Letter Case
			
				-
					The letter case of content specified for elements listed in this document is
					irrelevant.
				-
				
			Use Element
			
				-
					A use element has the content "Use". It may have an indefinite number of
					children, each of which having content that specifies the file path of a use
					document.
				-
			
			Use Document
			
				-
					A use document is a ONE document containing elements with either the content
					"Tags" or "Attributes". Each of these elements may have an indefinite number
					of children, with each of said children having one child. No child of a tags or
					attributes element may have the content "Attributes" or "Children".
					
					Any element in an DOM dialect document nested within the scope of the root
					element that matches the content of a child of a tag element in a use document
					referenced by a use command by said DOM dialect document shall function as an
					XML element that translates to an XML tag with a name matching the content of
					the child of said child, even if said element is not nested within a children
					element.
					
					Any element in an DOM dialect document nested within an XML element that
					matches the content of a child of a attributes element in a use document
					referenced by a use command by said DOM dialect document shall function as an
					attribute element that translates to an XML attribute with a name matching the
					content of the child of said child, even if said element is not nested within
					an attributes element.
				-
			
			Declaration Element
				
				-
					The root element has the content "Declaration". It may have one or both or both
					of a child with the content "Encoding" and a child with the content
					"Standalone". The child with the content "Encoding" must have a child with
					content matching the name of a character encoding standard. The child with the
					content "Standalone" must have a child with either "Yes" or "No" as its
					content.
				-
			
			Document Element
				
				-
					The document element has the content "Document". It will have a single child
					which will have content in the form of an XML DTD.
				-
			
			XML Elements
			
				-
					An XML element may have any content, unless it is at the root level of the
					document, in which case it may not have the content "Use", "Declaration", or
					"Document", and it may have an indefinite number of children, each of which
					will take the form of a category element.
					
					The content of the element will be literal content.
				-
			
			Category Elements
				
				-
					A category element will take the form of an attributes element, a data element,
					or a children element.
				-
			
			Attributes Element
			
				-
					An attributes element will have the content "Attributes". It may have an
					indefinite number of children, each of which will be an attribute element.
				-
			
			Attribute Element
			
				-
					An attribute element may have any content, and will have a single child which
					may have any content.
					
					The content of both the element and its child will be literal content.
				-
			
			Children Element
				
				-
					A children element will have the content "Children" and may have an indefinite
					number of children, each of which will be an XML element.
				-
			
			Data Element
			
				-
					A data element may have any content other than "Attributes" or "Children", but
					no children.
					
					The content of the element will be literal content.
				-
			
			Literal Content
				
				-
					If literal content starts and ends with a quotation mark, it will represent XML
					content that matches itself where the first and last quotation marks have been
					cropped.
				-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 3 - ONE Dialects: 2 - Build Dialect: 3 - Miscellaneous Dialects: 2 - CSS Dialect'

CSS Dialect
	
	Philosophy
		
		-
			The CSS dialect is a build dialect analogous to CSS.
		-
	
	Principles
	
		Structure
		
			-
				A document written in the CSS dialect shall consist entirely of style elements and
				use elements.
			-
			
			Use Elements
			
				-
					A use element shall have the content "Use" and will have a single child with
					content containing the file path of a ONE+ file which has an element with the
					content "Tags", and an element with the content "CSS".
					
					All of the children of the tags element and all of the children of the css
					element will each have a single child with no children.
				-
			
			Style Elements
			
				-
					A style element shall have the content "Style". A style element must have at
					least one element with the content "Domain", and exactly one element with the
					content "Data".
					
					A domain element's children will specify one of the domains the style block
					effects. A child with no child will represent a tag type. The child of a child
					with the content "On" will represent an ID. The child of a child with the
					content "For" will represent a class. The order in which said children are
					listed dictate their hierarchy.
					
					If an element representing a tag type has content matching the content of a
					child of the tags element in a document referenced by a use element, the
					content of the child of the matching element will be the name of the tag after
					cross compilation. Otherwise, the name of the tag will be the content of the
					element.
					
					The data element's children will each have one child. The content of each child
					of the data element represents an attribute and the content of each of said
					element's children represent the value assigned to the respective attribute.
					
					If a child of the data element has content matching the content of a child of
					the css element in a document referenced by a use element, the content of the
					child of the matching element will be the name of the attribute after cross
					compilation. Otherwise, the name of the tag will be the content of the child of
					the data element.
				-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 3 - ONE Dialects: 2 - Build Dialect: 3 - Miscellaneous Dialects: 3 - SQL Dialect'

SQL Dialect
	
	Philosophy
		
		-
			The SQL dialect is a build dialect analogous to SQL.
		-
	
	Principles
	
		Structure
			
			Use
			
				-
					An element with the content "Use" may have an indefinite number of children,
					each of which with content containing the file path of a ONE+ document.
				-
		
			Statements
			
				-
					A statement is composed of any contiguous set of elements which do not have the
					content "Scope".
				-
			
			Scope
			
				-
					An element with the content "Scope" is equivalent to the statement or
					statements defined by its children.
				-
			
			Splitting
			
				-
					The occurrence of an element with the content "Split" that is nested within an
					element with the content "Scope" denotes that its parent scope element will be
					equivalent to two statements.
					
					The statement preceding the split element will become the first part of each
					statement.
					
					The children of the split element will become the second part of the first
					statement.
					
					The siblings following the split element will become the second part of the
					second statement.
				-
			
			Commands
				
				-
					Commands are elements within a statement that may have children. Whether an
					element is a command or not is dependent on whether its content corresponds to
					an element within a document referenced by a use element.
					
					Each child of a command will be processed as a statement, command, or literal
					depending on its content, and the content of a command will determine how the
					processed forms of its children are formatted during cross compilation.
				-
			
			Literals
			
				-
					Literals are elements which occur within statements but are not commands.
					
					Literals may not have children.
				-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 3 - ONE Dialects: 2 - Build Dialect: 3 - Miscellaneous Dialects: 4 - CSV Dialect'

CSV Dialect

	Philosophy
	
		-
			The CSV dialect is a build dialect analogous to CSV.
		-
	
	Principles
	
		Structure
		
			-
				Every element in the CSV dialect contains the content "Row". Each row element may
				have any number of children as long as it has at least one. Each child of a row
				element may have any content but may have no children.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 1 - ONE: 3 - ONE Dialects: 3 - Super Mode'

Super Mode
	
	Philosophy
		
		-
			Super Mode is an alternate syntax for Kaeon FUSION code that serves to allow for infix
			notation and to reduce verbosity.
		-
	
	Principles
		
		Effects
			
			Interfaces
				
				-
					Super Mode will automatically enable the Standard interface and the Stack
					interface.
				-
			
			Super Tokens
				
				-
					Super tokens are tokens that may be placed within the content of elements.
					
					If a token is not surrounded by double quotes, it will be processed. Certain
					tokens will take priority in the order they are processed if they occur within
					the same element. If multiple tokens have equivalent priority, they will be
					processed from left to right. If a token requires a value it cannot locate, it
					will not be processed. The letter case of a token is irrelevant.
					
					Upon being processed, a token will separate the content that precedes it into a
					left hand value and the content that follows it into a right hand value. Both
					the left hand value and the right hand value will be trimmed of any leading or
					trailing whitespace. If the resulting left hand value has a length of zero, the
					element preceding the element containing the token may serve as the left hand
					value for certain tokens. If the resulting right hand value has a length of
					zero, the element following the element containing the token, or the children
					of the element containing the token, in which case there will be multiple right
					hand values, may serve as the right hand value depending on the token.
					
					Once processed into a left hand value, a token, and a right hand value, an
					effect will be applied depending on the token.
				-
				
				Token Conflicts
				
					-
						If the content of an element matches the name of a command in the standard
						interface or stack interface, or if an element is a directive, any tokens
						within said element will not be processed.
						
						If one token consists of another token followed by an additional sequence
						of characters, the larger token will take priority.
						
						Certain tokens referred to as isolated tokens will only be recognized if
						they are preceded by either the beginning of their element's content or by
						whitespace, and followed either by the end of their element's content or by
						whitespace.
					-
				
				Tokens
				
					First Priority
					
						Abs
						Cos
						Def
						Define
						Elif
						Else
						For
						For Each
						For Range
						Global
						If
						Import
						Log
						Log Line
						LogN
						New
						Params
						Print
						Return
						Sin
						Sqrt
						Tan
						While
						
					Second Priority
					
						=
						&=
						+=
						-=
						*=
						/=
						%=
						
					Third Priority
					
						And
						Not
						Or
						Xor
						
					Fourth Priority
					
						==
						!=
						>
						>=
						<
						<=
						
					Fifth Priority
					
						->
						=>
						~|
						@
						++
						--
					
					Sixth Priority
					
						&
						+
						-
					
					Seventh Priority
					
						**
						*
						/
						%
				
				Effects
					
					Function Parameters
					
						-
							The token "params" may be used to specify function parameters if it is
							nested within the child of a define command. It is an isolated token.
							
							This token will use the children of the command it occurs in as
							alternative right hand values.
							
							The content of each of the token's right hand values shall become an
							alias of a parameter for the function corresponding to the order of
							said right hand values.
						-
					
					Implicit Prefix Notation
					
						-
							Certain tokens may be used in place of certain commands where their
							right hand values will serve as arguments. They are all isolated
							tokens.
							
							These tokens will use the children of the command they occur in as
							alternative right hand values.
							
							The log, log line, import, define, else, not, new, global, and return
							commands may all be used in the form of such a token as opposed to a
							command. The token "print" may be used in place of "log line", the
							token "def" may be used in place of "define", the token "Sin" may be
							used in place of "Sine", the token "Cos" may be used in place of
							"Cosine", the token "Tan" may be used in place of "Tangent", the token
							"Abs" may be used in place of "Absolute Value", the token "Sqrt" may be
							used in place of "Square Root", and the token "LogN" may be used in
							place of "Natural Logarithm".
						-
					
					Conditionals and Loops
						
						-
							The following tokens will use the children of the command they occur in
							as alternative right hand values. They are all isolated tokens.
							
							The token "If" with a right hand value in the form of a value that
							returns a boolean translates to a conditional where its children, not
							including said boolean, are processed if said boolean is true.
							
							The token "Elif" with a right hand value in the form of a value that
							returns a boolean translates to a conditional where its children, not
							including said boolean, are processed if said boolean is true and the
							previous conditional failed to activate.
							
							The token "While" with a right hand value in the form of a value that
							returns a boolean followed by the token "Do" translates to a loop where
							its children, not including said boolean, are processed until said
							boolean is false.
							
							The token "For" with at least one right hand value in the form of a
							value that returns a number translates to a loop where its children,
							not including the first right hand value, are processed for the number
							of times returned by said number.
							
							The token "For Each" with at the least two right hand values, the first
							of which may have any content and the second of which returns a list
							translates to a loop where its children, not including the first two
							right hand values, are processed once for every element in the returned
							list and content of the first right hand value serves as the alias for
							the element in the list at the index corresponding to the current
							iteration.
							
							The token "For Range" with at the least three right hand values, the
							first of which may have any content and the second and third of which
							return numbers, translates to a loop where its children, not including
							the first three right hand values, are processed once for every number
							between the two returned numbers, inclusive, and the miscellaneous
							string serves as the alias for the number corresponding to the current
							iteration.
						-
					
					Infix Operators
						
						-
							An infix operator token will take its left hand value and its right
							hand values, and make them the children of the command containing it,
							with the left hand value preceding the right hand values. The token
							will then be replaced with a standard interface command.
							
							These tokens will use the siblings of the command they occur in as
							alternative left hand values and right hand values.
							
							The tokens recognized as infix operators are listed below along with
							their respective standard interface commands:
							
							&: Concatenate
							@: At
							And: And
							Or: Or
							Xor: Exclusive Or
							>: Greater
							>=: Greater or Equal
							<: Less
							<=: Less or Equal
							==: Equal
							!=: Not: Equal
							**: Power
							*: Multiply
							/: Divide
							%: Modulus
							+: Add
							-: Subtract
							
							The token "-=" indicates the presence of a command that deprecates its
							left hand value by its right hand value.
							
							The token "+=" indicates the presence of a command that increments its
							left hand value by its right hand value.
							
							The token "*=" indicates the presence of a command that multiplies its
							left hand value by its right hand value.
							
							The token "/=" indicates the presence of a command that divides its
							left hand value by its right hand value.
							
							The token "%=" indicates the presence of a command that calculates the
							remainder of its left hand value divided by its right hand value.
							
							The token "&=" indicates the presence of a command that concatenates
							its right hand value to its left hand value.
						-
					
					Postfix Operators
						
						-
							The token "--" indicates the presence of a command that deprecates its
							left hand value by one.
							
							The token "++" indicates the presence of a command that increments its
							left hand value by one.
						-
					
					Special Operators
					
						-
							The token "=" translates to a command that assigns the right hand value
							to a variable with an alias matching its left hand value.
							
							The token "->" translates to a command that performs the functions
							specified by its right hand values within the object specified by its
							left hand value. It will use the children of the element it occurs in
							as alternative right hand values.
							
							The token "=>" translates to a command that returns the variable
							specified by its right hand value from within the object specified by
							its left hand value.
							
							The token "|" translates to performing the commands specified by its
							left hand value with its right hand values as its first argument and
							the children of the command containing it as additional arguments. It
							will use the children of the element it occurs in as alternative right
							hand values.
						-

		Standard+

			-
				Standard+ is when super mode is active by default when interpreting Kaeon FUSION
				code.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 2 - Kaeon APIs'

Kaeon APIs

	Philosophy

		-
			The Kaeon APIs are a set of specifications for utility modules that may be implemented
			in any language unless stated otherwise in such a specification.
		-

	Principles

		Kaeon Framework

			-
				A Kaeon framework is a defined collection of Kaeon APIs which serve a common
				purpose.
			-

		Kaeon Suite

			-
				A Kaeon suite is a module that contains all of the Kaeon APIs available for a given
				language.

				The Kaeon suite for JavaScript shall constitute the Kaeon United JavaScript module.

				The Kaeon suite for Kaeon FUSION shall constitute the Kaeon United FUSION module,
				and shall include the Kaeon FUSION standard interface.
			-

		Kaeon United Alias

			-
				A Kaeon API's name through which it is referenced by Kaeon United is referred to as
				its Kaeon United Alias.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 2 - Kaeon APIs: 1 - APIs: 1 - Core: 1 - ONE Suite'

ONE Suite API

	Philosophy

		-
			The ONE Suite API is an API that may be used for processing ONE, ONE+, and Kaeon FUSION
			in various languages, and for using the universal preprocessor.
		-

	Principles

		Module

			Functions

				Preprocess

					-
						The preprocess function shall take a string as an argument, and shall
						execute any universal preprocessor directives in said string, and shall
						return the resulting string.
					-

				Parse

					-
						The parse function shall take any ONE or ONE+ string as an argument and
						shall return the content of said string in ONE list form, and shall utilize
						the universal preprocessor when parsing.
					-

				Write

					-
						The write function shall take a list representing a ONE document in ONE
						list form, and shall return the content of the document as a ONE document
						string.
					-

				Process

					-
						The process function shall take a ONE document in either the form of a ONE+
						string which may have universal preprocessor directives or in ONE list form
						as its first argument, and may optionally take an object representing a
						saved state of a Kaeon FUSION interpreter, which may be an empty object.

						If it received an interpreter state as an argument, it shall load said
						state into a Kaeon FUSION interpreter, and if not shall load a default
						Kaeon FUSION interpreter, and then shall use said interpreter to process
						the received ONE document as Kaeon FUSION code.

						After running the Kaeon FUSION script, it shall return the return value of
						the Kaeon FUSION script.
					-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 2 - Kaeon APIs: 1 - APIs: 2 - Utilities: 1 - General: 1 - Data: 1 - IO'

IO API

	Philosophy

		-
			The IO API is an API for general purpose IO tasks involving the console and the file
			system.
		-

	Principles

		Module

			Functions

				Get Input

					-
						The get input function takes a string specifying a user prompt, opens a
						user prompt displaying said string, and then returns whatever text the user
						enters.
					-

				Open

					-
						The open function takes a string specifying either a file path or URL and
						returns the string content from said location.
					-

				Run

					-
						The run function takes a string specifying a command line operation, and
						executes said command.
					-

				Save

					-
						The save function takes a string specifying the content of a file as its
						first argument and a string specifying a file path as its second argument,
						and writes the content to a new file at said path.
					-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 2 - Kaeon APIs: 1 - APIs: 2 - Utilities: 1 - General: 1 - Data: 2 - Parsing: 1 - Tokenizer'

Tokenizer API

	Philosophy

		-
			The tokenizer API provides the user with a function that can automatically tokenize any
			text.
		-

	Principles

		Module

			Functions

				Tokenize

					-
						The tokenize function takes a string as its first argument and a list of
						strings representing tokens as its second argument, tokenizes the first
						string based on the specified tokens, in order of the longest tokens to the
						shortest, and returns the tokenized string as a list of strings.
					-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 2 - Kaeon APIs: 1 - APIs: 2 - Utilities: 1 - General: 2 - Application: 1 - Management: 1 - Network: 1 - Server'

Server API

	Philosophy

		-
			The server API provides several functions for running an HTTP or HTTPS server.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 2 - Kaeon APIs: 1 - APIs: 2 - Utilities: 2 - Frameworks: 1 - Vision: 1 - Core'

Vision Core API

	Philosophy

		-
			The vision core API is a Kaeon API that provides functionality for HTML DOM management.
		-
	
	Principles

		Conventions

			Script Engine

				-
					The script engine is a background process which may be started and stopped as
					needed through the vision core API.

					When active, it runs a script every time a fixed interval passes which performs
					certain operations on every element on the page.
					
					First, if an element has not been operated on before by the script engine and
					has an "On Start" function, said function shall be executed. Then, if an
					element has an "On Update" function, said function shall be executed.

					Furthermore, a series of selector rules, each consisting of a rule for
					selecting elements on a given page, as well as a series of properties to assign
					to elements matching said criteria.

					When the script engine operates on an element that it has not operated on
					before, it will find all of the specified selector rules that match said
					element, and apply the properties specified by said rules to said element.

					The default interval for the script engine is one sixtieth of a second.
				-

			Value Types

				Element Selector Value

					-
						An element value is any value that may be used to define an existing DOM
						element or a group of existing DOM elements.

						The two types of elements that may be used to do this are DOM element
						objects, and strings containing the CSS selector of a set of elements,
						where if said strings are taken to specify single elements rather than
						groups, the desired elements shall be the first among said sets in the
						hierarchy of the DOM.
					-

				Element Specification Value

					-
						An element specification value is any value that may be used to define an
						element using the vision core API.

						The two types of elements that may be used to do this are DOM JSON objects,
						and strings containing the outer HTML of a single element. A null value may
						also be used to define a div with no attributes or child nodes.
					-

				Element Value

					-
						An element value is any value that is either an element selector value or
						an element specification value.
					-

				Element Group Value

					-
						An element group value is an array of element values.
					-

				Variable Element Value

					-
						A variable element value may either be an element value or an element group
						value.
					-

		Module

			Variables

				Selector Rules

					-
						The selector rules variable is an object, where the alias of each field is
						a CSS selector, and the value of each field is an DOM JSON object
						specifying the properties to be assigned to any element matching said
						selector.
					-

			Functions

				Create

					-
						The create function takes an element specification value and returns an
						element object with the properties defined by said element specification
						value.
					-

				Extend

					-
						The extend function may take an indefinite number of arguments, but must
						take at least one. From said arguments, one root value and an indefinite
						number of child values shall be derived.

						If the function receives only one argument, said argument must be a
						variable element value, which shall define the child values, and the root
						value shall thus be defined as the root element of the document.

						If the function receives multiple arguments, the first argument must be an
						element selector value, and every subsequent argument must be a variable
						element value. The first argument shall define the root value, and the
						child values shall be the contents of all other arguments concatenated
						together in the order they are defined.

						The function shall append the child values to the root value in order, and
						shall return the root value.
					-

				Get

					-
						The get function shall take one argument, which may either be a CSS
						selector string, or a DOM element object.

						If said argument is a CSS selector string, the function shall return all
						elements in the DOM matching the selector that said string contains.

						If said argument is a DOM element object, an DOM JSON object shall be
						generated which matches the properties of said object, and shall then be
						returned.
					-

				Load

					-
						The load function shall take an indefinite number of strings or string
						arrays, concatenate them together in order, producing the load array.

						Every string in the load array shall specify the URL of either a CSS
						stylesheet or a JavaScript script.

						The function shall load all of the stylesheets and scripts pointed to by
						the load array into the page.
					-

				Is Visible

					-
						The is visible function takes a DOM element object.
						
						It returns true if said element is visible on the page, and returns false
						if not.
					-

				Remove

					-
						The remove function takes an indefinite number of variable element selector
						values, and concatenates them together to produce the removal array.

						The function shall remove every element listed in the removal array from
						the page.
					-

				Set

					-
						The set function shall take an element selector value as its first
						argument, and an element specification value as its second.

						It shall assign to the element selected by the first argument all of the
						properties belonging to the element specified by the second argument.
					-

				Start Script Engine

					-
						The start script function starts the script engine background process if it
						has not already been started.
					-

				Stop Script Engine

					-
						The stop script function stops the script engine background process if it
						has already been started.
					-

				To CSS

					-
						The to CSS function shall take a style JSON object as an argument, and
						shall return a CSS string matching the properties of said object.
					-

				To Element

					-
						The to element function shall take an HTML string containing the outer HTML
						of a single element, and shall return an DOM JSON object matching the
						properties of said element.
					-

				To HTML

					-
						The to HTML function shall take a DOM JSON object as an argument, and shall
						return a string containing the outer HTML of an element matching the
						properties of said object.
					-

				To Style

					-
						The to style function shall take a CSS string as an argument, and shall
						return a style JSON object matching the properties of said string.
					-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 2 - Kaeon APIs: 1 - APIs: 2 - Utilities: 2 - Frameworks: 2 - Waypoint: 1 - Core'

Waypoint Core API

	Philosophy

		-
			The waypoint core API is a Kaeon API that provides functionality for action ACE.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 2 - Kaeon APIs: 1 - APIs: 2 - Utilities: 2 - Frameworks: 2 - Waypoint: 2 - Utilities: 1 - K-Auth: 1 - Core'

K-Auth Core API

	Philosophy

		-
			The K-Auth core API is a Kaeon API for integrating the level 3 standard method of user
			verification on both the front and back ends of web services.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 2 - Kaeon APIs: 1 - APIs: 2 - Utilities: 2 - Frameworks: 3 - Control: 1 - Core'

Control Core API

	Philosophy

		-
			The control core API is a Kaeon API that serves to format and transmit GHI calls
			according to prefabricated commands.
		-

	Principles

		Conventions

			Control Core Command

				-
					A control core command is a JSON object specifying data to incorporate into a
					GHI call so as to produce a given effect on a target device.

					A control core command shall contain a field with the alias "command", which
					contains a string specifying the name of a feature to be incorporated into a
					GHI call.
					
					Depending on what said command is, a control core command may also contain a
					field with the alias "operation", which, if present, contains a JSON object
					specifying the details of the feature to be incorporated into a GHI call.

					A control core command may take into account the type of the target device as
					well as its current state.

					A codified definition for a control core command is called a control core
					command definition.

					The results of applying a control core command to the contents of a GHI call
					may vary in terms of how said contents are formatted, and as such, control core
					command definitions shall be specified in terms of their effects on the target
					devices.
				-

			Control Core Device

				-
					A control core device is a standard governing the available modules on a given
					device to which GHI calls may be directed.

					If no device is specified, the control core API shall assume the target device
					to possess the same modules as a Raspberry Pi.

					A codified definition for a control core device is called a control core device
					definition.
				-

			Control Core Service

				-
					A control core service is a JSON object specifying how a GHI call is to be
					directed to a target device through a given API.

					A control core service shall contain a field with the alias "service", which
					contains a string specifying the name of an API through which to transmit a GHI
					call.
					
					Depending on what said service is, a control core service may also contain a
					field with the alias "credentials", which, if present, contains a JSON object
					specifying the target and authentication keys for a given GHI call.

					A codified definition for a control core service is called a control core
					service definition.
				-

		Module

			Functions

				Call

					-
						The call function shall take a JSON object and a list of control core
						commands, and may also take two callback functions, the first for sending a
						call, and the second for retrieving calls.

						The JSON object shall have a field with the alias "contact", containing a
						control core service object, and may also have a field with the alias
						"state", containing the state of a target device in the receptor input
						format, as well as a field with the alias "device", containing a string
						specifying the type of device to which a given GHI call is to be directed.

						The function shall generate a JSON object in the receptor output format by
						passing the command list, the device field of the JSON object, if present,
						and the state field of the JSON object, if present, to the get message
						function.

						It shall then pass the result of the previous step, along with the contact
						field of the JSON object and the first callback function, if present, to
						the send call function.

						Finally, it shall call the get calls function with the contact field of the
						JSON object, no time value, and, if present, the second callback function,
						and shall return the result.
					-

				Get Calls

					-
						The get calls function shall take a control core service object, and may
						also take an argument specifying a specific time value, either a number
						specifying a system time value in seconds, or a string specifying a date
						and time, as well as a callback function.

						It shall retrieve all messages sent to the API and account specified by the
						control core service object, omitting any that were logged after the passed
						in time value if said value was specified, and shall log said values in a
						JSON list, containing an object for each message retrieved, where each
						object has a field with the alias "data", containing a string specifying
						the message to which it corresponds, and a field with the alias "time",
						containing a number specifying the system time in seconds that the message
						to which it corresponds was logged.

						If no callback function was passed in, the call shall be made synchronously
						and the function shall return the generated list, but if a callback
						function was passed in, the call shall be made asynchronously, after which
						the generated list shall be passed to the callback function and the get
						calls function shall return an empty list.
					-

				Get Message

					-
						The get message function shall take a list of control core commands, and
						may also take a string naming the type of a given target device, as well as
						the current state of a given target device in the receptor input format.

						It shall return a JSON object in the receptor output format, which may be
						used as the content of a GHI call corresponding to the given control core
						commands.
					-

				Send Call

					-
						The send call function shall take a control core service object and a
						string, and may also take a callback function.

						It shall send the content of the string to a target device through an API
						as specified by the control core service object, and if a callback function
						was provided, shall attempt to retrieve the most recent state of the target
						device as shall pass said state to the callback function in the receptor
						input format if successful.

						It may also return any object immediately returned by the API call, and
						shall return a null value if no such value is generated.
					-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 2 - Kaeon APIs: 1 - APIs: 2 - Utilities: 2 - Frameworks: 3 - Control: 1 - Core: 1 - Commands: 1 - Receptor: 1 - Reset'

Control Core Receptor Reset

	Philosophy

		-
			Control core receptor reset is a control core command definition.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 2 - Kaeon APIs: 1 - APIs: 2 - Utilities: 2 - Frameworks: 3 - Control: 1 - Core: 1 - Commands: 1 - Receptor: 2 - Set'

Control Core Receptor Set

	Philosophy

		-
			Control core receptor set is a control core command definition.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 2 - Kaeon APIs: 1 - APIs: 2 - Utilities: 2 - Frameworks: 3 - Control: 1 - Core: 1 - Commands: 2 - GPIO: 1 - Set'

Control Core GPIO Set

	Philosophy

		-
			Control core GPIO set is a control core command definition used for setting the states
			of GPIO pins on or connected to targeted UIMs.

			A control core command object formatted according to the control core GPIO set
			definition is called a control core GPIO set object.
		-

	Principles

		Command

			-
				The value of the command field for a control core GPIO set object shall be the
				string "GPIO set".
			-

		Operation

			-
				The operation object of a control core GPIO set object shall have a field with
				the alias "pins", containing an object.

				The pins object shall have a field for every pin for which a value is to be set,
				where each the alias of each field is the index of its corresponding pin according
				to the GPIO pin map of the targeted device, and the content of each field is the
				value to which its corresponding pin is to be set.

				If the operation is aimed at a pinout interface of a device connected to the
				targeted device via a serial port, the operation object of a control core GPIO set
				object shall have a field with the alias "board", containing an object matching the
				value of the device field that the GHI serial convention would use to specify said
				connected device.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 2 - Kaeon APIs: 1 - APIs: 2 - Utilities: 2 - Frameworks: 3 - Control: 1 - Core: 1 - Commands: 2 - GPIO: 2 - Flip'

Control Core GPIO Flip

	Philosophy

		-
			Control core GPIO flip is a control core command definition.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 2 - Kaeon APIs: 1 - APIs: 2 - Utilities: 2 - Frameworks: 3 - Control: 1 - Core: 1 - Commands: 2 - GPIO: 3 - Flicker'

Control Core GPIO Flicker

	Philosophy

		-
			Control core GPIO flicker is a control core command definition.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 2 - Kaeon APIs: 1 - APIs: 2 - Utilities: 2 - Frameworks: 3 - Control: 1 - Core: 1 - Commands: 3 - Drone: 1 - Launch'

Control Core Drone Launch

	Philosophy

		-
			Control core drone launch is a control core command definition used for launching
			Wi-Fi drones and keeping them airborne until they are instructed or forced to land.

			A control core command object formatted according to the control core drone launch
			definition is called a control core drone launch object.
		-

	Principles

		Command

			-
				The value of the command field for a control core drone launch object shall be
				"drone launch".
			-

		Operation

			-
				The operation object of a control core drone launch object shall have a field with
				the alias "drone", containing the W-Fi SSID of the target drone.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 2 - Kaeon APIs: 1 - APIs: 2 - Utilities: 2 - Frameworks: 3 - Control: 1 - Core: 2 - Services: 1 - Hologram'

Control Core Hologram

	Philosophy

		-
			Control core hologram is a control core service definition for relaying calls sent over
			the Hologram network.

			A control core service object formatted according to the control core hologram
			definition is called a control core hologram object.
		-

	Principles

		Service

			-
				The value of the service field for a control core hologram object shall be
				"hologram".
			-

		Credentials

			-
				The credentials object of a control core hologram object shall have a field with
				the alias "deviceID", containing the device ID of the target device, a field with
				the alias "webhookGUID", containing the webhook GUID of the target device, a field
				with the alias "apiKey", containing the API key of the user's account, and a field
				with the alias "orgID", containing the organization ID of the user's account.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 2 - Kaeon APIs: 2 - Kaeon Frameworks: 1 - Process Suite'

Process Suite

	Philosophy

		-
			All of the communication and AI utilities, and suites thereof, within the Kaeon APIs
			shall collectively be known as the process suite.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 2 - Kaeon APIs: 2 - Kaeon Frameworks: 1 - Process Suite: 1 - K-COM'

K-COM

	Philosophy

		-
			All of the communication utilities, and suites thereof, within the Kaeon APIs shall
			collectively be known as K-COM.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 2 - Kaeon APIs: 2 - Kaeon Frameworks: 1 - Process Suite: 1 - K-COM: 1 - Backend: 1 - Kaeon Stream'

Kaeon Stream

	Philosophy

		-
			All of the server management utilities within the Kaeon APIs shall collectively be
			known as Kaeon Stream.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 2 - Kaeon APIs: 2 - Kaeon Frameworks: 1 - Process Suite: 1 - K-COM: 1 - Backend: 2 - Kaeon Waypoint'

Kaeon Waypoint

	Philosophy

		-
			All of the state and data management utilities within the Kaeon APIs shall collectively
			be known as Kaeon Waypoint.
		-

	Principles

		Conventions

			Action ACE

				-
					Kaeon Waypoint shall primarily be designed around action ACE.
				-

		APIs

			Waypoint Core

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 2 - Kaeon APIs: 2 - Kaeon Frameworks: 1 - Process Suite: 1 - K-COM: 1 - Backend: 2 - Kaeon Waypoint: 1 - K-Auth'

K-Auth

	Philosophy

		-
			All of the user verification and profile management utilities within the Kaeon APIs
			shall collectively be known as K-Auth.
		-

	Principles

		APIs

			K-Auth Core

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 2 - Kaeon APIs: 2 - Kaeon Frameworks: 1 - Process Suite: 1 - K-COM: 2 - Kaeon Control'

Kaeon Control

	Philosophy

		-
			All of the hardware control utilities within the Kaeon APIs shall collectively be known
			as Kaeon Control.

			Kaeon Control aims to be as universal as possible, but places a special focus on
			compatibility with the general IoT stack.
		-

	Principles

		APIs

			Control Core

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 2 - Kaeon APIs: 2 - Kaeon Frameworks: 1 - Process Suite: 2 - Kaeon SOUL'

Kaeon SOUL

	Philosophy

		-
			All of the AI utilities within the Kaeon APIs shall collectively be known as Kaeon
			SOUL.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 2 - Kaeon APIs: 2 - Kaeon Frameworks: 2 - Interface Suite'

Interface Suite

	Philosophy

		-
			All of the interface utilities, and suites thereof, within the Kaeon APIs shall
			collectively be known as the interface suite.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 2 - Kaeon APIs: 2 - Kaeon Frameworks: 2 - Interface Suite: 1 - Kaeon Vision'

Kaeon Vision

	Philosophy

		-
			All of the UI utilities within the Kaeon APIs shall collectively be known as Kaeon
			Vision.
		-

	Principles

		APIs

			Vision Core

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 2 - Kaeon APIs: 2 - Kaeon Frameworks: 2 - Interface Suite: 2 - Game Kaeon'

Game Kaeon

	Philosophy

		-
			All of the game development utilities within the Kaeon APIs shall collectively be known
			as Game Kaeon.
		-

	Principles

		Conventions

			Kaeon ACE Liberty

				-
					All of the utilities within the Kaeon APIs that pertain to Kaeon ACE Liberty
					shall, unless otherwise specified, fall under Game Kaeon.
				-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 2 - Kaeon APIs: 2 - Kaeon Frameworks: 3 - Code Suite'

Code Suite

	Philosophy

		-
			All of the coding utilities, and suites thereof, within the Kaeon APIs shall
			collectively be known as the code suite.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 3 - Applied: 1 - Applications'

Kaeon Apps

	Philosophy

		-
			The Kaeon Apps are a suite of applications integrated into Kaeon United.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 3 - Applied: 1 - Applications: 1 - Apps: 1 - Kaeon Code'

Kaeon Code

	Philosophy

		-
			Kaeon Code is an online code editor and code playground with support for Kaeon FUSION,
			United JavaScript, and HTML, with additional utilities for ONE+ and the Universal
			Preprocessor.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 3 - Applied: 1 - Applications: 1 - Apps: 2 - Kaeon Cast'

Kaeon Cast

	Philosophy

		-
			Kaeon Cast is a cache directed application which may be used to project videos and
			video streams from separate applications and devices.
		-

	Principles

		Common Cache

			-
				Kaeon Cast shall, on regular intervals, fetch a value from a predetermined
				conventional common cache server.
			-

		Channel Specification

			-
				The key to fetch from the server shall be specified in a URL argument with the
				alias "key".
			-

		Playback

			-
				Kaeon Cast shall operate in fullscreen mode by default, and shall display a blank
				white screen when not playing anything.

				When the value fetched from the server is updated by an external application as
				indicated by the accompanying time value, Kaeon Cast shall load the video or video
				stream at the URL or video ID specified by the retrieved value and play it until it
				ends or until said value changes.
				
				If the video is embedded in a page served by a video or video stream hosting
				service, Kaeon Cast shall only play said media after extracting and isolating it
				from any background elements.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 3 - Applied: 1 - Applications: 2 - Kaeon Origin Utilities'

Kaeon Origin Utilities

	Philosophy

		-
			This document lists commands and utilities for Kaeon Origin and Kaeon Oracle.
		-

	Principles

		Conventions

			Case Sensitivity

				-
					Kaeon Origin and Kaeon Oracle commands shall be case insensitive unless
					otherwise specified.
				-

			Dependencies

				Default Cache

					-
						The default cache is the default common cache server used by all Kaeon
						Origin and Kaeon Oracle commands as needed unless otherwise specified.
					-

		Commands

			Kaeon Origin Commands

				Clear

					-
						If Kaeon Origin receives the command "clear" from a terminal interface, the
						contents of said terminal shall be cleared.
					-

				Code

					-
						If Kaeon Origin receives the command "code", it shall open the Kaeon Code
						application.
					-

				Cast

					-
						If Kaeon Origin receives the command "cast", it may have one or two
						arguments, the first being a common cache key, and the second, if present,
						being a value to assign to said key.

						If only the first argument is received, Kaeon Cast shall be opened and set
						to listen to the specified key.

						If both arguments are received, the value of the specified key shall be set
						to the specified value.
					-

			Kaeon Oracle Commands

				Play -

					-
						If a dynamic response command received by Kaeon Oracle starts with "Play",
						Kaeon Oracle shall take the text of said command following the first word,
						search for a video using said text as a query, and play the audio from the
						first video it finds.

						If audio from a previous use of the play command is already playing, it
						shall be stopped.
					-

				Stop

					-
						If a dynamic response command received by Kaeon Oracle is "Stop", the audio
						from any previous use of the play command that is currently playing shall
						be stopped.
					-

				Cast -

					-
						If a dynamic response command received by Kaeon Oracle starts with "Cast",
						and does not contain the word "to", Kaeon Oracle shall take the text of
						said command following the first word, and execute the Kaeon Origin cast
						command with said text as the first argument.
					-

				Cast - to -

					-
						If a dynamic response command received by Kaeon Oracle starts with "Cast",
						and does contain the word "to", Kaeon Oracle shall take the text of said
						command following the first word and prior to the first instance of the
						word "to", and the text following the first instance of the word "to", and
						execute the Kaeon Origin cast command with the former text as the first
						argument, and the latter text as the second argument.
					-

				Tell me about -

					-
						If a dynamic response command received by Kaeon Oracle starts with "Tell me
						about", Kaeon Oracle shall take the text of said command following the
						three words, search for an article using said text as a query, and audibly
						recite the first paragraph of said article.
					-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 3 - Applied: 2 - Devices'

Kaeon Ro

	Philosophy
	
		-
			Kaeon Ro is the collective set of physical objects which Kaeon United operates within
			or upon.

			The subset of Kaeon Ro which Kaeon United operates within is referred to as United Ro,
			and the subset of United Ro which Kaeon Aether operates within is referred to as Aether
			Ro.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 2 - Kaeon Series: 3 - Applied: 2 - Devices: 1 - Security: 1 - Locker Viewer'

Locker Viewer

	Philosophy

		-
			A locker viewer is a specialized PC for reading and writing encrypted data on external
			memory units.
		-

	Principles

		Memory Unit

			-
				An external memory unit used by a locker viewer, called a locker viewer unit, shall
				contain only a single plain text file in encrypted form, called a locked file.
				
				The default name of a locked file shall be "locked.txt".
			-

		Configuration

			-
				A locker viewer shall have no wireless communication capabilities, shall have a
				single keyboard as its interface, and shall have a monitor, but no speakers.

				All of the above components shall be permanently fixed together, with at least two
				ports exposed for external memory units, each of which shall have a numerical ID.

				The casings of locker viewers and locker viewer units shall integrate faraday cages
				to protect them from wireless exploits of flaws in their circuitry.
			-

		Software

			Unit Check

				-
					When a locker viewer unit is inserted into a locker viewer, it shall be scanned
					to see if its contents follow the guidelines for a locker viewer unit, and if
					not, the locker viewer unit shall be automatically flashed and its contents
					shall be replaced with a single blank locked file.
				-

			Algorithms

				-
					A locker unit may support multiple encryption algorithms, each of which shall
					be assigned a numerical ID.
				-

			Interface

				-
					A locket unit's primary interface shall consist of a terminal which is limited
					to the following commands: edit, set, clear, and copy. Each command shall be
					cleared from the terminal after execution.

					The edit command shall take as its first argument the ID of a port in which a
					locker viewer unit is inserted, as its second argument the ID the encryption
					algorithm used on the contents of the unit, and as its third argument the
					password used to encrypt the contents of the unit.

					The edit command shall then open a plain text editor displaying the decrypted
					contents of the specified locker viewer unit. When exiting the text editor, the
					user may choose to save the changes made to the file, and if they choose to do
					so, the new text shall be encrypted once more and written to the locker viewer
					unit, overwriting the pre-existing contents.

					The set command shall take as its first argument the ID of a port in which a
					locker viewer unit is inserted, as its second argument the ID the encryption
					algorithm used on the contents of the unit, as its third argument the password
					used to encrypt the contents of the unit, as its fourth argument the ID of an
					encryption algorithm to re-encrypt the contents of the unit with, and as its
					fifth argument the password to re-encrypt the contents of the unit with.

					The clear command shall take an indefinite number of arguments, each of which
					shall be the ID of a port for which the unit inserted into it shall have its
					contents erased and replaced with a blank locked file.

					The copy command shall take as its first argument the ID of a port to copy
					content from, and each subsequent argument shall be the ID of a port to copy
					said content to.
				-

			Data Deletion

				-
					When a locker viewer erases data from an inserted device, it shall perform a
					physical erasure of its memory by setting all available bits to zero.
				-

		Compliance

			-
				Locker viewers and locker viewer units that follow all of the criteria specified in
				this document are referred to as compliant, and those that do not are referred to
				as non-compliant.
			-

		Best Practices

			-
				Locker viewer units, when not being used, should be kept in a guarded location and
				sealed in a vault that requires both a physical key and a password to open.
				
				Said vault should integrate a faraday cage and its locking mechanisms should be
				analog, and thus should not require any electricity.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 3 - Development: 1 - Conventions: 1 - Principles: 1 - Convergence'

Convergence

	Philosophy

		-
			The principle of convergence states that when designing a system, it should first be
			determined what the central elements of said system have in common. Then, the first
			components of said system to be created should serve these common needs.

			Next, the remaining elements of the system should be grouped according to common needs
			and the process should be repeated, ideally until no more commonalities can be
			identified.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 3 - Development: 1 - Conventions: 1 - Principles: 2 - Separation'

Separation

	Philosophy

		-
			The principle of separation states that what can be distinguished from its environment
			ought to be identified as such.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 3 - Development: 1 - Conventions: 1 - Principles: 3 - Clustering'

Clustering

	Philosophy

		-
			The principle of clustering states that components of a system should be grouped
			together according to their similarities.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 3 - Development: 1 - Conventions: 2 - Ideals: 1 - The Creative Ideal'

The Creative Ideal

	Philosophy

		-
			The creative ideal is the notion that creative technology should strive to be
			sufficiently advanced yet also sufficiently simple to use such that one can create
			whatever they envision with as little effort as possible, effectively reducing the
			creative process to saying "be", and having it be.
		-

	Principles

		The Creative Compromise

			-
				If one lacks the knowledge or resources to build what they want to build, they
				should build the closest thing they can to their vision, no matter how big the gap
				between the fantasy and the reality may be, and they should continue to improve it
				as they acquire more knowledge and resources, until fantasy and reality begin to
				align.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 3 - Development: 1 - Conventions: 2 - Ideals: 2 - Suite Corruption'

Suite Corruption

	Philosophy

		-
			Suite corruption is where engineers are forced to abandon utilities and techniques they
			have grown reliant upon.
		-

	Principles

		1 - The Seven Deadly Sins

			1.1 - Payment

				-
					Payment is when a tool charges for its use, though a freemium model mitigates
					the severity of it.
				-

			1.2 - Signup

				-
					Signup is when a tool requires the submission of user information for its use.
				-

			1.3 - Setup

				-
					Setup is when a tool requires the user to manually register for, or install,
					specialized dependencies, becoming more severe the more manual effort is
					required.
				-

			1.4 - Decay

				-
					Decay is when a tool loses support or compatibility over time.
				-

			1.5 - Rigor

				-
					Rigor is when a tool requires highly specialized knowledge for its use where
					reasonable abstractions are possible to mitigate said barrier.
				-

			1.6 - Excess

				-
					Excess is where the interface of a tool is excessively obtuse, taking its most
					severe form when the tool is only usable through visual interfaces.
				-

			1.7 - Limits

				-
					Limits, the most severe of the seven sins, is when the usage of a tool makes
					certain types of development impossible to perform.
				-

		2 - The Sins of Bondage

			2.1 - The Sin of Commitment

				-
					The sin of commitment is when the usage of certain tools render others
					unusable.
					
					Thus, it forces commitment to one stack at the expense of others and renders
					migration itself impossible without restarting from scratch.
				-

			2.2 - The Sin of Baggage

				-
					The sin of baggage is when a tool cannot be used independently of a specific
					environment.
				-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 3 - Development: 1 - Conventions: 2 - Ideals: 3 - The Great Art'

The Great Art

	Philosophy

		-
			Programming; the art of understanding, deconstructing, and reconstructing reality
			through abstraction; the physical manifestation of philosophy itself; and the
			crossroads of all other disciplines; may be referred to as the great art; or the great
			craft.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 3 - Development: 1 - Conventions: 2 - Ideals: 3 - The Great Art: 1 - Computacy'

Computacy

	Philosophy

		-
			Computacy is the ability of a given person to understand and make use of computational
			concepts.

			Thus, to have computacy is to be computate, the lack of computacy is incomputacy, and
			to lack computacy is to be incomputate.
		-

	Principles

		Computacy as Enhanced Literacy

			-
				As oral speech is to transmit information, and written language is to encode
				information, computer programming is to make information come alive and to give it
				power.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 3 - Development: 1 - Conventions: 2 - Ideals: 3 - The Great Art: 1 - Computacy: 1 - Model of Computing'

Fundamental Model of Computing

	Philosophy

		-
			The fundamental model of computing defines computing as the execution of a sequence of
			steps, where each step is the execution of an operation in one of the three modes of
			computing, those being the first mode, to transform data internally, the second mode,
			to receive data from an external source, and the third mode, to transfer data to an
			external source. 

			The first mode can be called the core mode, and the second and third modes may be
			referred to as the two channels.
		-

	Principles

		The Six Definitions

			1 - Program

				-
					A program is a set of data from which a sequence of steps may be derived.
				-

			2 - Programming Language

				-
					A programming language is a method of deriving a set of steps from a set of
					data.
				-

			3 - Code

				-
					Code is the visual or physical representation of a program.
				-

			4 - Computer

				-
					A computer is a mechanism that performs computation.
				-

			5 - Memory

				-
					Memory is an external mechanism that a computer can connect to through which
					data can be stored and retrieved.
					
					Data within memory may be organized.
				-

			6 - Programmer

				-
					A programmer is one who creates programs via constructing code.
				-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 3 - Development: 1 - Conventions: 2 - Ideals: 3 - The Great Art: 1 - Computacy: 1 - Model of Computing: 1 - The Universal Basics'

The Universal Basics of Programming

	Philosophy

		-
			The universal basics of programming, or the five basics, listed in order in this
			document, along with related concepts, are the basic concepts one must learn in order
			to develop the vast majority of programs, as they constitute the key mechanisms through
			which the first mode of computing operates.

			The five basics, which themselves are spread across three chapters, taken together with
			the two channels, can be called the seven basics.

			The understanding of, and ability to apply the universal basics of programming
			constitutes functional computacy.
		-

	Principles

		The Three Chapters of the Five Basics

			The Two Forms - Data

				Variables { Literals }
				
					The Four Types
					
						Numbers: Modulus
						Characters: Strings
						Booleans: Boolean Logic: Not, And, Or, Xor
						Null Values

				Lists: Strings, Objects: Classes

			The Two Paths - Flow

				Conditionals
				Loops

			Functions: Composition { Parameters { Arguments }, Returning }, Recursion

		Related Topics

			Scope: Nesting
			Computational Complexity

			Code Styles

				-
					At some point, it is ideal for programmers to be exposed to programming styles
					that utilize a LISP-like form, such as what Kaeon FUSION uses, in order to help
					them grasp the underlying structure of programs regardless of their syntax and
					to give them powerful insights into the nature of code that can be applied
					beyond programming.
				-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 3 - Development: 1 - Conventions: 2 - Ideals: 3 - The Great Art: 1 - Computacy: 2 - The Basic Test'

The Basic Test

	Philosophy

		-
			A basic test refers to any test designed to confirm functional computacy.
		-

	Principles

		Preparation

			-
				In and of themselves, the essential principles of functional computacy can be
				taught to anyone fairly quickly, in a few hours or less; but mastery sufficient to
				pass the basic test may take longer.
			-

		The General Basic Test

			Format

				-
					The general basic test is a test of functional computacy where the subject is
					to iterate over a list, apply one of two functions to each element of the list
					according to whether the index is odd or even, append the return values of said
					functions to a new list in order, and log the content of the new list at the
					end.
				-

			Default

				-
					The default general test has the original list contain the upper case letters
					of the alphabet, has the first function return the input string converted to
					lower case, and has the second function return a boolean indicating whether the
					input string is included in the string "HELLO, WORLD!".
				-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 3 - Development: 2 - Methods: 1 - Kaeon Process'

Kaeon Process Conventions

	Philosophy
	
		-
			This document specifies conventions for the Kaeon Process, which may also be called
			specification driven development, spec driven development, ideal development, or
			Platonic development.
		-
	
	Principles
		
		Specification

			Crystallization and Fragmentation Usage

				-
					Crystallization is useful when multiple separate projects have similar or
					overlapping scopes, and fragmentation is used when a component of a project may
					have uses outside of said project, though the new projects generated by
					fragmentation may remain as dependencies of the original.
				-

			Minimalism

				-
					The specification should strive to be as minimalistic as possible in the
					language it uses to outline its terms, without sacrificing any relevant detail.
				-

			Specification Library

				-
					A specification library is an organized collection of related specifications.
				-

			Static and Dynamic Terms

				-
					The terms of the specification may be categorized as either static, which all
					implementations must abide by, or dynamic, which grants the developers some
					degree of liberty to decide if, and if so, how to implement certain aspects of
					the product or service.
				-

		Documentation

			Contents

				-
					The documentation are the documents that outline all aspects of the project
					that lie outside the scope of the specification, including development
					priorities, resource allocation, timelines, changelogs, records, developer
					wikis, user guides, and code comments, among other things.
				-

		Implementation

			Validity

				-
					The degree to which a given implementation conforms to the terms of the
					specification is referred to as its validity.
					
					Though it may to some degree be subjective, it may be quantified in terms of
					percentage.

					Validity, while highly important, should never be a burden to the progress of a
					project, and so some level of subjective judgement is acceptable in terms of
					granting leeway when it comes to following the specification to the letter and
					in terms of going beyond the requirements of the specification.
				-

			Release Points

				-
					The developers of a project may define milestone release points in the
					documentation where an implementation may be fit for an initial release or
					version update once a certain set of features have been developed.
					
					Between milestone release points and following project completion, patches may
					also be released.
				-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 3 - Development: 2 - Methods: 1 - Kaeon Process: 1 - Notes'

Kaeon Process Notes

	Philosophy

		-
			This document lists notes regarding the Kaeon Process.
		-

	Principles

		Advantages

			Resilience

				-
					The Kaeon process offers resilience through its enforcement of a specification
					which is itself removed from the fate of a particular implementation or
					organizational context, which allows the idea of the project to survive a
					collapse of a given organization or development effort, and to be passed on to
					others.

					The use of a specification also helps to preserve order during development even
					when the development process becomes chaotic.
				-

			Scalability

				-
					The Kaeon process offers a level of organizational complexity which is
					manageable for small teams and necessary for large teams.

					It also assists small teams in organizing projects much larger than teams of
					that size normally take on.
				-

			Adaptability

				-
					An implementation of a project developed under the Kaeon process may utilize
					other development methodologies such as agile or waterfall.

					The process may also be applied to projects that lie outside the scope of
					software.
				-

		Best Practices

			Plain Text

				-
					The specification documents used in projects utilizing the Kaeon Process should
					ideally be written in plain text.
				-

		Analogies

			Branches of Government

				-
					The three branches can be thought of as analogous to a government, where the
					specification is the legislative branch, the documentation is the judicial
					branch, and the implementations are the executive branch.
				-

			Platonic Idealism

				-
					In a platonic sense, the specification can be thought of as the platonic ideal
					of the project.
				-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 3 - Development: 2 - Methods: 1 - Kaeon Process: 2 - Documentation: 1 - Triple Log System'

Triple Log System

	Philosophy

		-
			The triple log system is the use of two types of documentation for handling task
			management, the ordered log, the chaotic log, and the journal log, which collectively
			constitute a triple log.

			The ordered log is a formal agile task board, the chaotic log is a note board where any
			idea may be written as it comes into one's stream of consciousness, such ideas being
			referred to as chaos notes, and the journal log is a written record of events that took
			place during one's work and the times at which they occurred. The chaotic log may be
			used to filter ideas into the ordered log.

			Notes regarding completed tasks from the ordered log may be chronicled in formal
			reports, and the completion criteria of some of said tasks may mandate the production
			of such a report.
		-

	Principles

		Triple Log Library

			-
				A triple log library is an organized collection of triple logs.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 3 - Development: 2 - Methods: 1 - Kaeon Process: 2 - Documentation: 2 - Formats: 1 - Kaeon Report Format'

Kaeon Report Format

	Philosophy

		-
			The Kaeon report format is a Kaeon document format used for chronicling the results of
			research and development activity.

			A document written in the Kaeon report format is called a Kaeon report.
		-

	Principles

		Philosophy Section

			-
				The philosophy section of the document shall serve as the abstract section of the
				document.
			-

		Principles Section

			Main Sections

				-
					The principles section of the document may have a child with the content
					"Discourse", and a child with the content "Metadata".

					If both are present, the discourse element shall precede the metadata element.

					The discourse element may have a child with the content "Projects", a child
					with the content "Notes", and a child with the content "Analysis".

					The metadata element may have a child with the content "Figures", and a child
					with the content "Authors".
				-

			Discourse

				Projects

					-
						Each activity undertaken in the scope of the research and development that
						a given Kaeon report concerns is called a project.

						The documentation of a project in a Kaeon report is modeled after the
						scientific method.

						Each project shall be catalogued as a child of the projects element, with
						each of said children being referred to as a project element.

						A project element shall have content containing its numerical index under
						its parent, where said indices begin at one.

						A project element shall have two children, the first child having the
						content "Hypothesis", and the third child having the content "Tests".

						The hypothesis element shall have a child with content that describes what
						those who participated in the project were attempting to do and what they
						expected to happen following the end of the project.

						The test element may have an indefinite number of children referred to as
						test elements.

						A test element shall have content containing its numerical index under its
						parent, where said indices begin at one.

						Each test element shall have a child with the content "Methods", and a
						child with the content "Results".

						The methods element shall have a child with content specifying the nature
						of an action taken to test the hypothesis.

						The results element shall have a child with content specifying what
						happened as a result of said test.
					-

				Notes

					-
						The notes element may have any children, which shall serve to provide
						commentary and analysis on the rest of the report.
					-

				Analysis

					-
						The analysis element shall have a child containing content summarizing the
						key takeaways from the report.
					-

			Metadata

				Figures

					-
						The figures element shall have a child for each figure relevant to the
						report. Said children shall be called figure elements.

						A figure element shall have content containing its numerical index under
						its parent, where said indices begin at one.

						A figure element shall have two children, one with the content
						"Description", and the other with the content "Data".

						The description element shall have a child with content specifying what the
						figure represents.

						The data element may have any children, which shall serve to host the
						content of the figure.
					-

				Authors

					-
						The authors element shall have a child for each author of the report, each
						containing content specifying the name of said author.
					-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 3 - Development: 2 - Methods: 1 - Kaeon Process: 2 - Documentation: 2 - Formats: 1 - Kaeon Report Format: 1 - Kaeon Citation'

Kaeon Citation

	Philosophy

		-
			A Kaeon citation is the use of a universal preprocessor comment directive, with the
			directive language declared using a null sequence, placed into written text, and with
			the directive content specifying a citation to a resource.

			The directive content shall consist of a ONE element written in ONE+. Said element
			shall have the content "Citation". Said element shall have a child specifying the name
			of a resource. If said resource is the document making the citation, said child's
			content shall be a null sequence. Said child may itself have a child containing the
			location of the cited information within the resource.
		-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 3 - Development: 2 - Methods: 1 - Kaeon Process: 2 - Documentation: 2 - Formats: 2 - Ticket Log Format'

Ticket Log Format

	Philosophy

		-
			The ticket log format is a Kaeon document format used to log the issuing and completion
			of project tickets.

			A document in the ticket log format is called a ticket log document.
		-

	Principles

		Ticket Properties

			-
				A ticket shall have a unique numerical ID, a text description, and a status, which
				may be open, meaning that no one is working on it, active, meaning that someone is
				working on it, submitted, meaning that whoever was working on it has submitted it
				for approval, and complete, meaning that it has been successfully completed.

				By default, the status of all tickets is set to open.

				Tickets may be assigned a due date and time, an indefinite number of prerequisite
				tickets which must be completed before itself, an indefinite number of string tags,
				indicating which groups they belong to, and an indefinite number of notes.

				A ticket may also be assigned a numerical class based on its perceived difficulty,
				from one to any arbitrarily high number, where higher numbers represent higher
				difficulty.

				A complete ticket may be assigned a numerical grade on a scale from zero to one,
				corresponding to the quality of the job done, where the higher the number is, the
				better the job. If no grade is specified, the grade shall be assumed to be one.
			-

		Ticket Format

			-
				The principles section of the document shall have a child for every ticket issued
				for the project.

				The content of each of said elements shall be a numerical ID unique from all other
				such elements. Said elements shall have a child with the content "Description", and
				a child with the content "Status"
				
				If the ticket to which the element corresponds has been assigned a class, then the
				element shall also have a child with the content "Class".

				If the ticket has been assigned prerequisites, then the element shall have a child
				with the content "Prerequisites".

				If the ticket has been assigned tags, then the element shall have a child with the
				content "Tags".

				If the ticket has been assigned notes, then the element shall have a child with the
				content "Notes".

				If the ticket has been assigned a due date and time, then the element shall have a
				child with the content "Due".

				The description element shall have a child containing a description of the ticket,
				and the status element shall have a child containing the status of the ticket.

				The class element, if present, shall have a child containing the class of the
				ticket.
				
				The prerequisites element, if present, shall have a child for each prerequisite
				assigned, which shall contain the numerical IDs of the tickets to which they
				correspond as their content.
				
				The tags element, if present, shall have a child for each tag assigned, which shall
				contain the tags to which they correspond as their content.
				
				The notes element, if present, shall have a child for each note assigned, which
				shall contain the notes to which they correspond as their content.

				The due element, if present, shall have a single child containing the date and time
				at which the ticket is due as its content.
			-

		Ticket Log Library

			-
				A ticket log library is an organized collection of ticket log documents.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 3 - Development: 2 - Methods: 1 - Kaeon Process: 2 - Documentation: 2 - Formats: 3 - Journal Format'

Journal Format

	Philosophy

		-
			The journal format is a Kaeon document format used to record events relevant to a
			particular task or set of tasks, along with the time at which said event occured.

			A document in the journal log format is called a journal log document.
		-

	Principles

		Format

			-
				Every element in the principles section of a journal log document constitutes a
				journal entry and is thus called an entry element.

				An entry element shall have as its content the date and time at which it was added.

				An entry element shall have a child with the content "Entry", which itself shall
				have a child containing as its content the content of the entry, and shall have a
				child with the content "Author", which shall have a child specifying the author of
				the entry.

				An entry element may also have a child with the content "Tags", which may have an
				indefinite number of children, each containing as content a string tag relevant to
				the entry that it belongs to.

				An entry element may additionally have a child with the content "Notes", which may
				have an indefinite number of children, each of which shall follow the same format
				as an entry element, but which may not have the tags or notes elements, and which
				correspond to notes made regarding the entry to which it belongs after said entry
				itself was made.
			-

Use: Locations: 'Kaeon United Specification: 2 - Principles: 3 - Development: 2 - Methods: 2 - Kaeon Stack'

Kaeon Stack

	Philosophy
	
		-
			The Kaeon stack is a development stack that consists solely of Kaeon FUSION,
			JavaScript, United C, and assembly or machine code.
		-

	Principles

		Conventions

			Implementation

				Defaults

					-
						By default, the JavaScript used shall be United JavaScript, the C used
						shall be United C, and the machine code used shall be written in CSB.
					-

				Kaeon FUSION

					-	
						Under the conventions of the Kaeon stack, the runtime environment for Kaeon
						FUSION will be powered by JavaScript and may be embedded into HTML and CSS
						environments.
						
						Kaeon FUSION may also be cross compiled to JavaScript, C, or CSB if needed.

						It is also an option to have the Kaeon stack consist of Kaeon FUSION alone.
					-

			Suites

				Kaeon Suite

					-
						The Kaeon suite is a tool stack consisting of Node.js, git, the GNU
						compilers, and make.

						It is also a convention according to the Kaeon stack to use VS Code and
						Kaeon Origin as one's primary code editors and terminal interfaces.
					-

				Outer Yggdrasil

					-
						Outer Yggdrasil is a series of layers which constitute a model
						demonstrating the relationship between the underlying technologies of Kaeon
						META, using a tree as an analogy for its form, and named in contrast to the
						"inner" Kaeon Yggdrasil.

						The first layer is Kaeon United itself, followed by the Kaeon APIs,
						followed by Kaeon Origin. The aforementioned layers are referred to as the
						root layers, which are followed by the canopy layers, consisting of the
						Kaeon Apps, followed by Kaeon Kor.

						This model is embedded in the "soil" of Kaeon Sigma, and from this model
						spouts the "fruits" of Kaeon Ro.
					-

		Branding

			Kaeon FUSION
			
				-
					The tag line for Kaeon FUSION is "A language without limits!".
				-

			Kaeon United

				-
					The tag line for Kaeon United is "It just works."
				-